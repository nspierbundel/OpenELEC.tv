From cef01168572238112d543362f6b4a6dc65b38cf2 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 7 Apr 2014 18:19:32 +0100
Subject: [PATCH 01/89] [rbp/omxplayer] When opening a stream don't try to
 update gui so often

---
 xbmc/dialogs/GUIDialogBusy.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/xbmc/dialogs/GUIDialogBusy.cpp b/xbmc/dialogs/GUIDialogBusy.cpp
index 2faceea..889d7a2 100644
--- a/xbmc/dialogs/GUIDialogBusy.cpp
+++ b/xbmc/dialogs/GUIDialogBusy.cpp
@@ -68,7 +68,11 @@ bool CGUIDialogBusy::WaitOnEvent(CEvent &event, unsigned int displaytime /* = 10
     if (dialog)
     {
       dialog->Show();
+#ifdef TARGET_RASPBERRY_PI
+      while(!event.WaitMSec(100))
+#else
       while(!event.WaitMSec(1))
+#endif
       {
         g_windowManager.ProcessRenderLoop(false);
         if (allowCancel && dialog->IsCanceled())

From ac38c688a0443bd965bf167def9f30e105e7227c Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 29 Apr 2014 15:23:22 +0100
Subject: [PATCH 02/89] [ffmpeg] Speed up wtv index creation

The index creation is O(N^2) with number of entries (typically thousands).
On a Pi this can take more than 60 seconds to execute for a recording of a few hours.

By replacing with an O(N) loop, this takes virtually zero time
---
 tools/depends/target/ffmpeg/Makefile               |  3 +-
 .../ffmpeg_Speed_up_wtv_index_creation.patch       | 47 ++++++++++++++++++++++
 2 files changed, 49 insertions(+), 1 deletion(-)
 create mode 100644 tools/depends/target/ffmpeg/ffmpeg_Speed_up_wtv_index_creation.patch

diff --git a/tools/depends/target/ffmpeg/Makefile b/tools/depends/target/ffmpeg/Makefile
index 711182f..6e8364a 100644
--- a/tools/depends/target/ffmpeg/Makefile
+++ b/tools/depends/target/ffmpeg/Makefile
@@ -1,6 +1,6 @@
 include ../../Makefile.include
 include FFMPEG-VERSION
-DEPS= ../../Makefile.include FFMPEG-VERSION Makefile
+DEPS= ../../Makefile.include FFMPEG-VERSION Makefile ffmpeg_Speed_up_wtv_index_creation.patch
 
 # set to "yes" to enable patching
 # we don't apply patches until we move to a vanilla ffmpeg tarball
@@ -68,6 +68,7 @@ $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 	rm -rf $(PLATFORM); mkdir -p $(PLATFORM)
 	cd $(PLATFORM); $(ARCHIVE_TOOL) $(ARCHIVE_TOOL_FLAGS) $(TARBALLS_LOCATION)/$(ARCHIVE)
 	cd $(PLATFORM); sed -i".bak" -e "s%pkg_config_default=pkg-config%export PKG_CONFIG_LIBDIR=$(PREFIX)/lib/pkgconfig \&\& pkg_config_default=$(NATIVEPREFIX)/bin/pkg-config%" configure
+	cd $(PLATFORM); patch -p3 < ../ffmpeg_Speed_up_wtv_index_creation.patch
 	cd $(PLATFORM);\
 	CFLAGS="$(CFLAGS)" CXXFLAGS="$(CXXFLAGS)" CPPFLAGS="$(CPPFLAGS)" LDFLAGS="$(LDFLAGS)" \
 	./configure $(ffmpg_config)
diff --git a/tools/depends/target/ffmpeg/ffmpeg_Speed_up_wtv_index_creation.patch b/tools/depends/target/ffmpeg/ffmpeg_Speed_up_wtv_index_creation.patch
new file mode 100644
index 0000000..4ac5636
--- /dev/null
+++ b/tools/depends/target/ffmpeg/ffmpeg_Speed_up_wtv_index_creation.patch
@@ -0,0 +1,47 @@
+commit 0e7427498cb1131671f6fe9d054245ae7e5a36f5
+Author: popcornmix <popcornmix@gmail.com>
+Date:   Tue Mar 25 19:43:07 2014 +0000
+
+    [ffmpeg] Speed up wtv index creation
+
+    The index creation is O(N^2) with number of entries (typically thousands).
+    On a Pi this can take more than 60 seconds to execute for a recording of a few hours.
+
+    By replacing with an O(N) loop, this takes virtually zero time
+
+diff --git a/lib/ffmpeg/libavformat/wtvdec.c b/lib/ffmpeg/libavformat/wtvdec.c
+index e423370..70898bd 100644
+--- a/lib/ffmpeg/libavformat/wtvdec.c
++++ b/lib/ffmpeg/libavformat/wtvdec.c
+@@ -980,21 +980,23 @@ static int read_header(AVFormatContext *s)
+                 pb = wtvfile_open(s, root, root_size, ff_timeline_table_0_entries_Events_le16);
+                 if (pb) {
+                     int i;
++                    AVIndexEntry *e = wtv->index_entries;
++                    AVIndexEntry *e_end = wtv->index_entries + wtv->nb_index_entries - 1;
++                    uint64_t last_position = 0;
+                     while (1) {
+                         uint64_t frame_nb = avio_rl64(pb);
+                         uint64_t position = avio_rl64(pb);
++                        while (frame_nb > e->size && e <= e_end) {
++                           e->pos = last_position;
++                           e++;
++                        }
+                         if (avio_feof(pb))
+                             break;
+-                        for (i = wtv->nb_index_entries - 1; i >= 0; i--) {
+-                            AVIndexEntry *e = wtv->index_entries + i;
+-                            if (frame_nb > e->size)
+-                                break;
+-                            if (position > e->pos)
+-                                e->pos = position;
+-                        }
++                        last_position = position;
+                     }
++                    e_end->pos = last_position;
+                     wtvfile_close(pb);
+-                    st->duration = wtv->index_entries[wtv->nb_index_entries - 1].timestamp;
++                    st->duration = e_end->timestamp;
+                 }
+             }
+         }

From 10fca829203615581df049df3ab697eb26a0df13 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 2 Aug 2014 17:48:04 +0100
Subject: [PATCH 03/89] [omx] Report decoded image name

---
 xbmc/cores/omxplayer/OMXImage.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/xbmc/cores/omxplayer/OMXImage.cpp b/xbmc/cores/omxplayer/OMXImage.cpp
index a43a446..d99d719 100644
--- a/xbmc/cores/omxplayer/OMXImage.cpp
+++ b/xbmc/cores/omxplayer/OMXImage.cpp
@@ -327,6 +327,7 @@ bool COMXImage::DecodeJpegToTexture(COMXImageFile *file, unsigned int width, uns
   {
     ret = true;
     *userdata = tex;
+    CLog::Log(LOGDEBUG, "%s: decoded %s %dx%d", __func__, file->GetFilename(), width, height);
   }
   else
   {

From db0a6dc35272b3b14e9c463ed357ebd9df0431be Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 8 Mar 2014 15:36:06 +0000
Subject: [PATCH 04/89] [hifiberry] Hack: force it to be recognised as IEC958
 capable to enable passthrough options

---
 xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
index e22db7a..0120bd5 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
@@ -1342,6 +1342,10 @@ void CAESinkALSA::EnumerateDevice(AEDeviceInfoList &list, const std::string &dev
     if (snd_card_get_name(cardNr, &cardName) == 0)
       info.m_displayName = cardName;
 
+    // hack: hifiberry digi doesn't correctly report as iec958 device. Needs fixing in kernel driver
+    if (info.m_displayName == "snd_rpi_hifiberry_digi")
+      info.m_deviceType = AE_DEVTYPE_IEC958;
+
     if (info.m_deviceType == AE_DEVTYPE_HDMI && info.m_displayName.size() > 5 &&
         info.m_displayName.substr(info.m_displayName.size()-5) == " HDMI")
     {

From d21d0015b0df19c700e1c63d5525546cc5f71f15 Mon Sep 17 00:00:00 2001
From: Ben Avison <bavison@riscosopen.org>
Date: Thu, 1 May 2014 16:28:39 +0100
Subject: [PATCH 05/89] Improved file buffering in CArchive

Even though memcpy is typically inlined by the compiler into byte/word loads
and stores (at least for release builds), the frequency with which 1, 2 and 4
byte loads/stores are encountered in cases where the size is *not*
determinable at compile time is still high enough that it's worth handling
these specially. On the ARM1176JZF-S in the Raspberry Pi, this improves the
total time to open a library (in the case where it's fetched from a CArchive)
by around 4%.

It should be noted that this code uses 16-bit and 32-bit word loads and
stores that are not necessarily aligned to their respective widths. It is
possible that there are some architectures out there which do not support
this, although all ARMs since ARMv6 have supported it (and ARMs earlier than
that are probably not powerful enough to be good targets for XBMC).
---
 xbmc/utils/Archive.h | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/xbmc/utils/Archive.h b/xbmc/utils/Archive.h
index 6ed0f8f..8506d95 100644
--- a/xbmc/utils/Archive.h
+++ b/xbmc/utils/Archive.h
@@ -154,9 +154,17 @@ class CArchive
      * than waiting until we attempt to put more data into an already full buffer */
     if (m_BufferRemain > size)
     {
+      switch (size)
+      {
+      case 1: *m_BufferPos++ = *ptr; m_BufferRemain--; break;
+      case 2: *(uint16_t *) m_BufferPos = *(const uint16_t *) ptr; m_BufferPos += 2; m_BufferRemain -= 2; break;
+      case 4: *(uint32_t *) m_BufferPos = *(const uint32_t *) ptr; m_BufferPos += 4; m_BufferRemain -= 4; break;
+      default:
       memcpy(m_BufferPos, ptr, size);
       m_BufferPos += size;
       m_BufferRemain -= size;
+      break;
+      }
       return *this;
     }
     else
@@ -171,9 +179,17 @@ class CArchive
     /* Note, refilling the buffer is deferred until we know we need to read more from it */
     if (m_BufferRemain >= size)
     {
+      switch (size)
+      {
+      case 1: *ptr = *m_BufferPos++; m_BufferRemain--; break;
+      case 2: *(uint16_t *) ptr = *(const uint16_t *) m_BufferPos; m_BufferPos += 2; m_BufferRemain -= 2; break;
+      case 4: *(uint32_t *) ptr = *(const uint32_t *) m_BufferPos; m_BufferPos += 4; m_BufferRemain -= 4; break;
+      default:
       memcpy(ptr, m_BufferPos, size);
       m_BufferPos += size;
       m_BufferRemain -= size;
+      break;
+      }
       return *this;
     }
     else

From 02ffcb9c5cac171a3fb3e8ace0fb24fda0dd0db0 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 12 Aug 2014 00:31:36 +0100
Subject: [PATCH 06/89] [omxcodec] Don't force software codec with dvds

---
 xbmc/cores/dvdplayer/DVDPlayer.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/xbmc/cores/dvdplayer/DVDPlayer.cpp b/xbmc/cores/dvdplayer/DVDPlayer.cpp
index 143ea06..e029c16 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayer.cpp
@@ -3345,7 +3345,9 @@ bool CDVDPlayer::OpenVideoStream(CDVDStreamInfo& hint, bool reset)
       hint.aspect = aspect;
       hint.forced_aspect = true;
     }
+#ifndef TARGET_RASPBERRY_PI
     hint.software = true;
+#endif
   }
   else if (m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
   {

From 965be36a5564ce176d5d9c135b313e2323395242 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sun, 10 Aug 2014 16:45:16 +0100
Subject: [PATCH 07/89] filesystem: Make support of browsing into archives
 optional

The ability to browse, scan and play content in archives can cause problems on low powered/low memory devices.
It's quite common to see reports of a large rar file that causes xbmc to crash with an out-of-memory error when browsing or scanning.
It also can be slow as any archive in the directory is opened and extracted.

This causes issues for people who scan library with archives disabled, then subsequently enable it.
The library has the .rar files in which don't play without removing and re-adding.

We'll let people who don't use archives disable it manually
---
 addons/resource.language.en_gb/resources/strings.po | 9 +++++++++
 system/settings/settings.xml                        | 5 +++++
 xbmc/filesystem/FileDirectoryFactory.cpp            | 4 ++++
 3 files changed, 18 insertions(+)

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index dedca23..629f726 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -16527,6 +16527,15 @@ msgstr ""
 #: system/settings/rbp.xml
 msgctxt "#38010"
 msgid "GPU accelerated"
+
+#: system/settings/settings.xml
+msgctxt "#38020"
+msgid "Support browsing into archives"
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#38021"
+msgid "Allow viewing and playing files in archives (e.g. zip, rar)"
 msgstr ""
 
 #. Setting #38011 "Videos -> Library -> Show All Items entry"
diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index 3940ca8..8f1bfc4 100644
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -304,6 +304,11 @@
           <default>false</default>
           <control type="toggle" />
         </setting>
+        <setting id="filelists.browsearchives" type="boolean" label="38020" help="38021">
+          <level>1</level>
+          <default>true</default>
+          <control type="toggle" />
+        </setting>
       </group>
     </category>
     <category id="screensaver" label="360" help="36128">
diff --git a/xbmc/filesystem/FileDirectoryFactory.cpp b/xbmc/filesystem/FileDirectoryFactory.cpp
index 3a5ba4e..f1f6f79 100644
--- a/xbmc/filesystem/FileDirectoryFactory.cpp
+++ b/xbmc/filesystem/FileDirectoryFactory.cpp
@@ -41,6 +41,7 @@
 #include "Directory.h"
 #include "File.h"
 #include "ZipManager.h"
+#include "settings/Settings.h"
 #include "settings/AdvancedSettings.h"
 #include "FileItem.h"
 #include "utils/StringUtils.h"
@@ -115,6 +116,8 @@ IFileDirectory* CFileDirectoryFactory::Create(const CURL& url, CFileItem* pItem,
     return NULL;
   }
 #endif
+  if (CSettings::Get().GetBool("filelists.browsearchives"))
+  {
   if (url.IsFileType("zip"))
   {
     CURL zipURL = URIUtils::CreateArchivePath("zip", url);
@@ -188,6 +191,7 @@ IFileDirectory* CFileDirectoryFactory::Create(const CURL& url, CFileItem* pItem,
     }
     return NULL;
   }
+  }
   if (url.IsFileType("xsp"))
   { // XBMC Smart playlist - just XML renamed to XSP
     // read the name of the playlist in

From d1698689aedc5255eaf125d2bbf7940c6ce8b1e2 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 27 Oct 2014 13:06:57 +0000
Subject: [PATCH 09/89] [rbp] Make cachemembuffersize default depend on memory
 size

---
 xbmc/linux/RBP.cpp                 | 5 +++++
 xbmc/settings/AdvancedSettings.cpp | 5 +++++
 2 files changed, 10 insertions(+)

diff --git a/xbmc/linux/RBP.cpp b/xbmc/linux/RBP.cpp
index 59dd1da..aedae18 100644
--- a/xbmc/linux/RBP.cpp
+++ b/xbmc/linux/RBP.cpp
@@ -23,6 +23,7 @@
 
 #include <assert.h>
 #include "settings/Settings.h"
+#include "settings/AdvancedSettings.h"
 #include "utils/log.h"
 
 #include "cores/omxplayer/OMXImage.h"
@@ -82,6 +83,9 @@ bool CRBP::Initialize()
   if (!m_gui_resolution_limit)
     m_gui_resolution_limit = m_gpu_mem < 128 ? 720:1080;
 
+  if (g_advancedSettings.m_cacheMemBufferSize == ~0U)
+    g_advancedSettings.m_cacheMemBufferSize = m_arm_mem < 256 ? 1024 * 1024 * 2 : 1024 * 1024 * 20;
+
   g_OMXImage.Initialize();
   m_omx_image_init = true;
   return true;
@@ -94,6 +98,7 @@ void CRBP::LogFirmwareVerison()
   response[sizeof(response) - 1] = '\0';
   CLog::Log(LOGNOTICE, "Raspberry PI firmware version: %s", response);
   CLog::Log(LOGNOTICE, "ARM mem: %dMB GPU mem: %dMB MPG2:%d WVC1:%d", m_arm_mem, m_gpu_mem, m_codec_mpg2_enabled, m_codec_wvc1_enabled);
+  CLog::Log(LOGNOTICE, "cacheMemBufferSize: %dMB",  g_advancedSettings.m_cacheMemBufferSize >> 20);
   m_DllBcmHost->vc_gencmd(response, sizeof response, "get_config int");
   response[sizeof(response) - 1] = '\0';
   CLog::Log(LOGNOTICE, "Config:\n%s", response);
diff --git a/xbmc/settings/AdvancedSettings.cpp b/xbmc/settings/AdvancedSettings.cpp
index fab9a82..25ef7b8 100644
--- a/xbmc/settings/AdvancedSettings.cpp
+++ b/xbmc/settings/AdvancedSettings.cpp
@@ -352,7 +352,12 @@ void CAdvancedSettings::Initialize()
   m_bPVRAutoScanIconsUserSet       = false;
   m_iPVRNumericChannelSwitchTimeout = 1000;
 
+#ifdef TARGET_RASPBERRY_PI
+  // want default to be memory dependent, but interface to gpu not available yet, so set in RBP.cpp
+  m_cacheMemBufferSize = ~0;
+#else
   m_cacheMemBufferSize = 1024 * 1024 * 20;
+#endif
   m_networkBufferMode = 0; // Default (buffer all internet streams/filesystems)
   // the following setting determines the readRate of a player data
   // as multiply of the default data read rate


From 1690732bafc24f041aabaccd168f35e86ebdbbd2 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 30 May 2014 14:58:43 +0100
Subject: [PATCH 11/89] [settings] Experiment: Report DESKTOP resolution in
 video settings

---
 xbmc/settings/DisplaySettings.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/xbmc/settings/DisplaySettings.cpp b/xbmc/settings/DisplaySettings.cpp
index 1fafd9a..e0288aa 100644
--- a/xbmc/settings/DisplaySettings.cpp
+++ b/xbmc/settings/DisplaySettings.cpp
@@ -674,6 +674,9 @@ void CDisplaySettings::SettingOptionsResolutionsFiller(const CSetting *setting,
     vector<RESOLUTION_WHR> resolutions = g_Windowing.ScreenResolutions(info.iScreen, info.fRefreshRate);
     for (vector<RESOLUTION_WHR>::const_iterator resolution = resolutions.begin(); resolution != resolutions.end(); ++resolution)
     {
+if (resolution->ResInfo_Index == RES_DESKTOP)
+      list.push_back(make_pair(StringUtils::Format("DESKTOP"), resolution->ResInfo_Index));
+else
       list.push_back(make_pair(
         StringUtils::Format("%dx%d%s", resolution->width, resolution->height,
                             ModeFlagsToString(resolution->flags, false).c_str()),

From 2e5b318953c5635129b69c01f24919392b0af5da Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 9 Sep 2014 12:04:26 +0100
Subject: [PATCH 12/89] egl: Treat unknown display aspect ratio as square pixel

---
 xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
index bda7430..68fc647 100644
--- a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
@@ -447,7 +447,7 @@ bool CEGLNativeTypeRaspberryPI::ProbeResolutions(std::vector<RESOLUTION_INFO> &r
       m_desktopRes.iScreenWidth = tv_state.display.hdmi.width;
       m_desktopRes.iScreenHeight= tv_state.display.hdmi.height;
       m_desktopRes.dwFlags      = MAKEFLAGS(tv_state.display.hdmi.group, tv_state.display.hdmi.mode, tv_state.display.hdmi.scan_mode);
-      m_desktopRes.fPixelRatio  = get_display_aspect_ratio((HDMI_ASPECT_T)tv_state.display.hdmi.display_options.aspect) / ((float)m_desktopRes.iScreenWidth / (float)m_desktopRes.iScreenHeight);
+      m_desktopRes.fPixelRatio  = tv_state.display.hdmi.display_options.aspect == 0 ? 1.0f : get_display_aspect_ratio((HDMI_ASPECT_T)tv_state.display.hdmi.display_options.aspect) / ((float)m_desktopRes.iScreenWidth / (float)m_desktopRes.iScreenHeight);
       // Also add 3D flags
       if (tv_state.display.hdmi.format_3d == HDMI_3D_FORMAT_SBS_HALF)
       {
@@ -474,7 +474,7 @@ bool CEGLNativeTypeRaspberryPI::ProbeResolutions(std::vector<RESOLUTION_INFO> &r
       m_desktopRes.iScreenHeight= tv_state.display.sdtv.height;
       m_desktopRes.dwFlags      = D3DPRESENTFLAG_INTERLACED;
       m_desktopRes.fRefreshRate = (float)tv_state.display.sdtv.frame_rate;
-      m_desktopRes.fPixelRatio  = get_display_aspect_ratio((SDTV_ASPECT_T)tv_state.display.sdtv.display_options.aspect) / ((float)m_desktopRes.iScreenWidth / (float)m_desktopRes.iScreenHeight);
+      m_desktopRes.fPixelRatio  = tv_state.display.hdmi.display_options.aspect == 0 ? 1.0f : get_display_aspect_ratio((SDTV_ASPECT_T)tv_state.display.sdtv.display_options.aspect) / ((float)m_desktopRes.iScreenWidth / (float)m_desktopRes.iScreenHeight);
     }
 
     SetResolutionString(m_desktopRes);

From f585eaf62527f49edaa92c95322968c05189ac2f Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 19 Sep 2014 11:54:49 +0100
Subject: [PATCH 13/89] [dvdplayer/rbp] Add pi specific option to maintain
 vsync with pll adjustment

New A/V sync option in settings/video/playback to do "Adjust PLL".
This uses video clock (so perfect video syncing) but avoids having to resample
or drop/dupe audio packets which is normally required.

Needed updated firmware

[dvdplayeraudio] Add advancedsetting for configuring max pll adjustment

[dvdplayer] Allow pll adjustment to go higher, but tail off more gradually
---
 .../resource.language.en_gb/resources/strings.po   | 24 ++++++++++++++-
 system/settings/settings.xml                       | 14 +++++++++
 xbmc/cores/AudioEngine/Utils/AEUtil.h              |  3 +-
 xbmc/cores/dvdplayer/DVDPlayerAudio.cpp            | 36 +++++++++++++++++++---
 xbmc/cores/dvdplayer/DVDPlayerAudio.h              |  3 ++
 xbmc/linux/RBP.cpp                                 | 14 +++++++++
 xbmc/linux/RBP.h                                   |  1 +
 xbmc/settings/AdvancedSettings.cpp                 |  2 ++
 xbmc/settings/AdvancedSettings.h                   |  1 +
 9 files changed, 91 insertions(+), 7 deletions(-)

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index 629f726..129f0c7 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -6336,7 +6336,22 @@ msgctxt "#13459"
 msgid "Use OMXPlayer for decoding of video files."
 msgstr ""
 
-#empty strings from id 13460 to 13504
+#empty strings from id 13460 to 13499
+
+#: system/settings/settings.xml
+msgctxt "#13500"
+msgid "A/V sync method"
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#13503"
+msgid "Resample audio"
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#13504"
+msgid "Adjust PLL"
+msgstr ""
 
 #: system/settings/settings.xml
 msgctxt "#13505"
@@ -16573,3 +16588,10 @@ msgstr ""
 msgctxt "#38016"
 msgid "%d fps"
 msgstr ""
+
+#. Description of setting "Videos -> Playback -> A/V sync method" with label #13500
+#: system/settings/settings.xml
+msgctxt "#38006"
+msgid "Audio has to stay in sync, this can either be done by resampling, or adjusting the PLL"
+msgstr ""
+
diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index 8f1bfc4..ad90e8c 100644
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -572,6 +572,20 @@
           <default>false</default>
           <control type="toggle" />
         </setting>
+        <setting id="videoplayer.synctype" type="integer" parent="videoplayer.usedisplayasclock" label="13500" help="38006">
+          <level>2</level>
+          <default>2</default> <!-- SYNC_RESAMPLE -->
+          <constraints>
+            <options>
+              <option label="13503">2</option> <!-- SYNC_RESAMPLE -->
+              <option label="13504">3</option> <!-- SYNC_PLLADJUST -->
+            </options>
+          </constraints>
+          <dependencies>
+            <dependency type="enable" setting="videoplayer.usedisplayasclock" operator="is">true</dependency>
+          </dependencies>
+          <control type="spinner" format="string" />
+        </setting>
         <setting id="videoplayer.errorinaspect" type="integer" label="22021" help="36170">
           <level>2</level>
           <default>0</default>
diff --git a/xbmc/cores/AudioEngine/Utils/AEUtil.h b/xbmc/cores/AudioEngine/Utils/AEUtil.h
index 782a9ba..3e0390c 100644
--- a/xbmc/cores/AudioEngine/Utils/AEUtil.h
+++ b/xbmc/cores/AudioEngine/Utils/AEUtil.h
@@ -57,7 +57,8 @@ enum AVSync
 {
   SYNC_DISCON   = 0,
   SYNC_SKIPDUP,
-  SYNC_RESAMPLE
+  SYNC_RESAMPLE,
+  SYNC_PLLADJUST
 };
 
 struct AEDelayStatus
diff --git a/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp b/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp
index a345a88..bd357aa 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp
@@ -25,6 +25,7 @@
 #include "DVDCodecs/DVDCodecs.h"
 #include "DVDCodecs/DVDFactoryCodec.h"
 #include "settings/Settings.h"
+#include "settings/AdvancedSettings.h"
 #include "video/VideoReferenceClock.h"
 #include "utils/log.h"
 #include "utils/TimeUtils.h"
@@ -113,6 +114,9 @@ CDVDPlayerAudio::CDVDPlayerAudio(CDVDClock* pClock, CDVDMessageQueue& parent)
   m_started = false;
   m_silence = false;
   m_resampleratio = 1.0;
+  m_plladjust = 1.0;
+  m_last_plladjust = 1.0;
+  m_last_error = 0.0;
   m_synctype = SYNC_DISCON;
   m_setsynctype = SYNC_DISCON;
   m_prevsynctype = -1;
@@ -186,11 +190,13 @@ void CDVDPlayerAudio::OpenStream( CDVDStreamInfo &hints, CDVDAudioCodec* codec )
   m_synctype = SYNC_DISCON;
   m_setsynctype = SYNC_DISCON;
   if (CSettings::Get().GetBool("videoplayer.usedisplayasclock"))
-    m_setsynctype = SYNC_RESAMPLE;
+    m_setsynctype = CSettings::Get().GetInt("videoplayer.synctype");
   m_prevsynctype = -1;
 
   m_error = 0;
   m_errors.Flush();
+  m_plladjust = 1.0;
+  m_last_plladjust = 1.0;
   m_integral = 0;
   m_prevskipped = false;
   m_syncclock = true;
@@ -233,7 +239,6 @@ void CDVDPlayerAudio::CloseStream(bool bWaitForBuffers)
 
   // uninit queue
   m_messageQueue.End();
-
   CLog::Log(LOGNOTICE, "Deleting audio codec");
   if (m_pAudioCodec)
   {
@@ -486,7 +491,11 @@ void CDVDPlayerAudio::UpdatePlayerInfo()
   //print the inverse of the resample ratio, since that makes more sense
   //if the resample ratio is 0.5, then we're playing twice as fast
   if (m_synctype == SYNC_RESAMPLE)
-    s << ", rr:" << fixed << setprecision(5) << 1.0 / m_resampleratio;
+    s << ", rr:" << fixed << setprecision(5) << 1.0 / m_resampleratio << ", err:" << fixed << setprecision(1) << m_last_error * 1e-3 << "ms";
+  if (m_synctype == SYNC_SKIPDUP)
+    s << ", err:" << fixed << setprecision(1) << m_last_error * 1e-3 << "ms";
+  if (m_synctype == SYNC_PLLADJUST)
+    s << ", pll:" << fixed << setprecision(5) << m_last_plladjust << ", err:" << fixed << setprecision(1) << m_last_error * 1e-3 << "ms";
 
   s << ", att:" << fixed << setprecision(1) << log(GetCurrentAttenuation()) * 20.0f << " dB";
 
@@ -641,8 +650,8 @@ void CDVDPlayerAudio::SetSyncType(bool passthrough)
 
   if (m_synctype != m_prevsynctype)
   {
-    const char *synctypes[] = {"clock feedback", "skip/duplicate", "resample", "invalid"};
-    int synctype = (m_synctype >= 0 && m_synctype <= 2) ? m_synctype : 3;
+    const char *synctypes[] = {"clock feedback", "skip/duplicate", "resample", "pll adjust", "invalid"};
+    int synctype = (m_synctype >= 0 && m_synctype <= 3) ? m_synctype : 4;
     CLog::Log(LOGDEBUG, "CDVDPlayerAudio:: synctype set to %i: %s", m_synctype, synctypes[synctype]);
     m_prevsynctype = m_synctype;
   }
@@ -752,7 +761,19 @@ void CDVDPlayerAudio::HandleSyncError(double duration)
       proportional = m_error / DVD_TIME_BASE / proportionaldiv;
     }
     m_resampleratio = 1.0 / m_pClock->GetClockSpeed() + proportional + m_integral;
+    CLog::Log(LOGDEBUG, "CDVDPlayerAudio::%s rr:%.5f error:%.3fms", __FUNCTION__, m_resampleratio, m_error * 1e-3);
+  }
+  else if (m_synctype == SYNC_PLLADJUST)
+  {
+#if defined(TARGET_RASPBERRY_PI)
+    double e = std::max(std::min(m_error / DVD_MSEC_TO_TIME(50), 1.0), -1.0);
+    double adjust = g_advancedSettings.m_maxPllAdjust * 1e-6;
+    m_plladjust = 1.0 + e * adjust;
+    m_last_plladjust = g_RBP.AdjustHDMIClock(m_plladjust);
+    CLog::Log(LOGDEBUG, "CDVDPlayerAudio::%s pll:%.5f (%.5f) error:%.6f e:%.6f a:%f", __FUNCTION__, m_plladjust, m_last_plladjust, m_error, e * adjust, adjust );
+#endif
   }
+  m_last_error = m_error;
 }
 
 bool CDVDPlayerAudio::OutputPacket(DVDAudioFrame &audioframe)
@@ -805,6 +826,7 @@ bool CDVDPlayerAudio::OutputPacket(DVDAudioFrame &audioframe)
     {
       m_dvdAudio.AddPackets(audioframe);
     }
+    m_plladjust = 1.0;
   }
   else if (m_synctype == SYNC_DISCON)
   {
@@ -839,6 +861,10 @@ bool CDVDPlayerAudio::OutputPacket(DVDAudioFrame &audioframe)
     m_dvdAudio.SetResampleRatio(m_resampleratio);
     m_dvdAudio.AddPackets(audioframe);
   }
+  else if (m_synctype == SYNC_PLLADJUST)
+  {
+    m_dvdAudio.AddPackets(audioframe);
+  }
 
   return true;
 }
diff --git a/xbmc/cores/dvdplayer/DVDPlayerAudio.h b/xbmc/cores/dvdplayer/DVDPlayerAudio.h
index 99ce952..635c184 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerAudio.h
+++ b/xbmc/cores/dvdplayer/DVDPlayerAudio.h
@@ -232,6 +232,9 @@ class CDVDPlayerAudio : public CThread, public IDVDStreamPlayerAudio
   bool   m_prevskipped;
   double m_maxspeedadjust;
   double m_resampleratio; //resample ratio when using SYNC_RESAMPLE, used for the codec info
+  double m_plladjust;    // for display using SYNC_PLLADJUST
+  double m_last_error;    // for display using SYNC_PLLADJUST
+  double m_last_plladjust;    // for display using SYNC_PLLADJUST
 
   struct SInfo
   {
diff --git a/xbmc/linux/RBP.cpp b/xbmc/linux/RBP.cpp
index aedae18..a4b0c2a 100644
--- a/xbmc/linux/RBP.cpp
+++ b/xbmc/linux/RBP.cpp
@@ -220,4 +220,18 @@ void CRBP::Deinitialize()
   m_initialized     = false;
   m_omx_initialized = false;
 }
+
+double CRBP::AdjustHDMIClock(double adjust)
+{
+  char response[80];
+  vc_gencmd(response, sizeof response, "hdmi_adjust_clock %f", adjust);
+  float new_adjust = 1.0f;
+  char *p = strchr(response, '=');
+  if (p)
+    new_adjust = atof(p+1);
+  CLog::Log(LOGDEBUG, "CRBP::%s(%.4f) = %.4f", __func__, adjust, new_adjust);
+  return new_adjust;
+}
+
+
 #endif
diff --git a/xbmc/linux/RBP.h b/xbmc/linux/RBP.h
index 9559914..65492fa 100644
--- a/xbmc/linux/RBP.h
+++ b/xbmc/linux/RBP.h
@@ -63,6 +63,7 @@ class CRBP
   unsigned char *CaptureDisplay(int width, int height, int *stride, bool swap_red_blue, bool video_only = true);
   DllOMX *GetDllOMX() { return m_OMX ? m_OMX->GetDll() : NULL; }
   void WaitVsync();
+  double AdjustHDMIClock(double adjust);
 
 private:
   DllBcmHost *m_DllBcmHost;
diff --git a/xbmc/settings/AdvancedSettings.cpp b/xbmc/settings/AdvancedSettings.cpp
index 25ef7b8..76b5ce8 100644
--- a/xbmc/settings/AdvancedSettings.cpp
+++ b/xbmc/settings/AdvancedSettings.cpp
@@ -110,6 +110,7 @@ void CAdvancedSettings::Initialize()
   m_audioHeadRoom = 0;
   m_ac3Gain = 12.0f;
   m_audioApplyDrc = -1.0f;
+  m_maxPllAdjust = 1000;
   m_dvdplayerIgnoreDTSinWAV = false;
 
   //default hold time of 25 ms, this allows a 20 hertz sine to pass undistorted
@@ -468,6 +469,7 @@ void CAdvancedSettings::ParseSettingsFile(const std::string &file)
   if (pElement)
   {
     XMLUtils::GetFloat(pElement, "ac3downmixgain", m_ac3Gain, -96.0f, 96.0f);
+    XMLUtils::GetInt(pElement, "maxplladjust", m_maxPllAdjust, 0, 1000000);
     XMLUtils::GetInt(pElement, "headroom", m_audioHeadRoom, 0, 12);
     XMLUtils::GetString(pElement, "defaultplayer", m_audioDefaultPlayer);
     // 101 on purpose - can be used to never automark as watched
diff --git a/xbmc/settings/AdvancedSettings.h b/xbmc/settings/AdvancedSettings.h
index b0b4df1..5e0b14c 100644
--- a/xbmc/settings/AdvancedSettings.h
+++ b/xbmc/settings/AdvancedSettings.h
@@ -141,6 +141,7 @@ class CAdvancedSettings : public ISettingCallback, public ISettingsHandler
 
     int m_audioHeadRoom;
     float m_ac3Gain;
+    int m_maxPllAdjust;
     std::string m_audioDefaultPlayer;
     float m_audioPlayCountMinimumPercent;
     bool m_dvdplayerIgnoreDTSinWAV;

From dfbee238810b1825c24c466b6f7c90140a6c602f Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 27 Sep 2014 15:32:37 +0100
Subject: [PATCH 14/89] [dvdplayer] exerimental: don't raise priority of audio
 thread

---
 xbmc/cores/dvdplayer/DVDPlayer.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/xbmc/cores/dvdplayer/DVDPlayer.cpp b/xbmc/cores/dvdplayer/DVDPlayer.cpp
index e029c16..63f4a30 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayer.cpp
@@ -3330,7 +3330,11 @@ bool CDVDPlayer::OpenAudioStream(CDVDStreamInfo& hint, bool reset)
   m_dvdPlayerAudio->SendMessage(new CDVDMsg(CDVDMsg::PLAYER_STARTED), 1);
 
   /* audio normally won't consume full cpu, so let it have prio */
+#ifdef TARGET_RASPBERRY_PI
+  m_dvdPlayerAudio->SetPriority(GetPriority());
+#else
   m_dvdPlayerAudio->SetPriority(GetPriority()+1);
+#endif
   return true;
 }
 

From e8a3d13ea42fc7a4f654a1b1b419a5cf0e3a1edc Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 24 Sep 2014 23:13:52 +0100
Subject: [PATCH 15/89] [audio] Add settings option to boost centre channel
 when downmixing

This allows a dB volume increase to be added to centre channel.
This can help improve dialgue in the presence of background music/effects.
It can go up to 30dB for testing purposes, but value of 6 is probably more reasonable.
It is recommended to ensure "Normalise levels on downmix" is enabled when boosting by large values to avoid clipping.

Should work with Pi Sink (dvdplayer/paplayer) and omxplayer
---
 addons/resource.language.en_gb/resources/strings.po        | 14 ++++++++++++++
 system/settings/settings.xml                               | 12 ++++++++++++
 .../Engines/ActiveAE/ActiveAEResampleFFMPEG.cpp            |  7 +++++++
 .../AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp    |  6 ++++++
 xbmc/cores/omxplayer/OMXAudio.cpp                          |  6 ++++++
 5 files changed, 45 insertions(+)

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index 129f0c7..7f44813 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -16595,3 +16595,17 @@ msgctxt "#38006"
 msgid "Audio has to stay in sync, this can either be done by resampling, or adjusting the PLL"
 msgstr ""
 
+#: system/settings/settings.xml
+msgctxt "#38007"
+msgid "Boost centre channel when downmixing"
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#38008"
+msgid "Increase this value to make the dialogue louder compared to background sounds when downmixing multichannel audio"
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#38009"
+msgid "%i dB"
+msgstr ""
diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index ad90e8c..ede89e4 100644
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -2645,6 +2645,18 @@
           <default>true</default>
           <control type="toggle" />
         </setting>
+         <setting id="audiooutput.boostcenter" type="integer" label="38007" help="38008">
+          <level>2</level>
+          <default>0</default>
+          <constraints>
+            <minimum>0</minimum>
+            <step>1</step>
+            <maximum>30</maximum>
+          </constraints>
+          <control type="spinner" format="string">
+            <formatlabel>38009</formatlabel>
+          </control>
+        </setting>
         <setting id="audiooutput.processquality" type="integer" label="13505" help="36169">
           <requirement>HAS_AE_QUALITY_LEVELS</requirement>
           <level>2</level>
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResampleFFMPEG.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResampleFFMPEG.cpp
index e4ddf9e..34d0152 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResampleFFMPEG.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResampleFFMPEG.cpp
@@ -20,6 +20,7 @@
 
 #include "cores/AudioEngine/Utils/AEUtil.h"
 #include "ActiveAEResampleFFMPEG.h"
+#include "settings/Settings.h"
 #include "utils/log.h"
 
 extern "C" {
@@ -105,6 +106,12 @@ bool CActiveAEResampleFFMPEG::Init(uint64_t dst_chan_layout, int dst_channels, i
   {
      av_opt_set_double(m_pContext, "rematrix_maxval", 1.0, 0);
   }
+  int boost_center = CSettings::Get().GetInt("audiooutput.boostcenter");
+  if (boost_center)
+  {
+    float gain = pow(10.0f, ((float)(-3 + boost_center))/20.0f);
+    av_opt_set_double(m_pContext, "center_mix_level", gain, 0);
+  }
 
   if (remapLayout)
   {
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp
index 7807149..759ba7b 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp
@@ -164,6 +164,12 @@ bool CActiveAEResamplePi::Init(uint64_t dst_chan_layout, int dst_channels, int d
   {
     av_opt_set_double(m_pContext, "rematrix_maxval", 1.0, 0);
   }
+  int boost_center = CSettings::Get().GetInt("audiooutput.boostcenter");
+  if (boost_center)
+  {
+    float gain = pow(10.0f, ((float)(-3 + boost_center))/20.0f);
+    av_opt_set_double(m_pContext, "center_mix_level", gain, 0);
+  }
 
   if (remapLayout)
   {
diff --git a/xbmc/cores/omxplayer/OMXAudio.cpp b/xbmc/cores/omxplayer/OMXAudio.cpp
index f99c0e6..1911189 100644
--- a/xbmc/cores/omxplayer/OMXAudio.cpp
+++ b/xbmc/cores/omxplayer/OMXAudio.cpp
@@ -641,6 +641,12 @@ bool COMXAudio::Initialize(AEAudioFormat format, OMXClock *clock, CDVDStreamInfo
     {
        av_opt_set_double(m_pContext, "rematrix_maxval", 1.0, 0);
     }
+    int boost_center = CSettings::Get().GetInt("audiooutput.boostcenter");
+    if (boost_center)
+    {
+      float gain = pow(10.0f, ((float)(-3 + boost_center))/20.0f);
+      av_opt_set_double(m_pContext, "center_mix_level", gain, 0);
+    }
 
     // stereo upmix
     if (upmix && m_src_channels == 2 && m_dst_channels > 2)

From 726e56391004744900c2ab04c27e58a3e21f0d44 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 3 Oct 2014 18:40:06 +0100
Subject: [PATCH 16/89] [SinkPi] Handle multichannel layout more like OMXAudio

---
 xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp | 14 +++++++-------
 1 file changed, 7 insertions(+), 7 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp
index a7691e8..d72a97a 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp
@@ -94,9 +94,9 @@ static void SetAudioProps(bool stream_channels, uint32_t channel_map)
   CLog::Log(LOGDEBUG, "%s:%s hdmi_stream_channels %d hdmi_channel_map %08x", CLASSNAME, __func__, stream_channels, channel_map);
 }
 
-static uint32_t GetChannelMap(AEAudioFormat &format, bool passthrough)
+static uint32_t GetChannelMap(const CAEChannelInfo &channelLayout, bool passthrough)
 {
-  unsigned int channels = format.m_channelLayout.Count();
+  unsigned int channels = channelLayout.Count();
   uint32_t channel_map = 0;
   if (passthrough)
     return 0;
@@ -135,12 +135,12 @@ static uint32_t GetChannelMap(AEAudioFormat &format, bool passthrough)
   // According to CEA-861-D only RL and RR are known. In case of a format having SL and SR channels
   // but no BR BL channels, we use the wide map in order to open only the num of channels really
   // needed.
-  if (format.m_channelLayout.HasChannel(AE_CH_BL) && !format.m_channelLayout.HasChannel(AE_CH_SL))
+  if (channelLayout.HasChannel(AE_CH_BL) && !channelLayout.HasChannel(AE_CH_SL))
     map = map_back;
 
   for (unsigned int i = 0; i < channels; ++i)
   {
-    AEChannel c = format.m_channelLayout[i];
+    AEChannel c = channelLayout[i];
     unsigned int chan = 0;
     if ((unsigned int)c < sizeof map_normal / sizeof *map_normal)
       chan = map[(unsigned int)c];
@@ -171,9 +171,9 @@ static uint32_t GetChannelMap(AEAudioFormat &format, bool passthrough)
     0xff, // 7
     0x13, // 7.1
   };
-  uint8_t cea = format.m_channelLayout.HasChannel(AE_CH_LFE) ? cea_map_lfe[channels] : cea_map[channels];
+  uint8_t cea = channelLayout.HasChannel(AE_CH_LFE) ? cea_map_lfe[channels] : cea_map[channels];
   if (cea == 0xff)
-    CLog::Log(LOGERROR, "%s::%s - Unexpected CEA mapping %d,%d", CLASSNAME, __func__, format.m_channelLayout.HasChannel(AE_CH_LFE), channels);
+    CLog::Log(LOGERROR, "%s::%s - Unexpected CEA mapping %d,%d", CLASSNAME, __func__, channelLayout.HasChannel(AE_CH_LFE), channels);
 
   channel_map |= cea << 24;
 
@@ -215,7 +215,7 @@ bool CAESinkPi::Initialize(AEAudioFormat &format, std::string &device)
   format.m_frames        = format.m_sampleRate * AUDIO_PLAYBUFFER / NUM_OMX_BUFFERS;
   format.m_frameSamples  = format.m_frames * channels;
 
-  SetAudioProps(m_passthrough, GetChannelMap(format, m_passthrough));
+  SetAudioProps(m_passthrough, GetChannelMap(format.m_channelLayout, m_passthrough));
 
   m_format = format;
   m_sinkbuffer_sec_per_byte = 1.0 / (double)(m_format.m_frameSize * m_format.m_sampleRate);

From d424942bfc56c3d49521f7c6ac5410385d1147c8 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 27 Oct 2014 15:23:51 +0000
Subject: [PATCH 17/89] [rbp] Default extract thumbnails to false

It can take 80 seconds for a single file on a Pi. It can cause crashes with out-of-memory errors.
It genereates a lot of support issues. Best to default to disabled and let users enable it if they must
---
 system/settings/rbp.xml | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/system/settings/rbp.xml b/system/settings/rbp.xml
index cb83297..8496abf 100644
--- a/system/settings/rbp.xml
+++ b/system/settings/rbp.xml
@@ -38,6 +38,16 @@
         </setting>
       </group>
     </category>
+    <category id="myvideos">
+      <group id="1">
+        <setting id="myvideos.extractflags">
+          <default>false</default>
+        </setting>
+        <setting id="myvideos.extractthumb">
+          <default>false</default>
+        </setting>
+      </group>
+    </category>
   </section>
 
   <section id="system">


From bdb2bce42352230100067f6ab19ac077ab391ca9 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 15 Nov 2014 12:03:34 +0000
Subject: [PATCH 21/89] [dvdplayer] Add lock for player creation

---
 xbmc/cores/dvdplayer/DVDPlayer.cpp | 3 +++
 xbmc/cores/dvdplayer/DVDPlayer.h   | 1 +
 2 files changed, 4 insertions(+)

diff --git a/xbmc/cores/dvdplayer/DVDPlayer.cpp b/xbmc/cores/dvdplayer/DVDPlayer.cpp
index 63f4a30..3c313cd 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayer.cpp
@@ -529,6 +529,7 @@ int CSelectionStreams::CountSource(StreamType type, StreamSource source) const
 
 void CDVDPlayer::CreatePlayers()
 {
+  CSingleLock lock(m_players_lock);
 #ifdef HAS_OMXPLAYER
   if (m_omxplayer_mode && OMXPlayerUnsuitable(m_HasVideo, m_HasAudio, m_pDemuxer, m_pInputStream, m_SelectionStreams))
   {
@@ -558,6 +559,7 @@ void CDVDPlayer::CreatePlayers()
 
 void CDVDPlayer::DestroyPlayers()
 {
+  CSingleLock lock(m_players_lock);
   if (!m_players_created)
     return;
   delete m_dvdPlayerVideo;
@@ -4190,6 +4192,7 @@ double CDVDPlayer::GetQueueTime()
 
 void CDVDPlayer::GetVideoStreamInfo(SPlayerVideoStreamInfo &info)
 {
+  CSingleLock lock(m_players_lock);
   info.bitrate = m_dvdPlayerVideo->GetVideoBitrate();
 
   std::string retVal;
diff --git a/xbmc/cores/dvdplayer/DVDPlayer.h b/xbmc/cores/dvdplayer/DVDPlayer.h
index 468239c..3b8cefb 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.h
+++ b/xbmc/cores/dvdplayer/DVDPlayer.h
@@ -558,4 +558,5 @@ class CDVDPlayer : public IPlayer, public CThread, public IDVDPlayer
   // omxplayer variables
   struct SOmxPlayerState m_OmxPlayerState;
   bool m_omxplayer_mode;            // using omxplayer acceleration
+  CCriticalSection m_players_lock;
 };

From a40900ba3edf82d8ba63eb3e5e2ffd9a9810e42e Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 24 Nov 2014 22:07:25 +0000
Subject: [PATCH 22/89] [dvdplayervideo] Prod decoder when in stills mode

An asynchronous hardware decoder doesn't only produce output pictures when new packets arrive.
In dvd stills mode give it a chance to return pictures that weren't ready when frame was decoded.
---
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp | 46 ++++++++++++++++++++-------------
 1 file changed, 28 insertions(+), 18 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 69dc501..5832c58 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -323,7 +323,8 @@ void CDVDPlayerVideo::Process()
 
   while (!m_bStop)
   {
-    int iQueueTimeOut = (int)(m_stalled ? frametime / 4 : frametime * 10) / 1000;
+    bool bPictureWaiting = m_hints.stills && (m_pVideoCodec->Decode(NULL, 0, DVD_NOPTS_VALUE, DVD_NOPTS_VALUE) & VC_PICTURE);
+    int iQueueTimeOut = (int)(bPictureWaiting ? 0 : (m_hints.stills || m_stalled) ? frametime / 4 : frametime * 10) / 1000;
     int iPriority = (m_speed == DVD_PLAYSPEED_PAUSE && m_started) ? 1 : 0;
 
     CDVDMsg* pMsg;
@@ -340,27 +341,36 @@ void CDVDPlayerVideo::Process()
       if( iPriority )
         continue;
 
-      //Okey, start rendering at stream fps now instead, we are likely in a stillframe
-      if( !m_stalled )
+      // check for picture waiting
+      if (bPictureWaiting)
       {
-        if(m_started)
-          CLog::Log(LOGINFO, "CDVDPlayerVideo - Stillframe detected, switching to forced %f fps", m_fFrameRate);
-        m_stalled = true;
-        pts+= frametime*4;
+        // create a dummy demuxer packet to prod the decode logic
+        pMsg = new CDVDMsgDemuxerPacket(CDVDDemuxUtils::AllocateDemuxPacket(0), false);
       }
-
-      //Waiting timed out, output last picture
-      if( picture.iFlags & DVP_FLAG_ALLOCATED )
+      else
       {
-        //Remove interlaced flag before outputting
-        //no need to output this as if it was interlaced
-        picture.iFlags &= ~DVP_FLAG_INTERLACED;
-        picture.iFlags |= DVP_FLAG_NOSKIP;
-        OutputPicture(&picture, pts);
-        pts+= frametime;
-      }
+        //Okey, start rendering at stream fps now instead, we are likely in a stillframe
+        if( !m_stalled )
+        {
+          if(m_started)
+            CLog::Log(LOGINFO, "CDVDPlayerVideo - Stillframe detected, switching to forced %f fps", m_fFrameRate);
+          m_stalled = true;
+          pts+= frametime*4;
+        }
 
-      continue;
+        //Waiting timed out, output last picture
+        if( picture.iFlags & DVP_FLAG_ALLOCATED )
+        {
+          //Remove interlaced flag before outputting
+          //no need to output this as if it was interlaced
+          picture.iFlags &= ~DVP_FLAG_INTERLACED;
+          picture.iFlags |= DVP_FLAG_NOSKIP;
+          OutputPicture(&picture, pts);
+          pts+= frametime;
+        }
+
+        continue;
+      }
     }
 
     if (pMsg->IsType(CDVDMsg::GENERAL_SYNCHRONIZE))

From 8674cc04f73067ac9b26562f5ed1bbc87b61571c Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 27 Nov 2014 16:31:56 +0000
Subject: [PATCH 23/89] [languageinvoker] Reduce priority of python threads

---
 xbmc/interfaces/generic/LanguageInvokerThread.cpp | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/xbmc/interfaces/generic/LanguageInvokerThread.cpp b/xbmc/interfaces/generic/LanguageInvokerThread.cpp
index fcdd063..16f0c89 100644
--- a/xbmc/interfaces/generic/LanguageInvokerThread.cpp
+++ b/xbmc/interfaces/generic/LanguageInvokerThread.cpp
@@ -50,6 +50,11 @@ bool CLanguageInvokerThread::execute(const std::string &script, const std::vecto
   m_args = arguments;
 
   Create();
+  #ifdef TARGET_RASPBERRY_PI
+  /* low prio */
+  SetPriority(GetPriority()-1);
+  #endif
+
   return true;
 }
 

From c0d94a5d0a90ac3e0c8304f551d59ae150a04ccb Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 14 Dec 2013 16:55:05 +0000
Subject: [PATCH 24/89] logging: Add microsecond timer to log messages

---
 xbmc/utils/log.cpp | 17 +++++++++++++++--
 1 file changed, 15 insertions(+), 2 deletions(-)

diff --git a/xbmc/utils/log.cpp b/xbmc/utils/log.cpp
index 3443f12..31c4a99 100644
--- a/xbmc/utils/log.cpp
+++ b/xbmc/utils/log.cpp
@@ -24,6 +24,7 @@
 #include "threads/Thread.h"
 #include "utils/StringUtils.h"
 #include "CompileInfo.h"
+#include "utils/TimeUtils.cpp"
 
 static const char* const levelNames[] =
 {"DEBUG", "INFO", "NOTICE", "WARNING", "ERROR", "SEVERE", "FATAL", "NONE"};
@@ -198,19 +199,31 @@ void CLog::PrintDebugString(const std::string& line)
 
 bool CLog::WriteLogString(int logLevel, const std::string& logString)
 {
+#if defined(TARGET_LINUX)
+  static const char* prefixFormat = "%02.2d:%02.2d:%02.2d %10.6f T:%" PRIu64" %7s: ";
+#else
   static const char* prefixFormat = "%02.2d:%02.2d:%02.2d T:%" PRIu64" %7s: ";
-
+#endif
   std::string strData(logString);
   /* fixup newline alignment, number of spaces should equal prefix length */
   StringUtils::Replace(strData, "\n", "\n                                            ");
 
   int hour, minute, second;
   s_globals.m_platform.GetCurrentLocalTime(hour, minute, second);
-  
+
+#if defined(TARGET_LINUX)
+  struct timespec now;
+  clock_gettime(CLOCK_MONOTONIC, &now);
+  float Now = now.tv_sec + now.tv_nsec * 1e-9;
+#endif
+
   strData = StringUtils::Format(prefixFormat,
                                   hour,
                                   minute,
                                   second,
+#if defined(TARGET_LINUX)
+                                  Now,
+#endif
                                   (uint64_t)CThread::GetCurrentThreadId(),
                                   levelNames[logLevel]) + strData;
 

From 9148d35d4664d75cfa38af607202cb79e535d425 Mon Sep 17 00:00:00 2001
From: macrule <macrule2001@yahoo.de>
Date: Thu, 11 Apr 2013 18:24:42 +0200
Subject: [PATCH 25/89] Added some vc_tv_* functions that were missing in
 DllBCM.

---
 xbmc/linux/DllBCM.h | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/xbmc/linux/DllBCM.h b/xbmc/linux/DllBCM.h
index b92fdb8..9c7e293 100644
--- a/xbmc/linux/DllBCM.h
+++ b/xbmc/linux/DllBCM.h
@@ -48,6 +48,9 @@ class DllBcmHostInterface
   virtual void bcm_host_init() = 0;
   virtual void bcm_host_deinit() = 0;
   virtual int32_t graphics_get_display_size( const uint16_t display_number, uint32_t *width, uint32_t *height) = 0;
+  virtual int vc_tv_power_off() = 0;
+  virtual int vc_tv_sdtv_power_on(SDTV_MODE_T mode, SDTV_OPTIONS_T *options) = 0;
+  virtual int vc_tv_hdmi_power_on_preferred() = 0;
   virtual int vc_tv_hdmi_power_on_best(uint32_t width, uint32_t height, uint32_t frame_rate,
                                        HDMI_INTERLACED_T scan_mode, EDID_MODE_MATCH_FLAG_T match_flags) = 0;
   virtual int vc_tv_hdmi_power_on_best_3d(uint32_t width, uint32_t height, uint32_t frame_rate,
@@ -92,6 +95,12 @@ class DllBcmHost : public DllDynamic, DllBcmHostInterface
     { return ::bcm_host_deinit(); };
   virtual int32_t graphics_get_display_size( const uint16_t display_number, uint32_t *width, uint32_t *height)
     { return ::graphics_get_display_size(display_number, width, height); };
+  virtual int vc_tv_power_off()
+    { return ::vc_tv_power_off(); }
+  virtual int vc_tv_sdtv_power_on(SDTV_MODE_T mode, SDTV_OPTIONS_T *options)
+    { return ::vc_tv_sdtv_power_on(mode, options); }
+  virtual int vc_tv_hdmi_power_on_preferred()
+    { return ::vc_tv_hdmi_power_on_preferred(); }
   virtual int vc_tv_hdmi_power_on_best(uint32_t width, uint32_t height, uint32_t frame_rate,
                                        HDMI_INTERLACED_T scan_mode, EDID_MODE_MATCH_FLAG_T match_flags)
     { return ::vc_tv_hdmi_power_on_best(width, height, frame_rate, scan_mode, match_flags); };

From 1c09b17c3d8d8631708d0feaa2b03ac38451d23b Mon Sep 17 00:00:00 2001
From: macrule <macrule2001@yahoo.de>
Date: Thu, 11 Apr 2013 18:29:03 +0200
Subject: [PATCH 26/89] Added private utility function to map a float display
 aspect, to the respective SDTV_ASPECT_* enum value.

---
 xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp | 19 +++++++++++++++++++
 1 file changed, 19 insertions(+)

diff --git a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
index 68fc647..6b1f3b9 100644
--- a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
@@ -412,6 +412,25 @@ static void SetResolutionString(RESOLUTION_INFO &res)
     res.dwFlags & D3DPRESENTFLAG_MODE3DTB   ? " 3DTB" : "",
     res.dwFlags & D3DPRESENTFLAG_MODE3DSBS  ? " 3DSBS" : "");
 }
+
+static SDTV_ASPECT_T get_sdtv_aspect_from_display_aspect(float display_aspect)
+{
+  SDTV_ASPECT_T aspect;
+  const float delta = 1e-3;
+  if(fabs(get_display_aspect_ratio(SDTV_ASPECT_16_9) - display_aspect) < delta)
+  {
+    aspect = SDTV_ASPECT_16_9;
+  }
+  else if(fabs(get_display_aspect_ratio(SDTV_ASPECT_14_9) - display_aspect) < delta)
+  {
+    aspect = SDTV_ASPECT_14_9;
+  }
+  else
+  {
+    aspect = SDTV_ASPECT_4_3;
+  }
+  return aspect;
+}
 #endif
 
 bool CEGLNativeTypeRaspberryPI::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)

From d339ba599375b756dbbe5e878519b3b02f19d8bd Mon Sep 17 00:00:00 2001
From: macrule <macrule2001@yahoo.de>
Date: Thu, 11 Apr 2013 19:50:58 +0200
Subject: [PATCH 27/89] Changed SDTV resolutions to be treated similarly to
 HDMI resolutions in SetNativeResolution. This means that the SDTV interface
 is powered up and set to the right mode.

---
 xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp | 36 ++++++++++++++++++++-----
 xbmc/windowing/egl/EGLNativeTypeRaspberryPI.h   |  1 -
 2 files changed, 29 insertions(+), 8 deletions(-)

diff --git a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
index 6b1f3b9..4826d37 100644
--- a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
@@ -222,7 +222,7 @@ bool CEGLNativeTypeRaspberryPI::SetNativeResolution(const RESOLUTION_INFO &res)
 
   DestroyDispmaxWindow();
 
-  if(!m_fixedMode && GETFLAGS_GROUP(res.dwFlags) && GETFLAGS_MODE(res.dwFlags))
+  if(GETFLAGS_GROUP(res.dwFlags) && GETFLAGS_MODE(res.dwFlags))
   {
     sem_init(&m_tv_synced, 0, 0);
     m_DllBcmHost->vc_tv_register_callback(CallbackTvServiceCallback, this);
@@ -276,6 +276,33 @@ bool CEGLNativeTypeRaspberryPI::SetNativeResolution(const RESOLUTION_INFO &res)
 
     m_desktopRes = res;
   }
+  else if(!GETFLAGS_GROUP(res.dwFlags) && GETFLAGS_MODE(res.dwFlags))
+  {
+    sem_init(&m_tv_synced, 0, 0);
+    m_DllBcmHost->vc_tv_register_callback(CallbackTvServiceCallback, this);
+
+    SDTV_OPTIONS_T options;
+    options.aspect = get_sdtv_aspect_from_display_aspect((float)res.iScreenWidth / (float)res.iScreenHeight);
+
+    int success = m_DllBcmHost->vc_tv_sdtv_power_on((SDTV_MODE_T)GETFLAGS_MODE(res.dwFlags), &options);
+
+    if (success == 0)
+    {
+      CLog::Log(LOGDEBUG, "EGL set SDTV mode (%d,%d)=%d\n",
+                          GETFLAGS_GROUP(res.dwFlags), GETFLAGS_MODE(res.dwFlags), success);
+
+      sem_wait(&m_tv_synced);
+    }
+    else
+    {
+      CLog::Log(LOGERROR, "EGL failed to set SDTV mode (%d,%d)=%d\n",
+                          GETFLAGS_GROUP(res.dwFlags), GETFLAGS_MODE(res.dwFlags), success);
+    }
+    m_DllBcmHost->vc_tv_unregister_callback(CallbackTvServiceCallback);
+    sem_destroy(&m_tv_synced);
+
+    m_desktopRes = res;
+  }
 
   m_dispman_display = g_RBP.OpenDisplay(0);
 
@@ -441,8 +468,6 @@ bool CEGLNativeTypeRaspberryPI::ProbeResolutions(std::vector<RESOLUTION_INFO> &r
   if(!m_DllBcmHost)
     return false;
 
-  m_fixedMode               = false;
-
   /* read initial desktop resolution before probe resolutions.
    * probing will replace the desktop resolution when it finds the same one.
    * we raplace it because probing will generate more detailed 
@@ -491,7 +516,7 @@ bool CEGLNativeTypeRaspberryPI::ProbeResolutions(std::vector<RESOLUTION_INFO> &r
       m_desktopRes.iHeight      = tv_state.display.sdtv.height;
       m_desktopRes.iScreenWidth = tv_state.display.sdtv.width;
       m_desktopRes.iScreenHeight= tv_state.display.sdtv.height;
-      m_desktopRes.dwFlags      = D3DPRESENTFLAG_INTERLACED;
+      m_desktopRes.dwFlags      = MAKEFLAGS(HDMI_RES_GROUP_INVALID, tv_state.display.sdtv.mode, 1);
       m_desktopRes.fRefreshRate = (float)tv_state.display.sdtv.frame_rate;
       m_desktopRes.fPixelRatio  = tv_state.display.hdmi.display_options.aspect == 0 ? 1.0f : get_display_aspect_ratio((SDTV_ASPECT_T)tv_state.display.sdtv.display_options.aspect) / ((float)m_desktopRes.iScreenWidth / (float)m_desktopRes.iScreenHeight);
     }
@@ -514,9 +539,6 @@ bool CEGLNativeTypeRaspberryPI::ProbeResolutions(std::vector<RESOLUTION_INFO> &r
     CLog::Log(LOGDEBUG, "EGL probe resolution %s:%x\n", m_desktopRes.strMode.c_str(), m_desktopRes.dwFlags);
   }
 
-  if(resolutions.size() < 2)
-    m_fixedMode = true;
-
   DLOG("CEGLNativeTypeRaspberryPI::ProbeResolutions\n");
   return true;
 #else
diff --git a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.h b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.h
index 59401f5..a0acb1a 100644
--- a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.h
+++ b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.h
@@ -59,7 +59,6 @@ class CEGLNativeTypeRaspberryPI : public CEGLNativeType
   DISPMANX_ELEMENT_HANDLE_T     m_dispman_element;
   TV_GET_STATE_RESP_T           m_tv_state;
   sem_t                         m_tv_synced;
-  bool                          m_fixedMode;
   RESOLUTION_INFO               m_desktopRes;
   int                           m_width;
   int                           m_height;

From 8ebee675392f628fd18e803d549f69fcac428f01 Mon Sep 17 00:00:00 2001
From: macrule <macrule2001@yahoo.de>
Date: Thu, 11 Apr 2013 19:54:59 +0200
Subject: [PATCH 28/89] Added methods SuspendVideoOutput() and
 ResumeVideoOutput() to CRBP class, which can be used to power down the
 Raspberry PI's video interface, and restore it at a later point.

---
 xbmc/linux/RBP.cpp                              | 13 +++++++++++++
 xbmc/linux/RBP.h                                |  3 +++
 xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp |  3 +++
 3 files changed, 19 insertions(+)

diff --git a/xbmc/linux/RBP.cpp b/xbmc/linux/RBP.cpp
index a4b0c2a..160eb96 100644
--- a/xbmc/linux/RBP.cpp
+++ b/xbmc/linux/RBP.cpp
@@ -233,5 +233,18 @@ double CRBP::AdjustHDMIClock(double adjust)
   return new_adjust;
 }
 
+void CRBP::SuspendVideoOutput()
+{
+  CLog::Log(LOGDEBUG, "Raspberry PI suspending video output\n");
+  char response[80];
+  m_DllBcmHost->vc_gencmd(response, sizeof response, "display_power 0");
+}
+
+void CRBP::ResumeVideoOutput()
+{
+  char response[80];
+  m_DllBcmHost->vc_gencmd(response, sizeof response, "display_power 1");
+  CLog::Log(LOGDEBUG, "Raspberry PI resuming video output\n");
+}
 
 #endif
diff --git a/xbmc/linux/RBP.h b/xbmc/linux/RBP.h
index 65492fa..38fb252 100644
--- a/xbmc/linux/RBP.h
+++ b/xbmc/linux/RBP.h
@@ -65,6 +65,9 @@ class CRBP
   void WaitVsync();
   double AdjustHDMIClock(double adjust);
 
+  void SuspendVideoOutput();
+  void ResumeVideoOutput();
+
 private:
   DllBcmHost *m_DllBcmHost;
   bool       m_initialized;
diff --git a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
index 4826d37..7d9b0d3 100644
--- a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
@@ -60,7 +60,10 @@
 # define DLOG(fmt, args...)
 #endif
 
+#if defined(TARGET_RASPBERRY_PI)
 static void SetResolutionString(RESOLUTION_INFO &res);
+static SDTV_ASPECT_T get_sdtv_aspect_from_display_aspect(float display_aspect);
+#endif
 
 CEGLNativeTypeRaspberryPI::CEGLNativeTypeRaspberryPI()
 {

From 0739fee7877f4856d12321465b2b9744de086b46 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sun, 11 Aug 2013 15:03:36 +0100
Subject: [PATCH 29/89] PowerManager (and its IPowerSyscall instance) now gets
 called from CApplication::OnKey() and can process and suppress key presses.
 This is a requirement to implement a virtual sleep state.

---
 xbmc/Application.cpp                  | 1 -
 xbmc/input/InputManager.cpp           | 8 ++++++++
 xbmc/powermanagement/IPowerSyscall.h  | 7 +++++++
 xbmc/powermanagement/PowerManager.cpp | 6 ++++++
 xbmc/powermanagement/PowerManager.h   | 3 +++
 5 files changed, 24 insertions(+), 1 deletion(-)

diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index 135b466..df6e8ca 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -2043,7 +2043,6 @@ void CApplication::SetStandAlone(bool value)
   g_advancedSettings.m_handleMounting = m_bStandalone = value;
 }
 
-
 // OnAppCommand is called in response to a XBMC_APPCOMMAND event.
 // This needs to return true if it processed the appcommand or false if it didn't
 bool CApplication::OnAppCommand(const CAction &action)
diff --git a/xbmc/input/InputManager.cpp b/xbmc/input/InputManager.cpp
index c6f62d8db0..f90fa89 100644
--- a/xbmc/input/InputManager.cpp
+++ b/xbmc/input/InputManager.cpp
@@ -30,6 +30,7 @@
 #include "guilib/GUIWindow.h"
 #include "guilib/GUIWindowManager.h"
 #include "guilib/GUIMessage.h"
+#include "powermanagement/PowerManager.h"
 
 #ifdef HAS_EVENT_SERVER
 #include "network/EventServer.h"
@@ -524,6 +525,13 @@ bool CInputManager::OnKey(const CKey& key)
   // special handling if the screensaver is active
   CAction action = CButtonTranslator::GetInstance().GetAction(iWin, key);
 
+  // give the PowerManager a chance to process a keypress, and
+  // suppress further processing. we need this for virtual sleep.
+  if (g_powerManager.ProcessAction(action))
+  {
+    return true;
+  }
+
   // a key has been pressed.
   // reset Idle Timer
   g_application.ResetSystemIdleTimer();
diff --git a/xbmc/powermanagement/IPowerSyscall.h b/xbmc/powermanagement/IPowerSyscall.h
index 7f9e7ed..711abea 100644
--- a/xbmc/powermanagement/IPowerSyscall.h
+++ b/xbmc/powermanagement/IPowerSyscall.h
@@ -20,6 +20,9 @@
  *
  */
 
+// forward declaration
+class CAction;
+
 class IPowerEventsCallback
 {
 public:
@@ -60,6 +63,10 @@ class IPowerSyscall
    \param callback the callback to signal to
    */
   virtual bool PumpPowerEvents(IPowerEventsCallback *callback) = 0;
+
+  // this is an optional part of the interface, so we provide a no-op implementation here.
+  // return true to suppress further processing of the CAction.
+  virtual bool ProcessAction(const CAction& action) { return false; }
 };
 
 class CPowerSyscallWithoutEvents : public IPowerSyscall
diff --git a/xbmc/powermanagement/PowerManager.cpp b/xbmc/powermanagement/PowerManager.cpp
index 5900f98..6e819d9 100644
--- a/xbmc/powermanagement/PowerManager.cpp
+++ b/xbmc/powermanagement/PowerManager.cpp
@@ -225,6 +225,12 @@ void CPowerManager::ProcessEvents()
   nesting--;
 }
 
+bool CPowerManager::ProcessAction(const CAction& action)
+{
+  return m_instance->ProcessAction(action);
+}
+
+
 void CPowerManager::OnSleep()
 {
   CAnnouncementManager::Get().Announce(System, "xbmc", "OnSleep");
diff --git a/xbmc/powermanagement/PowerManager.h b/xbmc/powermanagement/PowerManager.h
index 0b1f10a..e42b143 100644
--- a/xbmc/powermanagement/PowerManager.h
+++ b/xbmc/powermanagement/PowerManager.h
@@ -58,6 +58,8 @@ class CNullPowerSyscall : public IPowerSyscall
 
 
   virtual bool PumpPowerEvents(IPowerEventsCallback *callback) { return false; }
+
+  virtual bool ProcessAction(const CAction& action) { return false; }
 };
 
 // This class will wrap and handle PowerSyscalls.
@@ -87,6 +89,7 @@ class CPowerManager : public IPowerEventsCallback
 
   static void SettingOptionsShutdownStatesFiller(const CSetting *setting, std::vector< std::pair<std::string, int> > &list, int &current, void *data);
 
+  bool ProcessAction(const CAction& action);
 private:
   void OnSleep();
   void OnWake();

From 94a8bac3feaeed3edd78e9e49f209b92ef5c87f9 Mon Sep 17 00:00:00 2001
From: macrule <macrule2001@yahoo.de>
Date: Wed, 17 Apr 2013 13:23:01 +0200
Subject: [PATCH 30/89] Added CPowerSyscallVirtualSleep class, which acts as a
 base class for devices that have no native standby mode, and need to fake it
 in some way.

---
 xbmc/powermanagement/Makefile                     |  1 +
 xbmc/powermanagement/PowerSyscallVirtualSleep.cpp | 84 +++++++++++++++++++++++
 xbmc/powermanagement/PowerSyscallVirtualSleep.h   | 56 +++++++++++++++
 3 files changed, 141 insertions(+)
 create mode 100644 xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
 create mode 100644 xbmc/powermanagement/PowerSyscallVirtualSleep.h

diff --git a/xbmc/powermanagement/Makefile b/xbmc/powermanagement/Makefile
index 0b4c029..16056af 100644
--- a/xbmc/powermanagement/Makefile
+++ b/xbmc/powermanagement/Makefile
@@ -1,5 +1,6 @@
 SRCS=DPMSSupport.cpp \
      PowerManager.cpp \
+     PowerSyscallVirtualSleep.cpp \
 
 LIB=powermanagement.a
 
diff --git a/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp b/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
new file mode 100644
index 0000000..9e6c8e4
--- /dev/null
+++ b/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
@@ -0,0 +1,84 @@
+/*
+ *      Copyright (C) 2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "PowerSyscallVirtualSleep.h"
+#include "input/Key.h"
+#include "utils/log.h"
+#include "utils/StringUtils.h"
+
+bool CPowerSyscallVirtualSleep::Suspend()
+{
+  if (m_virtualSleepState == VIRTUAL_SLEEP_STATE_AWAKE)
+  {
+    if (VirtualSleep())
+    {
+      m_virtualSleepState = VIRTUAL_SLEEP_STATE_WILL_SLEEP;
+      return true;
+    }
+  }
+
+  return false;
+}
+
+bool CPowerSyscallVirtualSleep::PumpPowerEvents(IPowerEventsCallback *callback)
+{
+  if (m_virtualSleepState == VIRTUAL_SLEEP_STATE_WILL_WAKE)
+  {
+    callback->OnWake();
+    m_virtualSleepState = VIRTUAL_SLEEP_STATE_AWAKE;
+    return true;
+  }
+  else if (m_virtualSleepState == VIRTUAL_SLEEP_STATE_WILL_SLEEP)
+  {
+    callback->OnSleep();
+    m_virtualSleepState = VIRTUAL_SLEEP_STATE_ASLEEP;
+    return true;
+  }
+
+  return false;
+}
+
+bool CPowerSyscallVirtualSleep::ProcessAction(const CAction& action)
+{
+  if (m_virtualSleepState != VIRTUAL_SLEEP_STATE_ASLEEP)
+    return false;
+
+  // device is in virtual sleep, only one of the power keys will
+  // wake it up again.
+  if (action.GetID() == ACTION_BUILT_IN_FUNCTION)
+  {
+    std::string name = action.GetName();
+    StringUtils::ToLower(name);
+    if(name.Equals("xbmc.suspend()") ||
+       name.Equals("shutdown") ||
+       name.Equals("suspend")  ||
+       name.Equals("hibernate"))
+    {
+      if(VirtualWake())
+      {
+        m_virtualSleepState = VIRTUAL_SLEEP_STATE_WILL_WAKE;
+        return false;
+      }
+    }
+  }
+
+  // wasn't a power key, suppress this and stay asleep
+  return true;
+}
diff --git a/xbmc/powermanagement/PowerSyscallVirtualSleep.h b/xbmc/powermanagement/PowerSyscallVirtualSleep.h
new file mode 100644
index 0000000..ef6e682
--- /dev/null
+++ b/xbmc/powermanagement/PowerSyscallVirtualSleep.h
@@ -0,0 +1,56 @@
+/*
+ *      Copyright (C) 2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef _POWER_SYSCALL_VIRTUAL_SLEEP_H_
+#define _POWER_SYSCALL_VIRTUAL_SLEEP_H_
+#include "IPowerSyscall.h"
+
+// Systems that have no native standby mode, can base their
+// IPowerSyscall implementation on this class, and need only
+// implement VirtualSleep()/VirtualWake().
+class CPowerSyscallVirtualSleep : public IPowerSyscall
+{
+public:
+  CPowerSyscallVirtualSleep() : m_virtualSleepState(VIRTUAL_SLEEP_STATE_AWAKE) {}
+  virtual ~CPowerSyscallVirtualSleep() {}
+
+  virtual bool CanSuspend() { return true; }
+  virtual bool Suspend();
+
+  virtual bool PumpPowerEvents(IPowerEventsCallback *callback);
+
+  virtual bool ProcessAction(const CAction& action);
+
+  virtual bool VirtualSleep() = 0;
+  virtual bool VirtualWake()  = 0;
+
+protected:
+  // keep track of virtual sleep state for devices that support it
+  typedef enum {
+    VIRTUAL_SLEEP_STATE_AWAKE = 0,
+    VIRTUAL_SLEEP_STATE_ASLEEP,
+    VIRTUAL_SLEEP_STATE_WILL_WAKE,
+    VIRTUAL_SLEEP_STATE_WILL_SLEEP,
+  } VirtualSleepState;
+
+  VirtualSleepState m_virtualSleepState;
+};
+
+#endif // _POWER_SYSCALL_VIRTUAL_SLEEP_H_

From 4e72dbc0c34cd319b3168551ee14ebc6ea78739c Mon Sep 17 00:00:00 2001
From: macrule <macrule2001@yahoo.de>
Date: Wed, 17 Apr 2013 13:24:22 +0200
Subject: [PATCH 31/89] Added power management support for the Raspberry Pi.
 Since it doesn't support true standby, we fake it by turning video on or off,
 and ignoring remote inputs during the standby phase.

---
 xbmc/powermanagement/PowerManager.cpp              |  4 ++
 xbmc/powermanagement/linux/Makefile                |  1 +
 .../linux/RaspberryPIPowerSyscall.cpp              | 38 +++++++++++++++++
 .../linux/RaspberryPIPowerSyscall.h                | 49 ++++++++++++++++++++++
 4 files changed, 92 insertions(+)
 create mode 100644 xbmc/powermanagement/linux/RaspberryPIPowerSyscall.cpp
 create mode 100644 xbmc/powermanagement/linux/RaspberryPIPowerSyscall.h

diff --git a/xbmc/powermanagement/PowerManager.cpp b/xbmc/powermanagement/PowerManager.cpp
index 6e819d9..2d8c750 100644
--- a/xbmc/powermanagement/PowerManager.cpp
+++ b/xbmc/powermanagement/PowerManager.cpp
@@ -38,6 +38,8 @@
 
 #if defined(TARGET_DARWIN)
 #include "osx/CocoaPowerSyscall.h"
+#elif defined(TARGET_RASPBERRY_PI)
+#include "linux/RaspberryPIPowerSyscall.h"
 #elif defined(TARGET_ANDROID)
 #include "android/AndroidPowerSyscall.h"
 #elif defined(TARGET_POSIX)
@@ -71,6 +73,8 @@ void CPowerManager::Initialize()
 {
 #if defined(TARGET_DARWIN)
   m_instance = new CCocoaPowerSyscall();
+#elif defined(TARGET_RASPBERRY_PI)
+  m_instance = new CRaspberryPIPowerSyscall();
 #elif defined(TARGET_ANDROID)
   m_instance = new CAndroidPowerSyscall();
 #elif defined(TARGET_POSIX)
diff --git a/xbmc/powermanagement/linux/Makefile b/xbmc/powermanagement/linux/Makefile
index e9d95fb..b130812 100644
--- a/xbmc/powermanagement/linux/Makefile
+++ b/xbmc/powermanagement/linux/Makefile
@@ -1,5 +1,6 @@
 SRCS=ConsoleDeviceKitPowerSyscall.cpp \
      ConsoleUPowerSyscall.cpp \
+     RaspberryPIPowerSyscall.cpp \
      UPowerSyscall.cpp \
      LogindUPowerSyscall.cpp
 
diff --git a/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.cpp b/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.cpp
new file mode 100644
index 0000000..10deeb8
--- /dev/null
+++ b/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.cpp
@@ -0,0 +1,38 @@
+/*
+ *      Copyright (C) 2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#if defined(TARGET_RASPBERRY_PI)
+
+#include "RaspberryPIPowerSyscall.h"
+#include "RBP.h"
+
+bool CRaspberryPIPowerSyscall::VirtualSleep()
+{
+  g_RBP.SuspendVideoOutput();
+  return true;
+}
+
+bool CRaspberryPIPowerSyscall::VirtualWake()
+{
+  g_RBP.ResumeVideoOutput();
+  return true;
+}
+
+#endif
diff --git a/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.h b/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.h
new file mode 100644
index 0000000..fd1d67c
--- /dev/null
+++ b/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.h
@@ -0,0 +1,49 @@
+#pragma once
+/*
+ *      Copyright (C) 2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef _RASPBERRY_PI_POWER_SYSCALL_H_
+#define _RASPBERRY_PI_POWER_SYSCALL_H_
+
+#if defined(TARGET_RASPBERRY_PI)
+#include "powermanagement/PowerSyscallVirtualSleep.h"
+
+class CRaspberryPIPowerSyscall : public CPowerSyscallVirtualSleep
+{
+public:
+  CRaspberryPIPowerSyscall() : CPowerSyscallVirtualSleep() {}
+  virtual ~CRaspberryPIPowerSyscall() {}
+
+  virtual bool Powerdown()    { return false; }
+  virtual bool Hibernate()    { return false; }
+  virtual bool Reboot()       { return false; }
+
+  virtual bool CanPowerdown() { return false; }
+  virtual bool CanHibernate() { return false; }
+  virtual bool CanReboot()    { return true; }
+
+  virtual int  BatteryLevel() { return 0; }
+
+  virtual bool VirtualSleep();
+  virtual bool VirtualWake();
+};
+#endif // TARGET_RASPBERRY_PI
+
+#endif // _RASPBERRY_PI_POWER_SYSCALL_H_

From 1e00d7bc6e5e193d12b3224d6801fb1dc8bf3b61 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 3 Mar 2014 16:16:29 +0000
Subject: [PATCH 32/89] [power] hack - don't kill lirc or cec

---
 xbmc/peripherals/devices/PeripheralCecAdapter.cpp | 37 +++++++++++++++++++++++
 xbmc/powermanagement/PowerManager.cpp             |  4 +--
 2 files changed, 39 insertions(+), 2 deletions(-)

diff --git a/xbmc/peripherals/devices/PeripheralCecAdapter.cpp b/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
index 3d0c07d..ae5583d 100644
--- a/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
+++ b/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
@@ -186,12 +186,49 @@ void CPeripheralCecAdapter::Announce(AnnouncementFlag flag, const char *sender,
   }
   else if (flag == System && !strcmp(sender, "xbmc") && !strcmp(message, "OnSleep"))
   {
+#if 1
+  bool bSendStandbyCommands(false);
+  {
+    CSingleLock lock(m_critSection);
+    bSendStandbyCommands = m_iExitCode != EXITCODE_REBOOT &&
+                           m_iExitCode != EXITCODE_RESTARTAPP &&
+                           !m_bDeviceRemoved &&
+                           (!m_bGoingToStandby || GetSettingBool("standby_tv_on_pc_standby")) &&
+                           GetSettingBool("enabled");
+
+    if (m_bGoingToStandby)
+      m_bActiveSourceBeforeStandby = m_cecAdapter->IsLibCECActiveSource();
+  }
+
+  if (bSendStandbyCommands)
+  {
+    if (m_cecAdapter->IsLibCECActiveSource())
+    {
+      if (!m_configuration.powerOffDevices.IsEmpty())
+      {
+        CLog::Log(LOGDEBUG, "%s - sending standby commands", __FUNCTION__);
+        m_standbySent = CDateTime::GetCurrentDateTime();
+        m_cecAdapter->StandbyDevices();
+      }
+      else if (m_configuration.bSendInactiveSource == 1)
+      {
+        CLog::Log(LOGDEBUG, "%s - sending inactive source commands", __FUNCTION__);
+        m_cecAdapter->SetInactiveView();
+      }
+    }
+    else
+    {
+      CLog::Log(LOGDEBUG, "%s - XBMC is not the active source, not sending any standby commands", __FUNCTION__);
+    }
+  }
+#else
     // this will also power off devices when we're the active source
     {
       CSingleLock lock(m_critSection);
       m_bGoingToStandby = true;
     }
     StopThread();
+#endif
   }
   else if (flag == System && !strcmp(sender, "xbmc") && !strcmp(message, "OnWake"))
   {
diff --git a/xbmc/powermanagement/PowerManager.cpp b/xbmc/powermanagement/PowerManager.cpp
index 2d8c750..901f449 100644
--- a/xbmc/powermanagement/PowerManager.cpp
+++ b/xbmc/powermanagement/PowerManager.cpp
@@ -241,7 +241,7 @@ void CPowerManager::OnSleep()
   CLog::Log(LOGNOTICE, "%s: Running sleep jobs", __FUNCTION__);
 
   // stop lirc
-#if defined(HAS_LIRC) || defined(HAS_IRSERVERSUITE)
+#if 0 //defined(HAS_LIRC) || defined(HAS_IRSERVERSUITE)
   CLog::Log(LOGNOTICE, "%s: Stopping lirc", __FUNCTION__);
   CBuiltins::Execute("LIRC.Stop");
 #endif
@@ -277,7 +277,7 @@ void CPowerManager::OnWake()
 #endif
 
   // restart lirc
-#if defined(HAS_LIRC) || defined(HAS_IRSERVERSUITE)
+#if 0 // defined(HAS_LIRC) || defined(HAS_IRSERVERSUITE)
   CLog::Log(LOGNOTICE, "%s: Restarting lirc", __FUNCTION__);
   CBuiltins::Execute("LIRC.Start");
 #endif

From ca8103aa0469ee82fe6da538e2d19cf33cabfc2c Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 3 Mar 2014 16:47:54 +0000
Subject: [PATCH 33/89] [power] hack - wake on any action

---
 xbmc/powermanagement/PowerSyscallVirtualSleep.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp b/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
index 9e6c8e4..78566ec 100644
--- a/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
+++ b/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
@@ -62,14 +62,14 @@ bool CPowerSyscallVirtualSleep::ProcessAction(const CAction& action)
 
   // device is in virtual sleep, only one of the power keys will
   // wake it up again.
-  if (action.GetID() == ACTION_BUILT_IN_FUNCTION)
+  //if (action.GetID() == ACTION_BUILT_IN_FUNCTION)
   {
     std::string name = action.GetName();
     StringUtils::ToLower(name);
-    if(name.Equals("xbmc.suspend()") ||
+    /*if(name.Equals("system.suspend") ||
        name.Equals("shutdown") ||
        name.Equals("suspend")  ||
-       name.Equals("hibernate"))
+       name.Equals("hibernate"))*/
     {
       if(VirtualWake())
       {

From 2db6f609de8998c2db449d0471699e02c6a6f46c Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 3 Mar 2014 17:30:07 +0000
Subject: [PATCH 34/89] [power] hack - Make suspend toggle suspend state

---
 xbmc/powermanagement/PowerSyscallVirtualSleep.cpp | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp b/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
index 78566ec..4cffcce 100644
--- a/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
+++ b/xbmc/powermanagement/PowerSyscallVirtualSleep.cpp
@@ -33,6 +33,11 @@ bool CPowerSyscallVirtualSleep::Suspend()
       return true;
     }
   }
+  else if (VirtualWake())
+  {
+    m_virtualSleepState = VIRTUAL_SLEEP_STATE_WILL_WAKE;
+    return false;
+  }
 
   return false;
 }

From c42ebe26c18468fb40569e4f5b0eb387ac835670 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 4 Mar 2014 19:33:44 +0000
Subject: [PATCH 35/89] [power] Add back in powerdown and reboot

---
 .../linux/RaspberryPIPowerSyscall.cpp              | 34 ++++++++++++++++++++++
 .../linux/RaspberryPIPowerSyscall.h                |  6 ++--
 2 files changed, 37 insertions(+), 3 deletions(-)

diff --git a/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.cpp b/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.cpp
index 10deeb8..220bca9 100644
--- a/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.cpp
+++ b/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.cpp
@@ -20,7 +20,11 @@
 
 #if defined(TARGET_RASPBERRY_PI)
 
+#include "system.h"
 #include "RaspberryPIPowerSyscall.h"
+#if defined(HAS_DBUS)
+#include "LogindUPowerSyscall.h"
+#endif
 #include "RBP.h"
 
 bool CRaspberryPIPowerSyscall::VirtualSleep()
@@ -35,4 +39,34 @@ bool CRaspberryPIPowerSyscall::VirtualWake()
   return true;
 }
 
+bool CRaspberryPIPowerSyscall::Powerdown()
+{
+  int s = false;
+#if defined(HAS_DBUS)
+  if (CLogindUPowerSyscall::HasLogind())
+  {
+    IPowerSyscall *m_instance = new CLogindUPowerSyscall;
+    if (m_instance->CanPowerdown())
+      s = m_instance->Powerdown();
+    delete m_instance;
+  }
+#endif
+  return s;
+}
+
+bool CRaspberryPIPowerSyscall::Reboot()
+{
+  int s = false;
+#if defined(HAS_DBUS)
+  if (CLogindUPowerSyscall::HasLogind())
+  {
+    IPowerSyscall *m_instance = new CLogindUPowerSyscall;
+    if (m_instance->CanReboot())
+      s = m_instance->Reboot();
+    delete m_instance;
+  }
+#endif
+  return s;
+}
+
 #endif
diff --git a/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.h b/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.h
index fd1d67c..062132e 100644
--- a/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.h
+++ b/xbmc/powermanagement/linux/RaspberryPIPowerSyscall.h
@@ -31,11 +31,11 @@ class CRaspberryPIPowerSyscall : public CPowerSyscallVirtualSleep
   CRaspberryPIPowerSyscall() : CPowerSyscallVirtualSleep() {}
   virtual ~CRaspberryPIPowerSyscall() {}
 
-  virtual bool Powerdown()    { return false; }
+  virtual bool Powerdown();
   virtual bool Hibernate()    { return false; }
-  virtual bool Reboot()       { return false; }
+  virtual bool Reboot();
 
-  virtual bool CanPowerdown() { return false; }
+  virtual bool CanPowerdown() { return true; }
   virtual bool CanHibernate() { return false; }
   virtual bool CanReboot()    { return true; }
 

From 21ff1d4748a4297716e53e78b347cf0f1c60ff4c Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 26 Apr 2014 17:27:52 +0100
Subject: [PATCH 36/89] [cec] Don't suspend pi on tv switch off - it can't wake
 up

---
 system/peripherals.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/system/peripherals.xml b/system/peripherals.xml
index 094a3c1..0b89ee8 100644
--- a/system/peripherals.xml
+++ b/system/peripherals.xml
@@ -16,7 +16,7 @@
     <setting key="send_inactive_source" type="bool" value="1" label="36025" order="5" />
     <setting key="cec_standby_screensaver" type="bool" value="0" label="36009" order="6" />
     <setting key="cec_wake_screensaver" type="bool" value="1" label="36010" order="7" />
-    <setting key="standby_pc_on_tv_standby" type="enum" value="13011" label="36029" order="8" lvalues="36028|13005|13011" />
+    <setting key="standby_pc_on_tv_standby" type="enum" value="36028" label="36029" order="8" lvalues="36028|13005|13011" />
     <setting key="standby_tv_on_pc_standby" type="bool" value="1" label="36026" order="9" />
     <setting key="use_tv_menu_language" type="bool" value="1" label="36018" order="10" />
     <setting key="pause_playback_on_deactivate" type="bool" value="1" label="36033" order="11" />

From 2697d6cb2ff2bbbb7be8fd40370e654c227a1b86 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 27 Jun 2014 00:01:05 +0100
Subject: [PATCH 37/89] [rbp] Resume video output on startup

---
 xbmc/linux/RBP.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/xbmc/linux/RBP.cpp b/xbmc/linux/RBP.cpp
index 160eb96..1472d10 100644
--- a/xbmc/linux/RBP.cpp
+++ b/xbmc/linux/RBP.cpp
@@ -86,6 +86,9 @@ bool CRBP::Initialize()
   if (g_advancedSettings.m_cacheMemBufferSize == ~0U)
     g_advancedSettings.m_cacheMemBufferSize = m_arm_mem < 256 ? 1024 * 1024 * 2 : 1024 * 1024 * 20;
 
+  // in case xbcm was restarted when suspended
+  ResumeVideoOutput();
+
   g_OMXImage.Initialize();
   m_omx_image_init = true;
   return true;

From 266a5a51a12a418f95c2c366e147e0c5e9c6eaee Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 11 Apr 2014 16:12:27 +0100
Subject: [PATCH 38/89] [omxplayer] Add ability to log more timestamp info in
 extra debug settings

---
 addons/resource.language.en_gb/resources/strings.po |  5 +++++
 xbmc/commons/ilog.h                                 |  1 +
 xbmc/cores/omxplayer/OMXHelper.cpp                  | 12 +++++++-----
 xbmc/cores/omxplayer/OMXPlayerAudio.cpp             |  8 ++++----
 xbmc/cores/omxplayer/OMXPlayerVideo.cpp             |  9 +++++----
 xbmc/settings/AdvancedSettings.cpp                  |  3 +++
 6 files changed, 25 insertions(+), 13 deletions(-)

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index 804e295..1b70492 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -2915,6 +2915,11 @@ msgctxt "#680"
 msgid "Verbose logging for VIDEO component"
 msgstr ""
 
+#: xbmc/settings/AdvancedSettings.cpp
+msgctxt "#697"
+msgid "Verbose logging for OMXPLAYER"
+msgstr ""
+
 #empty strings from id 681 to 699
 
 msgctxt "#700"
diff --git a/xbmc/commons/ilog.h b/xbmc/commons/ilog.h
index de90359..e4ffb5e 100644
--- a/xbmc/commons/ilog.h
+++ b/xbmc/commons/ilog.h
@@ -53,6 +53,7 @@
 #define LOGUPNP     (1 << (LOGMASKBIT + 8))
 #define LOGCEC      (1 << (LOGMASKBIT + 9))
 #define LOGVIDEO    (1 << (LOGMASKBIT + 10))
+#define LOGOMXPLAYER (1 << (LOGMASKBIT + 16))
 
 #include "utils/params_check_macros.h"
 
diff --git a/xbmc/cores/omxplayer/OMXHelper.cpp b/xbmc/cores/omxplayer/OMXHelper.cpp
index be54f31..9739ed0 100644
--- a/xbmc/cores/omxplayer/OMXHelper.cpp
+++ b/xbmc/cores/omxplayer/OMXHelper.cpp
@@ -23,6 +23,7 @@
 #ifdef HAS_OMXPLAYER
 
 #include "DVDPlayer.h"
+#include "settings/AdvancedSettings.h"
 #include "settings/Settings.h"
 #include "settings/MediaSettings.h"
 #include "DVDInputStreams/DVDInputStream.h"
@@ -140,7 +141,8 @@ bool OMXDoProcessing(struct SOmxPlayerState &m_OmxPlayerState, int m_playSpeed,
     m_OmxPlayerState.video_fifo = (int)(100.0*(m_dvdPlayerVideo->GetDecoderBufferSize()-m_dvdPlayerVideo->GetDecoderFreeSpace())/m_dvdPlayerVideo->GetDecoderBufferSize());
     m_OmxPlayerState.audio_fifo = (int)(100.0*audio_fifo/m_dvdPlayerAudio->GetCacheTotal());
 
-    #ifdef _DEBUG
+  if (g_advancedSettings.CanLogComponent(LOGOMXPLAYER))
+  {
     static unsigned count;
     if ((count++ & 7) == 0)
     {
@@ -160,7 +162,7 @@ bool OMXDoProcessing(struct SOmxPlayerState &m_OmxPlayerState, int m_playSpeed,
       vc_gencmd(response, sizeof response, "render_bar 7 audio_queue %d %d %d %d",
             m_dvdPlayerAudio->GetLevel(), 0, 0, 100);
     }
-    #endif
+  }
     if (audio_pts != DVD_NOPTS_VALUE)
     {
       audio_fifo_low = m_HasAudio && audio_fifo < threshold;
@@ -176,15 +178,15 @@ bool OMXDoProcessing(struct SOmxPlayerState &m_OmxPlayerState, int m_playSpeed,
     if (!m_HasVideo && m_HasAudio)
       video_fifo_high = true;
 
-    #ifdef _DEBUG
+  if (g_advancedSettings.CanLogComponent(LOGOMXPLAYER))
+  {
     CLog::Log(LOGDEBUG, "%s::%s M:%.6f-%.6f (A:%.6f V:%.6f) PEF:%d%d%d S:%.2f A:%.2f V:%.2f/T:%.2f (A:%d%d V:%d%d) A:%d%% V:%d%% (%.2f,%.2f)", "CDVDPlayer", __FUNCTION__,
       m_OmxPlayerState.stamp*1e-6, m_OmxPlayerState.av_clock.OMXClockAdjustment()*1e-6, audio_pts*1e-6, video_pts*1e-6,
       m_OmxPlayerState.av_clock.OMXIsPaused(), m_OmxPlayerState.bOmxSentEOFs, not_accepts_data, m_playSpeed * (1.0f/DVD_PLAYSPEED_NORMAL),
       audio_pts == DVD_NOPTS_VALUE ? 0.0:audio_fifo, video_pts == DVD_NOPTS_VALUE ? 0.0:video_fifo, m_OmxPlayerState.threshold,
       audio_fifo_low, audio_fifo_high, video_fifo_low, video_fifo_high,
       m_dvdPlayerAudio->GetLevel(), m_dvdPlayerVideo->GetLevel(), m_dvdPlayerAudio->GetDelay(), (float)m_dvdPlayerAudio->GetCacheTotal());
-    #endif
-
+  }
     if(!m_Pause && (m_OmxPlayerState.bOmxSentEOFs || not_accepts_data || (audio_fifo_high && video_fifo_high) || m_playSpeed != DVD_PLAYSPEED_NORMAL))
     {
       if (m_OmxPlayerState.av_clock.OMXIsPaused())
diff --git a/xbmc/cores/omxplayer/OMXPlayerAudio.cpp b/xbmc/cores/omxplayer/OMXPlayerAudio.cpp
index c2da2d2..2f1df45 100644
--- a/xbmc/cores/omxplayer/OMXPlayerAudio.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayerAudio.cpp
@@ -366,10 +366,10 @@ void OMXPlayerAudio::Process()
       DemuxPacket* pPacket = ((CDVDMsgDemuxerPacket*)pMsg)->GetPacket();
       bool bPacketDrop     = ((CDVDMsgDemuxerPacket*)pMsg)->GetPacketDrop();
 
-      #ifdef _DEBUG
-      CLog::Log(LOGINFO, "Audio: dts:%.0f pts:%.0f size:%d (s:%d f:%d d:%d l:%d) s:%d %d/%d late:%d,%d", pPacket->dts, pPacket->pts,
-           (int)pPacket->iSize, m_started, m_flush, bPacketDrop, m_stalled, m_speed, 0, 0, (int)m_omxAudio.GetAudioRenderingLatency(), (int)m_hints_current.samplerate);
-      #endif
+      if (g_advancedSettings.CanLogComponent(LOGOMXPLAYER))
+        CLog::Log(LOGINFO, "Audio: dts:%.0f pts:%.0f size:%d (s:%d f:%d d:%d l:%d) s:%d %d/%d late:%d,%d", pPacket->dts, pPacket->pts,
+             (int)pPacket->iSize, m_started, m_flush, bPacketDrop, m_stalled, m_speed, 0, 0, (int)m_omxAudio.GetAudioRenderingLatency(), (int)m_hints_current.samplerate);
+
       if(Decode(pPacket, m_speed > DVD_PLAYSPEED_NORMAL || m_speed < 0 || bPacketDrop))
       {
         // we are not running until something is cached in output device
diff --git a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
index 5ca7665..8becff1 100644
--- a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
@@ -42,6 +42,7 @@
 #include "DVDOverlayRenderer.h"
 #include "settings/DisplaySettings.h"
 #include "settings/Settings.h"
+#include "settings/AdvancedSettings.h"
 #include "settings/MediaSettings.h"
 #include "cores/VideoRenderers/RenderFormats.h"
 #include "cores/VideoRenderers/RenderFlags.h"
@@ -461,10 +462,10 @@ void OMXPlayerVideo::Process()
       DemuxPacket* pPacket = ((CDVDMsgDemuxerPacket*)pMsg)->GetPacket();
       bool bPacketDrop     = ((CDVDMsgDemuxerPacket*)pMsg)->GetPacketDrop();
 
-      #ifdef _DEBUG
-      CLog::Log(LOGINFO, "Video: dts:%.0f pts:%.0f size:%d (s:%d f:%d d:%d l:%d) s:%d %d/%d late:%d\n", pPacket->dts, pPacket->pts, 
-          (int)pPacket->iSize, m_started, m_flush, bPacketDrop, m_stalled, m_speed, 0, 0, 0);
-      #endif
+      if (g_advancedSettings.CanLogComponent(LOGOMXPLAYER))
+        CLog::Log(LOGINFO, "Video: dts:%.0f pts:%.0f size:%d (s:%d f:%d d:%d l:%d) s:%d %d/%d late:%d\n", pPacket->dts, pPacket->pts,
+            (int)pPacket->iSize, m_started, m_flush, bPacketDrop, m_stalled, m_speed, 0, 0, 0);
+
       if (m_messageQueue.GetDataSize() == 0
       ||  m_speed < 0)
       {
diff --git a/xbmc/settings/AdvancedSettings.cpp b/xbmc/settings/AdvancedSettings.cpp
index 76b5ce8..139e12d 100644
--- a/xbmc/settings/AdvancedSettings.cpp
+++ b/xbmc/settings/AdvancedSettings.cpp
@@ -1364,6 +1364,9 @@ void CAdvancedSettings::SettingOptionsLoggingComponentsFiller(const CSetting *se
 #ifdef HAVE_LIBCEC
   list.push_back(std::make_pair(g_localizeStrings.Get(679), LOGCEC));
 #endif
+#ifdef TARGET_RASPBERRY_PI
+  list.push_back(std::make_pair(g_localizeStrings.Get(697), LOGOMXPLAYER));
+#endif
 }
 
 void CAdvancedSettings::setExtraLogLevel(const std::vector<CVariant> &components)

From ba20c596cce9f4e3e6112921182a25c899847c7d Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 7 Apr 2014 23:13:55 +0100
Subject: [PATCH 39/89] [omxplayer] Add ability to dump out audio/video data
 for later debugging

---
 .../resource.language.en_gb/resources/strings.po   | 10 +++++
 xbmc/commons/ilog.h                                |  2 +
 xbmc/cores/omxplayer/OMXAudio.cpp                  | 49 ++++++++++++++++++++++
 xbmc/cores/omxplayer/OMXVideo.cpp                  | 47 +++++++++++++++++++++
 xbmc/settings/AdvancedSettings.cpp                 |  4 ++
 5 files changed, 112 insertions(+)

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index 1b70492..19b94b5 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -2920,6 +2920,16 @@ msgctxt "#697"
 msgid "Verbose logging for OMXPLAYER"
 msgstr ""
 
+#: xbmc/settings/AdvancedSettings.cpp
+msgctxt "#698"
+msgid "Dump video frames to debug file"
+msgstr ""
+
+#: xbmc/settings/AdvancedSettings.cpp
+msgctxt "#699"
+msgid "Dump audio frames to debug file"
+msgstr ""
+
 #empty strings from id 681 to 699
 
 msgctxt "#700"
diff --git a/xbmc/commons/ilog.h b/xbmc/commons/ilog.h
index e4ffb5e..4f8926c 100644
--- a/xbmc/commons/ilog.h
+++ b/xbmc/commons/ilog.h
@@ -54,6 +54,8 @@
 #define LOGCEC      (1 << (LOGMASKBIT + 9))
 #define LOGVIDEO    (1 << (LOGMASKBIT + 10))
 #define LOGOMXPLAYER (1 << (LOGMASKBIT + 16))
+#define LOGDUMPVIDEO (1 << (LOGMASKBIT + 17))
+#define LOGDUMPAUDIO (1 << (LOGMASKBIT + 18))
 
 #include "utils/params_check_macros.h"
 
diff --git a/xbmc/cores/omxplayer/OMXAudio.cpp b/xbmc/cores/omxplayer/OMXAudio.cpp
index 1911189..6dff6aa 100644
--- a/xbmc/cores/omxplayer/OMXAudio.cpp
+++ b/xbmc/cores/omxplayer/OMXAudio.cpp
@@ -56,6 +56,49 @@ using namespace std;
 #define AUDIO_DECODE_OUTPUT_BUFFER (32*1024)
 static const char rounded_up_channels_shift[] = {0,0,1,2,2,3,3,3,3};
 
+//#define DEBUG_PLAYBACK
+static void dump_omx_buffer(OMX_BUFFERHEADERTYPE *omx_buffer)
+{
+  if (!(g_advancedSettings.CanLogComponent(LOGDUMPAUDIO)))
+    return;
+  static FILE *fp;
+  if (!omx_buffer)
+  {
+    if (fp)
+    {
+      fclose(fp);
+      fp = NULL;
+    }
+    return;
+  }
+  if (!fp)
+  {
+    char filename[1024];
+    strcpy(filename, g_advancedSettings.m_logFolder.c_str());
+    strcat(filename, "audio.dat");
+#ifdef DEBUG_PLAYBACK
+    fp = fopen(filename, "rb");
+#else
+    fp = fopen(filename, "wb");
+#endif
+    }
+  if (fp)
+  {
+#ifdef DEBUG_PLAYBACK
+    OMX_BUFFERHEADERTYPE omx = {0};
+    int s = fread(&omx, sizeof omx, 1, fp);
+    omx_buffer->nFilledLen = omx.nFilledLen;
+    omx_buffer->nFlags = omx.nFlags;
+    omx_buffer->nTimeStamp = omx.nTimeStamp;
+    if (s==1)
+      fread(omx_buffer->pBuffer, omx_buffer->nFilledLen, 1, fp);
+#else
+    if (fwrite(omx_buffer, sizeof *omx_buffer, 1, fp) == 1)
+      fwrite(omx_buffer->pBuffer, omx_buffer->nFilledLen, 1, fp);
+#endif
+  }
+}
+
 //////////////////////////////////////////////////////////////////////
 // Construction/Destruction
 //////////////////////////////////////////////////////////////////////
@@ -871,6 +914,7 @@ bool COMXAudio::Initialize(AEAudioFormat format, OMXClock *clock, CDVDStreamInfo
     memcpy((unsigned char *)omx_buffer->pBuffer, &m_wave_header, omx_buffer->nFilledLen);
     omx_buffer->nFlags = OMX_BUFFERFLAG_CODECCONFIG | OMX_BUFFERFLAG_ENDOFFRAME;
 
+    dump_omx_buffer(omx_buffer);
     omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
     if (omx_err != OMX_ErrorNone)
     {
@@ -899,6 +943,7 @@ bool COMXAudio::Initialize(AEAudioFormat format, OMXClock *clock, CDVDStreamInfo
       memcpy((unsigned char *)omx_buffer->pBuffer, m_extradata, omx_buffer->nFilledLen);
       omx_buffer->nFlags = OMX_BUFFERFLAG_CODECCONFIG | OMX_BUFFERFLAG_ENDOFFRAME;
   
+      dump_omx_buffer(omx_buffer);
       omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
       if (omx_err != OMX_ErrorNone)
       {
@@ -936,6 +981,8 @@ bool COMXAudio::Deinitialize()
 {
   CSingleLock lock (m_critSection);
 
+  dump_omx_buffer(NULL);
+
   if ( m_omx_tunnel_clock_analog.IsInitialized() )
     m_omx_tunnel_clock_analog.Deestablish();
   if ( m_omx_tunnel_clock_hdmi.IsInitialized() )
@@ -1223,6 +1270,7 @@ unsigned int COMXAudio::AddPackets(const void* data, unsigned int len, double dt
     if(demuxer_samples_sent == demuxer_samples)
       omx_buffer->nFlags |= OMX_BUFFERFLAG_ENDOFFRAME;
 
+    dump_omx_buffer(omx_buffer);
     omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
     if (omx_err != OMX_ErrorNone)
     {
@@ -1461,6 +1509,7 @@ void COMXAudio::SubmitEOS()
 
   omx_buffer->nFlags = OMX_BUFFERFLAG_ENDOFFRAME | OMX_BUFFERFLAG_EOS | OMX_BUFFERFLAG_TIME_UNKNOWN;
 
+  dump_omx_buffer(omx_buffer);
   omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
   if (omx_err != OMX_ErrorNone)
   {
diff --git a/xbmc/cores/omxplayer/OMXVideo.cpp b/xbmc/cores/omxplayer/OMXVideo.cpp
index ca40a37..0fb426c 100644
--- a/xbmc/cores/omxplayer/OMXVideo.cpp
+++ b/xbmc/cores/omxplayer/OMXVideo.cpp
@@ -65,6 +65,49 @@
 
 #define MAX_TEXT_LENGTH 1024
 
+//#define DEBUG_PLAYBACK
+static void dump_omx_buffer(OMX_BUFFERHEADERTYPE *omx_buffer)
+{
+  if (!(g_advancedSettings.CanLogComponent(LOGDUMPVIDEO)))
+    return;
+  static FILE *fp;
+  if (!omx_buffer)
+  {
+    if (fp)
+    {
+      fclose(fp);
+      fp = NULL;
+    }
+    return;
+  }
+  if (!fp)
+  {
+    char filename[1024];
+    strcpy(filename, g_advancedSettings.m_logFolder.c_str());
+    strcat(filename, "video.dat");
+#ifdef DEBUG_PLAYBACK
+    fp = fopen(filename, "rb");
+#else
+    fp = fopen(filename, "wb");
+#endif
+    }
+  if (fp)
+  {
+#ifdef DEBUG_PLAYBACK
+    OMX_BUFFERHEADERTYPE omx = {0};
+    int s = fread(&omx, sizeof omx, 1, fp);
+    omx_buffer->nFilledLen = omx.nFilledLen;
+    omx_buffer->nFlags = omx.nFlags;
+    omx_buffer->nTimeStamp = omx.nTimeStamp;
+    if (s==1)
+      fread(omx_buffer->pBuffer, omx_buffer->nFilledLen, 1, fp);
+#else
+    if (fwrite(omx_buffer, sizeof *omx_buffer, 1, fp) == 1)
+      fwrite(omx_buffer->pBuffer, omx_buffer->nFilledLen, 1, fp);
+#endif
+  }
+}
+
 COMXVideo::COMXVideo() : m_video_codec_name("")
 {
   m_is_open           = false;
@@ -115,6 +158,7 @@ bool COMXVideo::SendDecoderConfig()
     memcpy((unsigned char *)omx_buffer->pBuffer, m_extradata, omx_buffer->nFilledLen);
     omx_buffer->nFlags = OMX_BUFFERFLAG_CODECCONFIG | OMX_BUFFERFLAG_ENDOFFRAME;
   
+    dump_omx_buffer(omx_buffer);
     omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
     if (omx_err != OMX_ErrorNone)
     {
@@ -692,6 +736,7 @@ bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, EDEINTERLACEMODE de
 void COMXVideo::Close()
 {
   CSingleLock lock (m_critSection);
+  dump_omx_buffer(NULL);
   m_omx_tunnel_clock.Deestablish();
   m_omx_tunnel_decoder.Deestablish();
   if(m_deinterlace)
@@ -807,6 +852,7 @@ int COMXVideo::Decode(uint8_t *pData, int iSize, double pts)
       if(demuxer_bytes == 0)
         omx_buffer->nFlags |= OMX_BUFFERFLAG_ENDOFFRAME;
 
+      dump_omx_buffer(omx_buffer);
       omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
       if (omx_err != OMX_ErrorNone)
       {
@@ -928,6 +974,7 @@ void COMXVideo::SubmitEOS()
 
   omx_buffer->nFlags = OMX_BUFFERFLAG_ENDOFFRAME | OMX_BUFFERFLAG_EOS | OMX_BUFFERFLAG_TIME_UNKNOWN;
   
+  dump_omx_buffer(omx_buffer);
   omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
   if (omx_err != OMX_ErrorNone)
   {
diff --git a/xbmc/settings/AdvancedSettings.cpp b/xbmc/settings/AdvancedSettings.cpp
index 139e12d..ea45381 100644
--- a/xbmc/settings/AdvancedSettings.cpp
+++ b/xbmc/settings/AdvancedSettings.cpp
@@ -1367,6 +1367,10 @@ void CAdvancedSettings::SettingOptionsLoggingComponentsFiller(const CSetting *se
 #ifdef TARGET_RASPBERRY_PI
   list.push_back(std::make_pair(g_localizeStrings.Get(697), LOGOMXPLAYER));
 #endif
+#ifdef TARGET_RASPBERRY_PI
+  list.push_back(std::make_pair(g_localizeStrings.Get(698), LOGDUMPVIDEO));
+  list.push_back(std::make_pair(g_localizeStrings.Get(699), LOGDUMPAUDIO));
+#endif
 }
 
 void CAdvancedSettings::setExtraLogLevel(const std::vector<CVariant> &components)

From 4f9a70ab2488ac8b8dd154613e368a0060493d88 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 3 Nov 2014 17:16:54 +0000
Subject: [PATCH 40/89] Revert "[omxplayer] Add ability to dump out audio/video
 data for later debugging"

This reverts commit 417416bd29d00f1b42c77488d06e9e6840b8c4f4.
---
 .../resource.language.en_gb/resources/strings.po   | 10 -----
 xbmc/commons/ilog.h                                |  2 -
 xbmc/cores/omxplayer/OMXAudio.cpp                  | 49 ----------------------
 xbmc/cores/omxplayer/OMXVideo.cpp                  | 47 ---------------------
 xbmc/settings/AdvancedSettings.cpp                 |  4 --
 5 files changed, 112 deletions(-)

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index 19b94b5..1b70492 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -2920,16 +2920,6 @@ msgctxt "#697"
 msgid "Verbose logging for OMXPLAYER"
 msgstr ""
 
-#: xbmc/settings/AdvancedSettings.cpp
-msgctxt "#698"
-msgid "Dump video frames to debug file"
-msgstr ""
-
-#: xbmc/settings/AdvancedSettings.cpp
-msgctxt "#699"
-msgid "Dump audio frames to debug file"
-msgstr ""
-
 #empty strings from id 681 to 699
 
 msgctxt "#700"
diff --git a/xbmc/commons/ilog.h b/xbmc/commons/ilog.h
index 4f8926c..e4ffb5e 100644
--- a/xbmc/commons/ilog.h
+++ b/xbmc/commons/ilog.h
@@ -54,8 +54,6 @@
 #define LOGCEC      (1 << (LOGMASKBIT + 9))
 #define LOGVIDEO    (1 << (LOGMASKBIT + 10))
 #define LOGOMXPLAYER (1 << (LOGMASKBIT + 16))
-#define LOGDUMPVIDEO (1 << (LOGMASKBIT + 17))
-#define LOGDUMPAUDIO (1 << (LOGMASKBIT + 18))
 
 #include "utils/params_check_macros.h"
 
diff --git a/xbmc/cores/omxplayer/OMXAudio.cpp b/xbmc/cores/omxplayer/OMXAudio.cpp
index 6dff6aa..1911189 100644
--- a/xbmc/cores/omxplayer/OMXAudio.cpp
+++ b/xbmc/cores/omxplayer/OMXAudio.cpp
@@ -56,49 +56,6 @@ using namespace std;
 #define AUDIO_DECODE_OUTPUT_BUFFER (32*1024)
 static const char rounded_up_channels_shift[] = {0,0,1,2,2,3,3,3,3};
 
-//#define DEBUG_PLAYBACK
-static void dump_omx_buffer(OMX_BUFFERHEADERTYPE *omx_buffer)
-{
-  if (!(g_advancedSettings.CanLogComponent(LOGDUMPAUDIO)))
-    return;
-  static FILE *fp;
-  if (!omx_buffer)
-  {
-    if (fp)
-    {
-      fclose(fp);
-      fp = NULL;
-    }
-    return;
-  }
-  if (!fp)
-  {
-    char filename[1024];
-    strcpy(filename, g_advancedSettings.m_logFolder.c_str());
-    strcat(filename, "audio.dat");
-#ifdef DEBUG_PLAYBACK
-    fp = fopen(filename, "rb");
-#else
-    fp = fopen(filename, "wb");
-#endif
-    }
-  if (fp)
-  {
-#ifdef DEBUG_PLAYBACK
-    OMX_BUFFERHEADERTYPE omx = {0};
-    int s = fread(&omx, sizeof omx, 1, fp);
-    omx_buffer->nFilledLen = omx.nFilledLen;
-    omx_buffer->nFlags = omx.nFlags;
-    omx_buffer->nTimeStamp = omx.nTimeStamp;
-    if (s==1)
-      fread(omx_buffer->pBuffer, omx_buffer->nFilledLen, 1, fp);
-#else
-    if (fwrite(omx_buffer, sizeof *omx_buffer, 1, fp) == 1)
-      fwrite(omx_buffer->pBuffer, omx_buffer->nFilledLen, 1, fp);
-#endif
-  }
-}
-
 //////////////////////////////////////////////////////////////////////
 // Construction/Destruction
 //////////////////////////////////////////////////////////////////////
@@ -914,7 +871,6 @@ bool COMXAudio::Initialize(AEAudioFormat format, OMXClock *clock, CDVDStreamInfo
     memcpy((unsigned char *)omx_buffer->pBuffer, &m_wave_header, omx_buffer->nFilledLen);
     omx_buffer->nFlags = OMX_BUFFERFLAG_CODECCONFIG | OMX_BUFFERFLAG_ENDOFFRAME;
 
-    dump_omx_buffer(omx_buffer);
     omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
     if (omx_err != OMX_ErrorNone)
     {
@@ -943,7 +899,6 @@ bool COMXAudio::Initialize(AEAudioFormat format, OMXClock *clock, CDVDStreamInfo
       memcpy((unsigned char *)omx_buffer->pBuffer, m_extradata, omx_buffer->nFilledLen);
       omx_buffer->nFlags = OMX_BUFFERFLAG_CODECCONFIG | OMX_BUFFERFLAG_ENDOFFRAME;
   
-      dump_omx_buffer(omx_buffer);
       omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
       if (omx_err != OMX_ErrorNone)
       {
@@ -981,8 +936,6 @@ bool COMXAudio::Deinitialize()
 {
   CSingleLock lock (m_critSection);
 
-  dump_omx_buffer(NULL);
-
   if ( m_omx_tunnel_clock_analog.IsInitialized() )
     m_omx_tunnel_clock_analog.Deestablish();
   if ( m_omx_tunnel_clock_hdmi.IsInitialized() )
@@ -1270,7 +1223,6 @@ unsigned int COMXAudio::AddPackets(const void* data, unsigned int len, double dt
     if(demuxer_samples_sent == demuxer_samples)
       omx_buffer->nFlags |= OMX_BUFFERFLAG_ENDOFFRAME;
 
-    dump_omx_buffer(omx_buffer);
     omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
     if (omx_err != OMX_ErrorNone)
     {
@@ -1509,7 +1461,6 @@ void COMXAudio::SubmitEOS()
 
   omx_buffer->nFlags = OMX_BUFFERFLAG_ENDOFFRAME | OMX_BUFFERFLAG_EOS | OMX_BUFFERFLAG_TIME_UNKNOWN;
 
-  dump_omx_buffer(omx_buffer);
   omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
   if (omx_err != OMX_ErrorNone)
   {
diff --git a/xbmc/cores/omxplayer/OMXVideo.cpp b/xbmc/cores/omxplayer/OMXVideo.cpp
index 0fb426c..ca40a37 100644
--- a/xbmc/cores/omxplayer/OMXVideo.cpp
+++ b/xbmc/cores/omxplayer/OMXVideo.cpp
@@ -65,49 +65,6 @@
 
 #define MAX_TEXT_LENGTH 1024
 
-//#define DEBUG_PLAYBACK
-static void dump_omx_buffer(OMX_BUFFERHEADERTYPE *omx_buffer)
-{
-  if (!(g_advancedSettings.CanLogComponent(LOGDUMPVIDEO)))
-    return;
-  static FILE *fp;
-  if (!omx_buffer)
-  {
-    if (fp)
-    {
-      fclose(fp);
-      fp = NULL;
-    }
-    return;
-  }
-  if (!fp)
-  {
-    char filename[1024];
-    strcpy(filename, g_advancedSettings.m_logFolder.c_str());
-    strcat(filename, "video.dat");
-#ifdef DEBUG_PLAYBACK
-    fp = fopen(filename, "rb");
-#else
-    fp = fopen(filename, "wb");
-#endif
-    }
-  if (fp)
-  {
-#ifdef DEBUG_PLAYBACK
-    OMX_BUFFERHEADERTYPE omx = {0};
-    int s = fread(&omx, sizeof omx, 1, fp);
-    omx_buffer->nFilledLen = omx.nFilledLen;
-    omx_buffer->nFlags = omx.nFlags;
-    omx_buffer->nTimeStamp = omx.nTimeStamp;
-    if (s==1)
-      fread(omx_buffer->pBuffer, omx_buffer->nFilledLen, 1, fp);
-#else
-    if (fwrite(omx_buffer, sizeof *omx_buffer, 1, fp) == 1)
-      fwrite(omx_buffer->pBuffer, omx_buffer->nFilledLen, 1, fp);
-#endif
-  }
-}
-
 COMXVideo::COMXVideo() : m_video_codec_name("")
 {
   m_is_open           = false;
@@ -158,7 +115,6 @@ bool COMXVideo::SendDecoderConfig()
     memcpy((unsigned char *)omx_buffer->pBuffer, m_extradata, omx_buffer->nFilledLen);
     omx_buffer->nFlags = OMX_BUFFERFLAG_CODECCONFIG | OMX_BUFFERFLAG_ENDOFFRAME;
   
-    dump_omx_buffer(omx_buffer);
     omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
     if (omx_err != OMX_ErrorNone)
     {
@@ -736,7 +692,6 @@ bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, EDEINTERLACEMODE de
 void COMXVideo::Close()
 {
   CSingleLock lock (m_critSection);
-  dump_omx_buffer(NULL);
   m_omx_tunnel_clock.Deestablish();
   m_omx_tunnel_decoder.Deestablish();
   if(m_deinterlace)
@@ -852,7 +807,6 @@ int COMXVideo::Decode(uint8_t *pData, int iSize, double pts)
       if(demuxer_bytes == 0)
         omx_buffer->nFlags |= OMX_BUFFERFLAG_ENDOFFRAME;
 
-      dump_omx_buffer(omx_buffer);
       omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
       if (omx_err != OMX_ErrorNone)
       {
@@ -974,7 +928,6 @@ void COMXVideo::SubmitEOS()
 
   omx_buffer->nFlags = OMX_BUFFERFLAG_ENDOFFRAME | OMX_BUFFERFLAG_EOS | OMX_BUFFERFLAG_TIME_UNKNOWN;
   
-  dump_omx_buffer(omx_buffer);
   omx_err = m_omx_decoder.EmptyThisBuffer(omx_buffer);
   if (omx_err != OMX_ErrorNone)
   {
diff --git a/xbmc/settings/AdvancedSettings.cpp b/xbmc/settings/AdvancedSettings.cpp
index ea45381..139e12d 100644
--- a/xbmc/settings/AdvancedSettings.cpp
+++ b/xbmc/settings/AdvancedSettings.cpp
@@ -1367,10 +1367,6 @@ void CAdvancedSettings::SettingOptionsLoggingComponentsFiller(const CSetting *se
 #ifdef TARGET_RASPBERRY_PI
   list.push_back(std::make_pair(g_localizeStrings.Get(697), LOGOMXPLAYER));
 #endif
-#ifdef TARGET_RASPBERRY_PI
-  list.push_back(std::make_pair(g_localizeStrings.Get(698), LOGDUMPVIDEO));
-  list.push_back(std::make_pair(g_localizeStrings.Get(699), LOGDUMPAUDIO));
-#endif
 }
 
 void CAdvancedSettings::setExtraLogLevel(const std::vector<CVariant> &components)

From 1dd87e754c11ac47b4e96eb465b5503206a04aef Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 7 Apr 2014 23:13:55 +0100
Subject: [PATCH 41/89] [omxplayer] Add ability to dump out audio/video data
 for later debugging

---
 .../resource.language.en_gb/resources/strings.po   | 10 ++++
 xbmc/commons/ilog.h                                |  2 +
 xbmc/cores/dvdplayer/DVDPlayer.cpp                 | 63 ++++++++++++++++++++++
 xbmc/settings/AdvancedSettings.cpp                 |  4 ++
 4 files changed, 79 insertions(+)

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index 1b70492..19b94b5 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -2920,6 +2920,16 @@ msgctxt "#697"
 msgid "Verbose logging for OMXPLAYER"
 msgstr ""
 
+#: xbmc/settings/AdvancedSettings.cpp
+msgctxt "#698"
+msgid "Dump video frames to debug file"
+msgstr ""
+
+#: xbmc/settings/AdvancedSettings.cpp
+msgctxt "#699"
+msgid "Dump audio frames to debug file"
+msgstr ""
+
 #empty strings from id 681 to 699
 
 msgctxt "#700"
diff --git a/xbmc/commons/ilog.h b/xbmc/commons/ilog.h
index e4ffb5e..4f8926c 100644
--- a/xbmc/commons/ilog.h
+++ b/xbmc/commons/ilog.h
@@ -54,6 +54,8 @@
 #define LOGCEC      (1 << (LOGMASKBIT + 9))
 #define LOGVIDEO    (1 << (LOGMASKBIT + 10))
 #define LOGOMXPLAYER (1 << (LOGMASKBIT + 16))
+#define LOGDUMPVIDEO (1 << (LOGMASKBIT + 17))
+#define LOGDUMPAUDIO (1 << (LOGMASKBIT + 18))
 
 #include "utils/params_check_macros.h"
 
diff --git a/xbmc/cores/dvdplayer/DVDPlayer.cpp b/xbmc/cores/dvdplayer/DVDPlayer.cpp
index 3c313cd..8ceb498 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayer.cpp
@@ -96,6 +96,61 @@
 using namespace std;
 using namespace PVR;
 
+//#define DEBUG_PLAYBACK
+static void dump_packet(DemuxPacket *packet, bool video, bool audio)
+{
+  static CCriticalSection m_section;
+  static FILE *fp_video, *fp_audio;
+  if ((!video || !g_advancedSettings.CanLogComponent(LOGDUMPVIDEO)) &&
+      (!audio || !g_advancedSettings.CanLogComponent(LOGDUMPAUDIO)))
+    return;
+  const char *fname = video ? "video.dat" : "audio.dat";
+  FILE *&fp = video ? fp_video : fp_audio;
+  CSingleLock lock(m_section);
+  if (!packet)
+  {
+    if (fp)
+    {
+      CLog::Log(LOGNOTICE, "%s:: Closing file %p", __func__, fp);
+      fclose(fp);
+      fp = NULL;
+    }
+    return;
+  }
+  if (!fp)
+  {
+    char filename[1024];
+    strcpy(filename, g_advancedSettings.m_logFolder.c_str());
+    strcat(filename, fname);
+#ifdef DEBUG_PLAYBACK
+    fp = fopen(filename, "rb");
+#else
+    fp = fopen(filename, "wb");
+#endif
+    CLog::Log(LOGNOTICE, "%s:: Opening file %s = %p", __func__, filename, fp);
+  }
+  if (fp)
+  {
+#ifdef DEBUG_PLAYBACK
+    DemuxPacket p = {0};
+    int s = fread(&p, sizeof p, 1, fp);
+    if (s==1)
+    {
+      packet->iSize = p.iSize;
+      packet->dts = p.dts;
+      packet->pts = p.pts;
+      _aligned_free(packet->pData);
+      packet->pData = (uint8_t*)_aligned_malloc(packet->iSize + FF_INPUT_BUFFER_PADDING_SIZE, 16);
+      fread(packet->pData, packet->iSize, 1, fp);
+    }
+#else
+    if (fwrite(packet, sizeof *packet, 1, fp) == 1)
+      fwrite(packet->pData, packet->iSize, 1, fp);
+#endif
+  }
+}
+
+
 void CSelectionStreams::Clear(StreamType type, StreamSource source)
 {
   CSingleLock lock(m_section);
@@ -974,6 +1029,12 @@ bool CDVDPlayer::ReadPacket(DemuxPacket*& packet, CDemuxStream*& stream)
         return true;
     }
 
+    if(m_pDemuxer)
+    {
+      stream = m_pDemuxer->GetStream(packet->iStreamId);
+      if (stream)
+        dump_packet(packet, CheckIsCurrent(m_CurrentVideo, stream, packet), CheckIsCurrent(m_CurrentAudio, stream, packet));
+    }
     UpdateCorrection(packet, m_offset_pts);
 
     if(packet->iStreamId < 0)
@@ -3475,6 +3536,8 @@ bool CDVDPlayer::CloseStream(CCurrentStream& current, bool bWaitForBuffers)
   if(bWaitForBuffers)
     SetCaching(CACHESTATE_DONE);
 
+  dump_packet(NULL, current.player == DVDPLAYER_VIDEO, current.player == DVDPLAYER_AUDIO);
+
   IDVDStreamPlayer* player = GetStreamPlayer(current.player);
   if(player)
     player->CloseStream(bWaitForBuffers);
diff --git a/xbmc/settings/AdvancedSettings.cpp b/xbmc/settings/AdvancedSettings.cpp
index 139e12d..ea45381 100644
--- a/xbmc/settings/AdvancedSettings.cpp
+++ b/xbmc/settings/AdvancedSettings.cpp
@@ -1367,6 +1367,10 @@ void CAdvancedSettings::SettingOptionsLoggingComponentsFiller(const CSetting *se
 #ifdef TARGET_RASPBERRY_PI
   list.push_back(std::make_pair(g_localizeStrings.Get(697), LOGOMXPLAYER));
 #endif
+#ifdef TARGET_RASPBERRY_PI
+  list.push_back(std::make_pair(g_localizeStrings.Get(698), LOGDUMPVIDEO));
+  list.push_back(std::make_pair(g_localizeStrings.Get(699), LOGDUMPAUDIO));
+#endif
 }
 
 void CAdvancedSettings::setExtraLogLevel(const std::vector<CVariant> &components)

From c5426decde782f01e418f10fa2b4221b1b8e6157 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 29 Nov 2014 15:25:16 +0000
Subject: [PATCH 42/89] [rbp] hack: wait for splash to complete before changing
 hdmi mode

---
 xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp | 49 +++++++++++++++++++++++++
 1 file changed, 49 insertions(+)

diff --git a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
index 7d9b0d3..d388373 100644
--- a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
@@ -217,12 +217,61 @@ int CEGLNativeTypeRaspberryPI::AddUniqueResolution(RESOLUTION_INFO &res, std::ve
 }
 #endif
 
+#include <dirent.h>
+
+pid_t proc_find(const char* name)
+{
+    DIR* dir;
+    struct dirent* ent;
+    char buf[512];
+
+    long  pid;
+    char pname[100] = {0,};
+    char state;
+    FILE *fp=NULL;
+
+    if (!(dir = opendir("/proc"))) {
+        perror("can't open /proc");
+        return -1;
+    }
+
+    while((ent = readdir(dir)) != NULL) {
+        long lpid = atol(ent->d_name);
+        if(lpid < 0)
+            continue;
+        snprintf(buf, sizeof(buf), "/proc/%ld/stat", lpid);
+        fp = fopen(buf, "r");
+
+        if (fp) {
+            if ( (fscanf(fp, "%ld (%[^)]) %c", &pid, pname, &state)) != 3 ){
+                printf("fscanf failed \n");
+                fclose(fp);
+                closedir(dir);
+                return -1;
+            }
+            if (!strcmp(pname, name)) {
+                fclose(fp);
+                closedir(dir);
+                return (pid_t)lpid;
+            }
+            fclose(fp);
+        }
+    }
+
+    closedir(dir);
+    return -1;
+}
+
+
 bool CEGLNativeTypeRaspberryPI::SetNativeResolution(const RESOLUTION_INFO &res)
 {
 #if defined(TARGET_RASPBERRY_PI)
   if(!m_DllBcmHost || !m_nativeWindow)
     return false;
 
+  while (proc_find("hello_video.bin") >= 0)
+    Sleep(100);
+
   DestroyDispmaxWindow();
 
   if(GETFLAGS_GROUP(res.dwFlags) && GETFLAGS_MODE(res.dwFlags))

From 9ed5eff1125f8484ce829b87342fb99856ef8bea Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sun, 5 Oct 2014 14:05:25 +0100
Subject: [PATCH 43/89] [PiSink] Allow audio output latency to be set in
 settings

---
 addons/resource.language.en_gb/resources/strings.po | 15 +++++++++++++++
 system/settings/rbp.xml                             | 12 ++++++++++++
 xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp           | 13 ++++++++-----
 xbmc/cores/AudioEngine/Sinks/AESinkPi.h             |  1 +
 4 files changed, 36 insertions(+), 5 deletions(-)

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index 19b94b5..37932be 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -16639,3 +16639,18 @@ msgstr ""
 msgctxt "#38052"
 msgid "Remote button press release time (ms)"
 msgstr ""
+
+#: system/settings/rbp.xml
+msgctxt "#38100"
+msgid "Audio output latency"
+msgstr ""
+
+#: system/settings/rbp.xml
+msgctxt "#38101"
+msgid "Increase this to protect against underruns, reduce to have lower latency gui sounds"
+msgstr ""
+
+#: system/settings/rbp.xml
+msgctxt "#38102"
+msgid "%i ms"
+msgstr ""
diff --git a/system/settings/rbp.xml b/system/settings/rbp.xml
index 8496abf..5068b20 100644
--- a/system/settings/rbp.xml
+++ b/system/settings/rbp.xml
@@ -89,6 +89,18 @@
         <setting id="audiooutput.processquality">
           <default>101</default> <!-- AE_QUALITY_GPU -->
         </setting>
+         <setting id="audiooutput.latency" type="integer" label="38100" help="38101">
+          <level>3</level>
+          <default>100</default>
+          <constraints>
+            <minimum>50</minimum>
+            <step>50</step>
+            <maximum>300</maximum>
+          </constraints>
+          <control type="spinner" format="string">
+            <formatlabel>38102</formatlabel>
+          </control>
+        </setting>
       </group>
       <group id="3">
         <setting id="audiooutput.ac3transcode" help="37024">
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp
index d72a97a..b69925a 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkPi.cpp
@@ -35,7 +35,6 @@
 #define CLASSNAME "CAESinkPi"
 
 #define NUM_OMX_BUFFERS 2
-#define AUDIO_PLAYBUFFER (0.1) // 100ms
 
 static const unsigned int PassthroughSampleRates[] = { 8000, 11025, 16000, 22050, 24000, 32000, 44100, 48000, 88200, 96000, 176400, 192000 };
 
@@ -43,6 +42,7 @@ CAEDeviceInfo CAESinkPi::m_info;
 
 CAESinkPi::CAESinkPi() :
     m_sinkbuffer_sec_per_byte(0),
+    m_latency(0),
     m_Initialized(false),
     m_submitted(0),
     m_omx_output(NULL),
@@ -191,6 +191,9 @@ bool CAESinkPi::Initialize(AEAudioFormat &format, std::string &device)
   m_initDevice = device;
   m_initFormat = format;
 
+  m_latency = CSettings::Get().GetInt("audiooutput.latency") * 1e-3;
+  m_latency = std::max(m_latency, 50e-3);
+
   if (m_passthrough || CSettings::Get().GetString("audiooutput.audiodevice") == "PI:HDMI")
     m_output = AESINKPI_HDMI;
   else if (CSettings::Get().GetString("audiooutput.audiodevice") == "PI:Analogue")
@@ -212,7 +215,7 @@ bool CAESinkPi::Initialize(AEAudioFormat &format, std::string &device)
   unsigned int sample_size = CAEUtil::DataFormatToBits(format.m_dataFormat) >> 3;
   format.m_frameSize     = sample_size * channels;
   format.m_sampleRate    = std::max(8000U, std::min(192000U, format.m_sampleRate));
-  format.m_frames        = format.m_sampleRate * AUDIO_PLAYBUFFER / NUM_OMX_BUFFERS;
+  format.m_frames        = format.m_sampleRate * m_latency / NUM_OMX_BUFFERS;
   format.m_frameSamples  = format.m_frames * channels;
 
   SetAudioProps(m_passthrough, GetChannelMap(format.m_channelLayout, m_passthrough));
@@ -427,7 +430,7 @@ void CAESinkPi::GetDelay(AEDelayStatus& status)
 
 double CAESinkPi::GetCacheTotal()
 {
-  return AUDIO_PLAYBUFFER;
+  return m_latency;
 }
 
 unsigned int CAESinkPi::AddPackets(uint8_t **data, unsigned int frames, unsigned int offset)
@@ -478,8 +481,8 @@ unsigned int CAESinkPi::AddPackets(uint8_t **data, unsigned int frames, unsigned
   m_submitted++;
   GetDelay(status);
   delay = status.GetDelay();
-  if (delay > AUDIO_PLAYBUFFER)
-    Sleep((int)(1000.0f * (delay - AUDIO_PLAYBUFFER)));
+  if (delay > m_latency)
+    Sleep((int)(1000.0f * (delay - m_latency)));
   return frames;
 }
 
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkPi.h b/xbmc/cores/AudioEngine/Sinks/AESinkPi.h
index 55ae1b4..10b0ec6 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkPi.h
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkPi.h
@@ -53,6 +53,7 @@ class CAESinkPi : public IAESink
   AEAudioFormat        m_initFormat;
   AEAudioFormat        m_format;
   double               m_sinkbuffer_sec_per_byte;
+  double               m_latency;
   static CAEDeviceInfo m_info;
   bool                 m_Initialized;
   uint32_t             m_submitted;

From 3a60bf2bb5ce7d064c719ec96d385cf8167a7b04 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 11 Dec 2014 17:00:57 +0000
Subject: [PATCH 44/89] Fix for UI not showing both extractflags and
 extractthumb

---
 addons/resource.language.en_gb/resources/strings.po | 11 ++++++++---
 system/settings/rbp.xml                             |  4 ----
 system/settings/settings.xml                        | 10 +++++-----
 3 files changed, 13 insertions(+), 12 deletions(-)

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index 37932be..647befc 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -10979,7 +10979,7 @@ msgstr ""
 
 #: system/settings/settings.xml
 msgctxt "#20433"
-msgid "Extract thumbnails and video information"
+msgid "Extract video information from files"
 msgstr ""
 
 #: xbmc/dialogs/GUIDialogSmartPlaylistRule.cpp
@@ -14509,7 +14509,7 @@ msgstr ""
 #. Description of setting "Videos -> File lists -> Extract thumbnails and video information" with label #20433
 #: system/settings/settings.xml
 msgctxt "#36178"
-msgid "Extract thumbnails and metadata information such as codec and aspect ratio from videos."
+msgid "Extract metadata information such as codec and aspect ratio from videos."
 msgstr ""
 
 #. Description of setting "Videos -> File lists -> Replace file names with library titles" with label #20419
@@ -14521,7 +14521,7 @@ msgstr ""
 #. Description of setting "Videos -> File lists -> Extract thumbnails and video information" with label #20433
 #: system/settings/settings.xml
 msgctxt "#36180"
-msgid "Extract thumbnails and information, such as codecs and aspect ratio, to display in Library Mode."
+msgid "Extract thumbnails, to display in Library Mode."
 msgstr ""
 
 #: system/settings/settings.xml
@@ -16654,3 +16654,8 @@ msgstr ""
 msgctxt "#38102"
 msgid "%i ms"
 msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#38103"
+msgid "Extract thumbnails from video files"
+msgstr ""
diff --git a/system/settings/rbp.xml b/system/settings/rbp.xml
index 5068b20..6e9ceaf 100644
--- a/system/settings/rbp.xml
+++ b/system/settings/rbp.xml
@@ -36,10 +36,6 @@
         <setting id="myvideos.extractchapterthumbs">
           <default>false</default>
         </setting>
-      </group>
-    </category>
-    <category id="myvideos">
-      <group id="1">
         <setting id="myvideos.extractflags">
           <default>false</default>
         </setting>
diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index ede89e4..f3022c3 100644
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -902,23 +902,23 @@
           </constraints>
           <control type="list" format="string" />
         </setting>
-        <setting id="myvideos.extractflags" type="boolean" label="20433" help="36178">
+        <setting id="myvideos.extractchapterthumbs" type="boolean" label="37044" help="37045">
           <level>1</level>
           <default>true</default>
           <control type="toggle" />
         </setting>
-        <setting id="myvideos.extractchapterthumbs" type="boolean" label="37044" help="37045">
+        <setting id="myvideos.extractflags" type="boolean" label="20433" help="36178">
           <level>1</level>
           <default>true</default>
           <control type="toggle" />
         </setting>
-        <setting id="myvideos.replacelabels" type="boolean" label="20419" help="36179">
+        <setting id="myvideos.extractthumb" type="boolean" label="38103" help="36180">
           <level>1</level>
           <default>true</default>
           <control type="toggle" />
         </setting>
-        <setting id="myvideos.extractthumb" type="boolean" label="20433" help="36180">
-          <level>4</level>
+        <setting id="myvideos.replacelabels" type="boolean" label="20419" help="36179">
+          <level>1</level>
           <default>true</default>
           <control type="toggle" />
         </setting>

From 85c30bde9f23146c332ffeaeecf2c0de5b784900 Mon Sep 17 00:00:00 2001
From: anaconda <anaconda@menakite.eu>
Date: Thu, 11 Sep 2014 21:30:43 +0200
Subject: [PATCH 45/89] Disable autoscrolling while on screensaver and while
 opening streams.

---
 xbmc/Application.cpp                | 10 ++++++++++
 xbmc/Application.h                  |  2 ++
 xbmc/guilib/GUIFadeLabelControl.cpp |  4 +++-
 xbmc/guilib/GUIFont.cpp             |  4 ++++
 xbmc/guilib/GUILabel.cpp            |  4 +++-
 xbmc/guilib/GUITextBox.cpp          |  3 ++-
 6 files changed, 24 insertions(+), 3 deletions(-)

diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index df6e8ca..5889613 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -4959,3 +4959,13 @@ bool CApplication::NotifyActionListeners(const CAction &action) const
   
   return false;
 }
+
+bool CApplication::ScreenSaverDisablesAutoScrolling()
+{
+  bool onBlackDimScreenSaver = IsInScreenSaver() && m_screenSaver &&
+    (m_screenSaver->ID() == "screensaver.xbmc.builtin.black" ||
+     m_screenSaver->ID() == "screensaver.xbmc.builtin.dim");
+  bool openingStreams = m_pPlayer->IsPlaying() && g_windowManager.IsWindowActive(WINDOW_DIALOG_BUSY);
+
+  return onBlackDimScreenSaver || openingStreams;
+}
diff --git a/xbmc/Application.h b/xbmc/Application.h
index b4da8f2..cc064c3 100644
--- a/xbmc/Application.h
+++ b/xbmc/Application.h
@@ -389,6 +389,8 @@ class CApplication : public CXBApplicationEx, public IPlayerCallback, public IMs
    */
   void UnregisterActionListener(IActionListener *listener);
 
+  bool ScreenSaverDisablesAutoScrolling();
+
 protected:
   virtual bool OnSettingsSaving() const;
 
diff --git a/xbmc/guilib/GUIFadeLabelControl.cpp b/xbmc/guilib/GUIFadeLabelControl.cpp
index 9eadbe4..b2b5f13 100644
--- a/xbmc/guilib/GUIFadeLabelControl.cpp
+++ b/xbmc/guilib/GUIFadeLabelControl.cpp
@@ -20,6 +20,8 @@
 
 #include "GUIFadeLabelControl.h"
 
+#include "Application.h"
+
 using namespace std;
 
 CGUIFadeLabelControl::CGUIFadeLabelControl(int parentID, int controlID, float posX, float posY, float width, float height, const CLabelInfo& labelInfo, bool scrollOut, unsigned int timeToDelayAtEnd, bool resetOnLabelChange)
@@ -102,7 +104,7 @@ void CGUIFadeLabelControl::Process(unsigned int currentTime, CDirtyRegionList &d
     m_lastLabel = m_currentLabel;
   }
 
-  if (m_infoLabels.size() > 1 || !m_shortText)
+  if ((m_infoLabels.size() > 1 || !m_shortText) && !g_application.ScreenSaverDisablesAutoScrolling())
   { // have scrolling text
     MarkDirtyRegion();
 
diff --git a/xbmc/guilib/GUIFont.cpp b/xbmc/guilib/GUIFont.cpp
index 7f11089..1192b74 100644
--- a/xbmc/guilib/GUIFont.cpp
+++ b/xbmc/guilib/GUIFont.cpp
@@ -22,6 +22,7 @@
 #include "GUIFontTTF.h"
 #include "GraphicContext.h"
 
+#include "Application.h"
 #include "threads/SingleLock.h"
 #include "utils/TimeUtils.h"
 #include "utils/MathUtils.h"
@@ -128,6 +129,9 @@ bool CGUIFont::UpdateScrollInfo(const vecText &text, CScrollInfo &scrollInfo)
   //   If the string is smaller than the viewport, then it may be plotted even
   //   more times than that.
   //
+  if (g_application.ScreenSaverDisablesAutoScrolling())
+    return false;
+
   if (scrollInfo.waitTime)
   {
     scrollInfo.waitTime--;
diff --git a/xbmc/guilib/GUILabel.cpp b/xbmc/guilib/GUILabel.cpp
index 759ac09..bed6ad2 100644
--- a/xbmc/guilib/GUILabel.cpp
+++ b/xbmc/guilib/GUILabel.cpp
@@ -21,6 +21,8 @@
 #include "GUILabel.h"
 #include <limits>
 
+#include "Application.h"
+
 CGUILabel::CGUILabel(float posX, float posY, float width, float height, const CLabelInfo& labelInfo, CGUILabel::OVER_FLOW overflow)
     : m_label(labelInfo)
     , m_textLayout(labelInfo.font, overflow == OVER_FLOW_WRAP, height)
@@ -104,7 +106,7 @@ void CGUILabel::Render()
   color_t color = GetColor();
   bool renderSolid = (m_color == COLOR_DISABLED);
   bool overFlows = (m_renderRect.Width() + 0.5f < m_textLayout.GetTextWidth()); // 0.5f to deal with floating point rounding issues
-  if (overFlows && m_scrolling && !renderSolid)
+  if (overFlows && m_scrolling && !renderSolid && !g_application.ScreenSaverDisablesAutoScrolling())
     m_textLayout.RenderScrolling(m_renderRect.x1, m_renderRect.y1, m_label.angle, color, m_label.shadowColor, 0, m_renderRect.Width(), m_scrollInfo);
   else
   {
diff --git a/xbmc/guilib/GUITextBox.cpp b/xbmc/guilib/GUITextBox.cpp
index 0d5b3f7..6d23024 100644
--- a/xbmc/guilib/GUITextBox.cpp
+++ b/xbmc/guilib/GUITextBox.cpp
@@ -23,6 +23,7 @@
 #include "utils/XBMCTinyXML.h"
 #include "utils/MathUtils.h"
 #include "utils/StringUtils.h"
+#include "Application.h"
 
 #include <algorithm>
 
@@ -134,7 +135,7 @@ void CGUITextBox::Process(unsigned int currentTime, CDirtyRegionList &dirtyregio
   // update our auto-scrolling as necessary
   if (m_autoScrollTime && m_lines.size() > m_itemsPerPage)
   {
-    if (!m_autoScrollCondition || m_autoScrollCondition->Get())
+    if ((!m_autoScrollCondition || m_autoScrollCondition->Get()) && !g_application.ScreenSaverDisablesAutoScrolling())
     {
       if (m_lastRenderTime)
         m_autoScrollDelayTime += currentTime - m_lastRenderTime;

From 67692cfba74ca0e49e21c805c503605501fb5de2 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 13 Dec 2014 18:35:20 +0000
Subject: [PATCH 46/89] [demuxer] Avoid memcpy on every demuxer packet

Avoids an unnecessary memcpy on every demuxer packet which for
high bitrate videos can be significant.
---
 xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp | 14 +++++++++-----
 xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPacket.h   |  3 +++
 xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.cpp  |  7 ++++++-
 3 files changed, 18 insertions(+), 6 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
index 643c219..2f70412 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
@@ -742,7 +742,7 @@ DemuxPacket* CDVDDemuxFFmpeg::Read()
           {
             if(m_pkt.pkt.stream_index == (int)m_pFormatContext->programs[m_program]->stream_index[i])
             {
-              pPacket = CDVDDemuxUtils::AllocateDemuxPacket(m_pkt.pkt.size);
+              pPacket = CDVDDemuxUtils::AllocateDemuxPacket(0);
               break;
             }
           }
@@ -751,7 +751,7 @@ DemuxPacket* CDVDDemuxFFmpeg::Read()
             bReturnEmpty = true;
         }
         else
-          pPacket = CDVDDemuxUtils::AllocateDemuxPacket(m_pkt.pkt.size);
+          pPacket = CDVDDemuxUtils::AllocateDemuxPacket(0);
       }
       else
         bReturnEmpty = true;
@@ -793,9 +793,13 @@ DemuxPacket* CDVDDemuxFFmpeg::Read()
         // copy contents into our own packet
         pPacket->iSize = m_pkt.pkt.size;
 
-        // maybe we can avoid a memcpy here by detecting where pkt.destruct is pointing too?
         if (m_pkt.pkt.data)
-          memcpy(pPacket->pData, m_pkt.pkt.data, pPacket->iSize);
+        {
+          pPacket->pData = m_pkt.pkt.data;
+          // so we can free AVPacket when DemuxPacket is freed
+          pPacket->pkt = new AVPacket(m_pkt.pkt);
+        }
+
 
         pPacket->pts = ConvertTimestamp(m_pkt.pkt.pts, stream->time_base.den, stream->time_base.num);
         pPacket->dts = ConvertTimestamp(m_pkt.pkt.dts, stream->time_base.den, stream->time_base.num);
@@ -830,7 +834,7 @@ DemuxPacket* CDVDDemuxFFmpeg::Read()
         pPacket->iStreamId = m_pkt.pkt.stream_index;
       }
       m_pkt.result = -1;
-      av_free_packet(&m_pkt.pkt);
+      memset(&m_pkt.pkt, 0, sizeof(AVPacket));
     }
   }
   } // end of lock scope
diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPacket.h b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPacket.h
index d64fbb3..012a7d1 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPacket.h
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPacket.h
@@ -23,6 +23,8 @@
 #define DMX_SPECIALID_STREAMINFO    -10
 #define DMX_SPECIALID_STREAMCHANGE  -11
 
+struct AVPacket;
+
  typedef struct DemuxPacket
 {
   unsigned char* pData;   // data
@@ -33,4 +35,5 @@
   double pts; // pts in DVD_TIME_BASE
   double dts; // dts in DVD_TIME_BASE
   double duration; // duration in DVD_TIME_BASE if available
+  AVPacket *pkt; // to allow packet to be freed
 } DemuxPacket;
diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.cpp
index ab298b2..10c5ee0 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.cpp
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.cpp
@@ -34,7 +34,12 @@ void CDVDDemuxUtils::FreeDemuxPacket(DemuxPacket* pPacket)
   if (pPacket)
   {
     try {
-      if (pPacket->pData) _aligned_free(pPacket->pData);
+      if (pPacket->pkt)
+      {
+        av_free_packet(pPacket->pkt);
+        delete pPacket->pkt;
+      }
+      else if (pPacket->pData) _aligned_free(pPacket->pData);
       delete pPacket;
     }
     catch(...) {

From 32561c3475489b45a10a23b1f00896759a4a8e35 Mon Sep 17 00:00:00 2001
From: Memphiz <memphis@machzwo.de>
Date: Tue, 18 Nov 2014 13:27:59 +0100
Subject: [PATCH 47/89] - added setting for allowing to hide watched
 movies/episodes/musicvideos in the recently added lists of the home screen

---
 addons/resource.language.en_gb/resources/strings.po | 16 ++++++++++++++--
 system/settings/settings.xml                        |  5 +++++
 2 files changed, 19 insertions(+), 2 deletions(-)

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index 647befc..bf466b0 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -11148,7 +11148,13 @@ msgctxt "#20469"
 msgid "Keep current set (%s)"
 msgstr ""
 
-#empty strings from id 20470 to 21329
+#. Label of setting "Videos -> Library -> Hide watched videos in recently added list (home screen)"
+#: system/settings/settings.xml
+msgctxt "#20470"
+msgid "Hide watched videos in recently added list (home screen)"
+msgstr ""
+
+#empty strings from id 20471 to 21329
 #up to 21329 is reserved for the video db !! !
 
 #: system/settings/settings.xml
@@ -15966,7 +15972,13 @@ msgctxt "#36435"
 msgid "Use DVDPlayer for decoding of video files with MMAL acceleration."
 msgstr ""
 
-#empty strings from id 36436 to 36499
+#. Description of setting "Videos -> Library -> Hide watched videos in recently added list."
+#: system/settings/settings.xml
+msgctxt "#36436"
+msgid "If enabled all watched items in the recently added list on the home screen will be hidden. This includes movies, episodes and musicvideos. The effect depends on the used skin and its settings."
+msgstr ""
+
+#empty strings from id 36437 to 36499
 #end reservation
 
 #. label of a setting for the stereoscopic 3D mode of the GUI that is/should be applied
diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index f3022c3..823f181 100644
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -468,6 +468,11 @@
           <default>false</default>
           <control type="toggle" />
         </setting>
+        <setting id="videolibrary.hiderecentlywatchedvideos" type="boolean" label="20470" help="36436">
+          <level>1</level>
+          <default>true</default>
+          <control type="toggle" />
+        </setting>
       </group>
       <group id="2">
         <setting id="videolibrary.updateonstartup" type="boolean" label="22000" help="36146">

From 299f258f82d0bf10105053affec0d811bfa20002 Mon Sep 17 00:00:00 2001
From: Memphiz <memphis@machzwo.de>
Date: Tue, 18 Nov 2014 13:28:36 +0100
Subject: [PATCH 48/89] - evaluate the setting for hiding watched
 movies/episodes/musicvideos in recently added job (should influence
 homescreen of skins only)

---
 xbmc/utils/RecentlyAddedJob.cpp | 10 +++++-----
 xbmc/video/VideoDatabase.cpp    | 27 ++++++++++++++++++++++++---
 xbmc/video/VideoDatabase.h      |  6 +++---
 3 files changed, 32 insertions(+), 11 deletions(-)

diff --git a/xbmc/utils/RecentlyAddedJob.cpp b/xbmc/utils/RecentlyAddedJob.cpp
index 1f8ec36..de45783 100644
--- a/xbmc/utils/RecentlyAddedJob.cpp
+++ b/xbmc/utils/RecentlyAddedJob.cpp
@@ -31,6 +31,7 @@
 #include "utils/Variant.h"
 #include "utils/StringUtils.h"
 #include "settings/AdvancedSettings.h"
+#include "settings/Settings.h"
 #include "music/MusicThumbLoader.h"
 #include "video/VideoThumbLoader.h"
 
@@ -57,8 +58,8 @@ bool CRecentlyAddedJob::UpdateVideo()
   loader.OnLoaderStart();
   
   videodatabase.Open();
-
-  if (videodatabase.GetRecentlyAddedMoviesNav("videodb://recentlyaddedmovies/", items, NUM_ITEMS))
+  bool hideWatched = CSettings::Get().GetBool("videolibrary.hiderecentlywatchedvideos");
+  if (videodatabase.GetRecentlyAddedMoviesNav("videodb://recentlyaddedmovies/", items, NUM_ITEMS, hideWatched))
   {  
     for (; i < items.Size(); ++i)
     {
@@ -97,8 +98,7 @@ bool CRecentlyAddedJob::UpdateVideo()
  
   i = 0;
   CFileItemList  TVShowItems; 
- 
-  if (videodatabase.GetRecentlyAddedEpisodesNav("videodb://recentlyaddedepisodes/", TVShowItems, NUM_ITEMS))
+  if (videodatabase.GetRecentlyAddedEpisodesNav("videodb://recentlyaddedepisodes/", TVShowItems, NUM_ITEMS, hideWatched))
   {
     for (; i < TVShowItems.Size(); ++i)
     {    
@@ -151,7 +151,7 @@ bool CRecentlyAddedJob::UpdateVideo()
   i = 0;
   CFileItemList MusicVideoItems;
 
-  if (videodatabase.GetRecentlyAddedMusicVideosNav("videodb://recentlyaddedmusicvideos/", MusicVideoItems, NUM_ITEMS))
+  if (videodatabase.GetRecentlyAddedMusicVideosNav("videodb://recentlyaddedmusicvideos/", MusicVideoItems, NUM_ITEMS, hideWatched))
   {
     for (; i < MusicVideoItems.Size(); ++i)
     {
diff --git a/xbmc/video/VideoDatabase.cpp b/xbmc/video/VideoDatabase.cpp
index 89fbfcc..aa370af 100644
--- a/xbmc/video/VideoDatabase.cpp
+++ b/xbmc/video/VideoDatabase.cpp
@@ -6552,27 +6552,48 @@ bool CVideoDatabase::GetMusicVideosNav(const std::string& strBaseDir, CFileItemL
   return GetMusicVideosByWhere(videoUrl.ToString(), filter, items, true, sortDescription);
 }
 
-bool CVideoDatabase::GetRecentlyAddedMoviesNav(const std::string& strBaseDir, CFileItemList& items, unsigned int limit)
+bool CVideoDatabase::GetRecentlyAddedMoviesNav(const std::string& strBaseDir, CFileItemList& items, unsigned int limit, bool hideWatched)
 {
   Filter filter;
   filter.order = "dateAdded desc, idMovie desc";
   filter.limit = PrepareSQL("%u", limit ? limit : g_advancedSettings.m_iVideoLibraryRecentlyAddedItems);
+
+  if (hideWatched)
+  {
+    filter.AppendWhere("playCount <= 0");// only query unwatched items
+    filter.AppendWhere("playCount IS NULL", false);
+  }
+
   return GetMoviesByWhere(strBaseDir, filter, items);
 }
 
-bool CVideoDatabase::GetRecentlyAddedEpisodesNav(const std::string& strBaseDir, CFileItemList& items, unsigned int limit)
+bool CVideoDatabase::GetRecentlyAddedEpisodesNav(const std::string& strBaseDir, CFileItemList& items, unsigned int limit, bool hideWatched)
 {
   Filter filter;
   filter.order = "dateAdded desc, idEpisode desc";
   filter.limit = PrepareSQL("%u", limit ? limit : g_advancedSettings.m_iVideoLibraryRecentlyAddedItems);
+
+  if (hideWatched)
+  {
+    filter.AppendWhere("playCount <= 0");// only query unwatched items
+    filter.AppendWhere("playCount IS NULL", false);
+  }
+
   return GetEpisodesByWhere(strBaseDir, filter, items, false);
 }
 
-bool CVideoDatabase::GetRecentlyAddedMusicVideosNav(const std::string& strBaseDir, CFileItemList& items, unsigned int limit)
+bool CVideoDatabase::GetRecentlyAddedMusicVideosNav(const std::string& strBaseDir, CFileItemList& items, unsigned int limit, bool hideWatched)
 {
   Filter filter;
   filter.order = "dateAdded desc, idMVideo desc";
   filter.limit = PrepareSQL("%u", limit ? limit : g_advancedSettings.m_iVideoLibraryRecentlyAddedItems);
+
+  if (hideWatched)
+  {
+    filter.AppendWhere("playCount <= 0");// only query unwatched items
+    filter.AppendWhere("playCount IS NULL", false);
+  }
+
   return GetMusicVideosByWhere(strBaseDir, filter, items);
 }
 
diff --git a/xbmc/video/VideoDatabase.h b/xbmc/video/VideoDatabase.h
index ca62f23..b905e48 100644
--- a/xbmc/video/VideoDatabase.h
+++ b/xbmc/video/VideoDatabase.h
@@ -683,9 +683,9 @@ class CVideoDatabase : public CDatabase
   bool GetEpisodesNav(const std::string& strBaseDir, CFileItemList& items, int idGenre=-1, int idYear=-1, int idActor=-1, int idDirector=-1, int idShow=-1, int idSeason=-1, const SortDescription &sortDescription = SortDescription());
   bool GetMusicVideosNav(const std::string& strBaseDir, CFileItemList& items, int idGenre=-1, int idYear=-1, int idArtist=-1, int idDirector=-1, int idStudio=-1, int idAlbum=-1, int idTag=-1, const SortDescription &sortDescription = SortDescription());
   
-  bool GetRecentlyAddedMoviesNav(const std::string& strBaseDir, CFileItemList& items, unsigned int limit=0);
-  bool GetRecentlyAddedEpisodesNav(const std::string& strBaseDir, CFileItemList& items, unsigned int limit=0);
-  bool GetRecentlyAddedMusicVideosNav(const std::string& strBaseDir, CFileItemList& items, unsigned int limit=0);
+  bool GetRecentlyAddedMoviesNav(const std::string& strBaseDir, CFileItemList& items, unsigned int limit=0, bool hideWatched=false);
+  bool GetRecentlyAddedEpisodesNav(const std::string& strBaseDir, CFileItemList& items, unsigned int limit=0, bool hideWatched=false);
+  bool GetRecentlyAddedMusicVideosNav(const std::string& strBaseDir, CFileItemList& items, unsigned int limit=0, bool hideWatched=false);
 
   bool HasContent();
   bool HasContent(VIDEODB_CONTENT_TYPE type);

From 2373aa7571337304e255fe7039fbd49fcfa3a4f9 Mon Sep 17 00:00:00 2001
From: fritsch <peter.fruehberger@gmail.com>
Date: Wed, 4 Feb 2015 22:32:03 +0100
Subject: [PATCH 49/89] NFSFile: Chank ChunkSize to 1MB

---
 xbmc/filesystem/NFSFile.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/filesystem/NFSFile.h b/xbmc/filesystem/NFSFile.h
index 4c01e4e..7afa6b8 100644
--- a/xbmc/filesystem/NFSFile.h
+++ b/xbmc/filesystem/NFSFile.h
@@ -148,7 +148,7 @@ namespace XFILE
     //implement iocontrol for seek_possible for preventing the stat in File class for
     //getting this info ...
     virtual int IoControl(EIoControl request, void* param){ if(request == IOCTRL_SEEK_POSSIBLE) return 1;return -1;};    
-    virtual int  GetChunkSize() {return 1;}
+    virtual int  GetChunkSize() {return 1024*1024;}
     
     virtual bool OpenForWrite(const CURL& url, bool bOverWrite = false);
     virtual bool Delete(const CURL& url);

From 2862d65f247cbff597c3a4f2a54342ae9e653e11 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 10 Feb 2015 00:19:51 +0000
Subject: [PATCH 52/89] [libnfs] Add streaming cache

---
 .../libnfs/0001-Sequential-Readahead-Mode.patch    | 949 +++++++++++++++++++++
 tools/depends/target/libnfs/Makefile               |   1 +
 xbmc/filesystem/DllLibNfs.h                        |   3 +
 xbmc/filesystem/NFSFile.cpp                        |   2 +
 4 files changed, 955 insertions(+)
 create mode 100644 tools/depends/target/libnfs/0001-Sequential-Readahead-Mode.patch

diff --git a/tools/depends/target/libnfs/0001-Sequential-Readahead-Mode.patch b/tools/depends/target/libnfs/0001-Sequential-Readahead-Mode.patch
new file mode 100644
index 0000000..83b7e11
--- /dev/null
+++ b/tools/depends/target/libnfs/0001-Sequential-Readahead-Mode.patch
@@ -0,0 +1,949 @@
+From ae7ef01ad15ea91f669a59d4fd44aa9c03a3a6fb Mon Sep 17 00:00:00 2001
+From: Ronnie Sahlberg <ronniesahlberg@gmail.com>
+Date: Sat, 7 Feb 2015 11:16:38 -0800
+Subject: [PATCH 1/7] Sequential Readahead Mode
+
+Add a new api to activate sequential reading of files.
+It is activated by calling nfs_set_streaming_mode(fs,size)
+with a filehandle and a size.
+
+Signed-off-by: Ronnie Sahlberg <ronniesahlberg@gmail.com>
+---
+ include/nfsc/libnfs-raw.h |   9 ++
+ include/nfsc/libnfs.h     |  14 +++
+ lib/libnfs-sync.c         |  12 ++-
+ lib/libnfs-win32.def      |   5 +
+ lib/libnfs.c              | 258 +++++++++++++++++++++++++++++++++++++++++++++-
+ lib/socket.c              |  15 ++-
+ 6 files changed, 308 insertions(+), 5 deletions(-)
+
+diff --git a/include/nfsc/libnfs-raw.h b/include/nfsc/libnfs-raw.h
+index 3ba9de3..4593cc6 100644
+--- a/include/nfsc/libnfs-raw.h
++++ b/include/nfsc/libnfs-raw.h
+@@ -44,6 +44,15 @@ int rpc_get_fd(struct rpc_context *rpc);
+ int rpc_which_events(struct rpc_context *rpc);
+ int rpc_service(struct rpc_context *rpc, int revents);
+ char *rpc_get_error(struct rpc_context *rpc);
++
++/* Return the number of PDUs in the outqueue.
++ * This is the count of PDUs not yet written to the socket.
++ */
++int rpc_outqueue_length(struct rpc_context *rpc);
++/* Return the number all in flight PDUs.
++ * This includes both the PDUs not yet written to the socket as well as
++ * all PDUs we have sent to the server but not yet received a reply to.
++ */
+ int rpc_queue_length(struct rpc_context *rpc);
+
+ /* Utility function to get an RPC context from a NFS context. Useful for doing low level NFSACL
+diff --git a/include/nfsc/libnfs.h b/include/nfsc/libnfs.h
+index 2d14113..f84650b 100644
+--- a/include/nfsc/libnfs.h
++++ b/include/nfsc/libnfs.h
+@@ -83,6 +83,15 @@ struct utimbuf {
+ EXTERN int nfs_get_fd(struct nfs_context *nfs);
+ EXTERN int nfs_which_events(struct nfs_context *nfs);
+ EXTERN int nfs_service(struct nfs_context *nfs, int revents);
++
++/* Return the number of PDUs in the outqueue.
++ * This is the count of PDUs not yet written to the socket.
++ */
++EXTERN int nfs_outqueue_length(struct nfs_context *nfs);
++/* Return the number all in flight PDUs.
++ * This includes both the PDUs not yet written to the socket as well as
++ * all PDUs we have sent to the server but not yet received a reply to.
++ */
+ EXTERN int nfs_queue_length(struct nfs_context *nfs);
+
+ /*
+@@ -191,6 +200,11 @@ EXTERN void nfs_set_uid(struct nfs_context *nfs, int uid);
+ EXTERN void nfs_set_gid(struct nfs_context *nfs, int gid);
+ EXTERN void nfs_set_readahead(struct nfs_context *nfs, uint32_t v);
+
++/* Optimize for sequentianl streaming reads. size is the amount
++ * of buffering.
++ */
++EXTERN int nfs_set_streaming_mode(struct nfsfh *nfsfh, uint32_t size);
++
+ /*
+  * MOUNT THE EXPORT
+  */
+diff --git a/lib/libnfs-sync.c b/lib/libnfs-sync.c
+index 59911fc..dc696c3 100644
+--- a/lib/libnfs-sync.c
++++ b/lib/libnfs-sync.c
+@@ -137,9 +137,14 @@ static void wait_for_reply(struct rpc_context *rpc, struct sync_cb_data *cb_data
+ static void wait_for_nfs_reply(struct nfs_context *nfs, struct sync_cb_data *cb_data)
+ {
+	struct pollfd pfd;
+-
+-	while (!cb_data->is_finished) {
+-
++	int available;
++
++	/* loop until the command has completed, and we have written all
++	 * queued PDUs to the socket, and we have read and processed all
++	 * data in the socket receive buffer.
++	 */
++	ioctl(nfs_get_fd(nfs), FIONREAD, &available);
++	while (!cb_data->is_finished || nfs_outqueue_length(nfs) || available) {
+		pfd.fd = nfs_get_fd(nfs);
+		pfd.events = nfs_which_events(nfs);
+		if (poll(&pfd, 1, -1) < 0) {
+@@ -152,6 +157,7 @@ static void wait_for_nfs_reply(struct nfs_context *nfs, struct sync_cb_data *cb_
+			cb_data->status = -EIO;
+			break;
+		}
++		ioctl(nfs_get_fd(nfs), FIONREAD, &available);
+	}
+ }
+
+diff --git a/lib/libnfs-win32.def b/lib/libnfs-win32.def
+index 5a0df03..bdfa737 100644
+--- a/lib/libnfs-win32.def
++++ b/lib/libnfs-win32.def
+@@ -48,6 +48,7 @@ nfs_open
+ nfs_open_async
+ nfs_opendir
+ nfs_opendir_async
++nfs_outqueue_length
+ nfs_parse_url_full
+ nfs_parse_url_dir
+ nfs_parse_url_incomplete
+@@ -56,6 +57,7 @@ nfs_pread
+ nfs_pread_async
+ nfs_pwrite
+ nfs_pwrite_async
++nfs_queue_length
+ nfs_read
+ nfs_read_async
+ nfs_readdir
+@@ -71,6 +73,7 @@ nfs_set_gid
+ nfs_set_tcp_syncnt
+ nfs_set_uid
+ nfs_set_readahead
++nfs_set_streaming_mode
+ nfs_stat
+ nfs_stat_async
+ nfs_stat64
+@@ -205,6 +208,8 @@ rpc_nsm1_unmon_async
+ rpc_nsm1_unmonall_async
+ rpc_nsm1_simucrash_async
+ rpc_nsm1_notify_async
++rpc_outqueue_length
++rpc_queue_length
+ rpc_rquota1_null_async
+ rpc_rquota1_getquota_async
+ rpc_rquota1_getactivequota_async
+diff --git a/lib/libnfs.c b/lib/libnfs.c
+index f807822..5fc921d 100644
+--- a/lib/libnfs.c
++++ b/lib/libnfs.c
+@@ -108,12 +108,37 @@ struct nfs_readahead {
+        uint32_t cur_ra;
+ };
+
++/* Store streaming cache in blocks of this size */
++#define NFS_STREAM_BUF_SIZE (32768 * 4)
++/* Skip trying to streaming caching for reads greater than this */
++#define NFS_MAX_STREAMING_SIZE (1024 * 1024)
++
++#define BSS_UNUSED  0
++#define BSS_PENDING 1
++#define BSS_VALID   2
++struct nfs_streaming_block {
++       int state;
++       unsigned char *ptr;
++};
++
++struct nfs_streaming_read {
++       uint64_t next_offset;
++       int num_seq;
++
++       int num_blocks; /* number of buffer blocks */
++       uint64_t buf_offset;
++       struct nfs_streaming_block *blocks;
++       unsigned char *buf;
++};
++
+ struct nfsfh {
+        struct nfs_fh3 fh;
+        int is_sync;
+        int is_append;
+        uint64_t offset;
+-       struct nfs_readahead ra;
++
++       struct nfs_streaming_read *sr;
++       struct nfs_readahead ra; /* broken? */
+ };
+
+ struct nested_mounts {
+@@ -231,6 +256,11 @@ int nfs_get_fd(struct nfs_context *nfs)
+	return rpc_get_fd(nfs->rpc);
+ }
+
++int nfs_outqueue_length(struct nfs_context *nfs)
++{
++	return rpc_outqueue_length(nfs->rpc);
++}
++
+ int nfs_queue_length(struct nfs_context *nfs)
+ {
+	return rpc_queue_length(nfs->rpc);
+@@ -730,12 +760,52 @@ static void free_nfs_cb_data(struct nfs_cb_data *data)
+	free(data);
+ }
+
++int nfs_set_streaming_mode(struct nfsfh *nfsfh, uint32_t size)
++{
++	struct nfs_streaming_read *sr;
++	int i;
++
++	sr = malloc(sizeof(struct nfs_streaming_read));
++	if (sr == NULL) {
++		return -1;
++	}
++	memset(sr, 0, sizeof(struct nfs_streaming_read));
++	sr->num_blocks = size / NFS_STREAM_BUF_SIZE;
++
++	sr->buf = malloc(sr->num_blocks * NFS_STREAM_BUF_SIZE);
++	if (sr->buf == NULL) {
++		free(sr);
++		return -1;
++	}
++	memset(sr->buf, 0, sr->num_blocks * NFS_STREAM_BUF_SIZE);
++
++	sr->blocks = malloc(sr->num_blocks * sizeof(struct nfs_streaming_block))
++;
++	if (sr->blocks == NULL) {
++		free(sr->buf);
++		free(sr);
++		return -1;
++	}
++	for (i = 0; i < sr->num_blocks; i++) {
++		sr->blocks[i].state = BSS_UNUSED;
++		sr->blocks[i].ptr = &sr->buf[i * NFS_STREAM_BUF_SIZE];
++	}
++	nfsfh->sr = sr;
++
++	return 0;
++}
++
+ static void free_nfsfh(struct nfsfh *nfsfh)
+ {
+	if (nfsfh->fh.data.data_val != NULL) {
+		free(nfsfh->fh.data.data_val);
+		nfsfh->fh.data.data_val = NULL;
+	}
++	if (nfsfh->sr != NULL) {
++		free(nfsfh->sr->blocks);
++		free(nfsfh->sr->buf);
++		free(nfsfh->sr);
++	}
+	free(nfsfh->ra.buf);
+	free(nfsfh);
+ }
+@@ -2033,6 +2103,8 @@ static void nfs_open_cb(struct rpc_context *rpc, int status, void *command_data,
+	nfsfh->fh = data->fh;
+	data->fh.data.data_val = NULL;
+
++	nfs_set_streaming_mode(nfsfh, 200 * NFS_STREAM_BUF_SIZE);
++
+	data->cb(0, nfs, nfsfh, data->private_data);
+	free_nfs_cb_data(data);
+ }
+@@ -2252,10 +2324,194 @@ static void nfs_ra_invalidate(struct nfsfh *nfsfh) {
+	nfsfh->ra.cur_ra = NFS_BLKSIZE;
+ }
+
++struct stream_cb_data {
++       uint64_t offset;
++       struct nfsfh *nfsfh;
++};
++
++static void nfs_stream_cb(struct rpc_context *rpc, int status, void *command_data, void *private_data)
++{
++	struct stream_cb_data *stream_data = private_data;
++	struct nfsfh *nfsfh = stream_data->nfsfh;
++	READ3res *res;
++	int i;
++
++	assert(rpc->magic == RPC_CONTEXT_MAGIC);
++
++	if (stream_data->offset < nfsfh->sr->buf_offset) {
++		free(stream_data);
++		return;
++	}
++	if (stream_data->offset >= nfsfh->sr->buf_offset + nfsfh->sr->num_blocks * NFS_STREAM_BUF_SIZE) {
++		free(stream_data);
++		return;
++	}
++
++	i = (stream_data->offset - nfsfh->sr->buf_offset) / NFS_STREAM_BUF_SIZE;
++	nfsfh->sr->blocks[i].state = BSS_UNUSED;
++	free(stream_data);
++
++	if (status == RPC_STATUS_ERROR) {
++		return;
++	}
++	if (status == RPC_STATUS_CANCEL) {
++		return;
++	}
++	if (status == RPC_STATUS_SUCCESS) {
++		res = command_data;
++		if (res->status != NFS3_OK) {
++			return;
++		}
++		if (res->READ3res_u.resok.count != NFS_STREAM_BUF_SIZE) {
++			return;
++		}
++		memcpy(nfsfh->sr->blocks[i].ptr,
++			res->READ3res_u.resok.data.data_val,
++			NFS_STREAM_BUF_SIZE);
++		nfsfh->sr->blocks[i].state = BSS_VALID;
++	}
++}
++
++static void prefetch_streaming_blocks(struct nfs_context *nfs, struct nfsfh *nfsfh, uint64_t next_offset, int num_blocks)
++{
++	int i;
++
++	for (i = 0; i < nfsfh->sr->num_blocks && num_blocks; i++) {
++		struct stream_cb_data *stream_data;
++		READ3args args;
++
++		if (nfsfh->sr->blocks[i].state != BSS_UNUSED) {
++			continue;
++		}
++
++		stream_data = malloc(sizeof(struct stream_cb_data));
++		if (stream_data == NULL) {
++			return;
++		}
++		stream_data->offset = i * NFS_STREAM_BUF_SIZE + nfsfh->sr->buf_offset;
++		stream_data->nfsfh = nfsfh;
++
++		nfs_fill_READ3args(&args, nfsfh, stream_data->offset, NFS_STREAM_BUF_SIZE);
++		if (rpc_nfs3_read_async(nfs->rpc, nfs_stream_cb, &args, stream_data) != 0) {
++			free(stream_data);
++			return;
++		}
++
++		nfsfh->sr->blocks[i].state = BSS_PENDING;
++		num_blocks--;
++	}
++}
++
+ static int nfs_pread_async_internal(struct nfs_context *nfs, struct nfsfh *nfsfh, uint64_t offset, uint64_t count, nfs_cb cb, void *private_data, int update_pos)
+ {
+	struct nfs_cb_data *data;
+
++	if (nfsfh->sr != NULL && count <= NFS_MAX_STREAMING_SIZE) {
++		int i, len, remaining, first_block, last_block;
++		unsigned char *buf, *pos;
++
++		/* track sequential access */
++		if (offset == nfsfh->sr->next_offset) {
++			nfsfh->sr->num_seq++;
++		} else {
++			if (nfsfh->sr->blocks[0].state != BSS_UNUSED) {
++				for (i = 0; i < nfsfh->sr->num_blocks; i++) {
++					nfsfh->sr->blocks[i].state = BSS_UNUSED;
++				}
++			}
++			nfsfh->sr->num_seq = 0;
++		}
++		nfsfh->sr->next_offset = offset + count;
++
++		if (nfsfh->sr->num_seq < 5) {
++			goto end_of_streaming;
++		}
++
++		/* If we do not have any cached data yet, reset buffer
++		 * offset to point slightly ahead of the current read.
++		 */
++		if (nfsfh->sr->blocks[0].state == BSS_UNUSED) {
++			nfsfh->sr->buf_offset = (offset / NFS_STREAM_BUF_SIZE + 1) * NFS_STREAM_BUF_SIZE ;
++		}
++
++		/* Prune head blocks we have read past */
++		while (nfsfh->sr->blocks[0].state != BSS_UNUSED &&
++			offset >= (nfsfh->sr->buf_offset + NFS_STREAM_BUF_SIZE)) {
++			unsigned char *ptr;
++
++			ptr = nfsfh->sr->blocks[0].ptr;
++			memmove(&nfsfh->sr->blocks[0], &nfsfh->sr->blocks[1],
++				(nfsfh->sr->num_blocks - 1)
++				* sizeof(struct nfs_streaming_block));
++			nfsfh->sr->buf_offset += NFS_STREAM_BUF_SIZE;
++			nfsfh->sr->blocks[nfsfh->sr->num_blocks - 1].state = BSS_UNUSED;
++			nfsfh->sr->blocks[nfsfh->sr->num_blocks - 1].ptr = ptr;
++		}
++
++		/* try to prefetch four more blocks */
++		prefetch_streaming_blocks(nfs, nfsfh, offset + count, 4);
++
++		/* can we service the request straight out of cache ? */
++		if (offset < nfsfh->sr->buf_offset) {
++			goto end_of_streaming;
++		}
++		first_block = (offset - nfsfh->sr->buf_offset) / NFS_STREAM_BUF_SIZE;
++		if (first_block >= nfsfh->sr->num_blocks) {
++			goto end_of_streaming;
++		}
++
++		if (offset + count > nfsfh->sr->buf_offset + nfsfh->sr->num_blocks * NFS_STREAM_BUF_SIZE) {
++			goto end_of_streaming;
++		}
++		last_block = (offset + count - nfsfh->sr->buf_offset - 1) / NFS_STREAM_BUF_SIZE;
++		if (last_block >= nfsfh->sr->num_blocks) {
++			goto end_of_streaming;
++		}
++		if (last_block < first_block) {
++			goto end_of_streaming;
++		}
++		for (i = first_block; i <= last_block; i++) {
++			if (nfsfh->sr->blocks[i].state != BSS_VALID) {
++				goto end_of_streaming;
++			}
++		}
++		if (first_block == last_block) {
++			if (update_pos) {
++				nfsfh->offset += count;
++			}
++			cb(count, nfs, &nfsfh->sr->blocks[first_block].ptr[offset % NFS_STREAM_BUF_SIZE], private_data);
++			return 0;
++		}
++
++		buf = malloc(count);
++		if (buf == NULL) {
++			goto end_of_streaming;
++		}
++		remaining = count;
++		pos = buf;
++		len = NFS_STREAM_BUF_SIZE - offset % NFS_STREAM_BUF_SIZE;
++		if (len > count) {
++			len = count;
++		}
++		memcpy(pos, &nfsfh->sr->blocks[first_block].ptr[offset % NFS_STREAM_BUF_SIZE], len);
++		remaining -= len;
++		pos += len;
++
++		for (i = first_block + 1; remaining; i++) {
++			len = (remaining >= NFS_STREAM_BUF_SIZE) ? NFS_STREAM_BUF_SIZE : remaining;
++			memcpy(pos, &nfsfh->sr->blocks[i].ptr[0], len);
++			remaining -= len;
++			pos += len;
++		}
++		if (update_pos) {
++			nfsfh->offset += count;
++		}
++		cb(count, nfs, buf, private_data);
++		free(buf);
++		return 0;
++	}
++end_of_streaming:
++
+	data = malloc(sizeof(struct nfs_cb_data));
+	if (data == NULL) {
+		rpc_set_error(nfs->rpc, "out of memory: failed to allocate nfs_cb_data structure");
+diff --git a/lib/socket.c b/lib/socket.c
+index 3588246..41fb5b2 100644
+--- a/lib/socket.c
++++ b/lib/socket.c
+@@ -755,7 +755,7 @@ struct sockaddr *rpc_get_recv_sockaddr(struct rpc_context *rpc)
+	return (struct sockaddr *)&rpc->udp_src;
+ }
+
+-int rpc_queue_length(struct rpc_context *rpc)
++int rpc_outqueue_length(struct rpc_context *rpc)
+ {
+	int i=0;
+	struct rpc_pdu *pdu;
+@@ -767,6 +767,19 @@ int rpc_queue_length(struct rpc_context *rpc)
+		i++;
+	}
+
++	return i;
++}
++
++int rpc_queue_length(struct rpc_context *rpc)
++{
++	int i=0;
++	struct rpc_pdu *pdu;
++	unsigned int n;
++
++	assert(rpc->magic == RPC_CONTEXT_MAGIC);
++
++	i = rpc_outqueue_length(rpc);
++
+	for (n = 0; n < HASHES; n++) {
+		struct rpc_queue *q = &rpc->waitpdu[n];
+
+--
+1.9.1
+
+
+From 6f6832b6c19a26557883af924d7135f5ef87f45d Mon Sep 17 00:00:00 2001
+From: Ronnie Sahlberg <ronniesahlberg@gmail.com>
+Date: Sat, 7 Feb 2015 12:43:59 -0800
+Subject: [PATCH 2/7] nfs-stream.c: a simple test tool to check performance
+ sequential read mode
+
+./nfs-stream <mfs-url> <bytes-per-second-to-read>
+
+This tool is for testing sequential read mode.
+It reads 32kbyte one block at a time using the sync API.
+The idea is that when a nfs_[p]read() command is executed, we will once we
+identify a sequential scan start issuing asynchronous commands in the
+background to populate a readahead cache.
+
+During read, we try to service the request immediately out of cache
+and return immediately to the application. During read from cache we will also
+process any to previous reads and use it to populate the cache. Also, as the
+file offset grows, we will discard the already read blocks from the cache
+and issue new asynchronous commands at the tail of the cache.
+
+nfs_read() will when the cache is operating behave like :
+  nfs_read() {
+     ... process any previous reads and populate the cache ...
+     ... send async command to replenish the tail of the cache ...
+     return data from cache straigh back to application
+  }
+
+The test tool will try to read 32kb chunks at a given rate.
+Once the test tool manages to service from cache  the read laency should drop
+to <<1ms and the majority of the time spent will be in the sleep() between calls.
+Once the latency is steady at <<1ms this is an indication that we now
+service all reads out of cache instead of the network.
+If the read latency remains <<1ms continously, without any spikes, it means that
+we have been successfull in maintaining the asycntrhous tasks to replenish the cache.
+
+Signed-off-by: Ronnie Sahlberg <ronniesahlberg@gmail.com>
+---
+ nfs-stream.c | 65 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 65 insertions(+)
+ create mode 100644 nfs-stream.c
+
+diff --git a/nfs-stream.c b/nfs-stream.c
+new file mode 100644
+index 0000000..5570cd6
+--- /dev/null
++++ b/nfs-stream.c
+@@ -0,0 +1,65 @@
++#include <fcntl.h>
++#include <stdio.h>
++#include <stdlib.h>
++#include <sys/stat.h>
++#include <sys/time.h>
++#include <sys/types.h>
++#include <unistd.h>
++#include "nfsc/libnfs.h"
++
++int main(int argc, char *argv[])
++{
++	struct nfs_context *nfs;
++	struct nfs_url *url;
++	struct nfsfh *nfsfh = NULL;
++	struct nfs_stat_64 st;
++	uint64_t offset;
++	char buf[32768];
++	struct timeval t1, t2;
++	uint64_t delta, tpc;
++
++	nfs = nfs_init_context();
++	url = nfs_parse_url_full(nfs, argv[1]);
++	if (!url) {
++		fprintf(stderr, "Can not parse URL. %s\n",
++			nfs_get_error(nfs));
++		exit(1);
++	}
++	if (nfs_mount(nfs, url->server, url->path) != 0) {
++		fprintf(stderr, "Failed to mount nfs share : %s\n",
++			       nfs_get_error(nfs));
++		exit(1);
++	}
++	if (nfs_open(nfs, url->file, O_RDONLY, &nfsfh) != 0) {
++		fprintf(stderr, "Failed to open file %s: %s\n",
++			url->file,
++			nfs_get_error(nfs));
++		exit(1);
++	}
++	if (nfs_fstat64(nfs, nfsfh, &st)) {
++		fprintf(stderr, "Failed to stat file %s: %s\n",
++			url->file,
++			nfs_get_error(nfs));
++		exit(1);
++	}
++	printf("File size:%lld\n", (long long)st.nfs_size);
++	tpc = 1000000 / (strtol(argv[2], NULL, 10) / 32768);
++	printf("Read one 32kb chunk every %d us\n", (int)tpc);
++	for (offset = 0; offset < st.nfs_size; offset += 32768) {
++		gettimeofday(&t1, NULL);
++		nfs_read(nfs, nfsfh, 8192, buf);
++		gettimeofday(&t2, NULL);
++		delta = t2.tv_sec * 1000000LL + t2.tv_usec -
++		  t1.tv_sec * 1000000LL - t1.tv_usec;
++		printf("Read latency:%lld us\n", (long long)delta);
++		if (tpc > delta) {
++			printf("Sleep for %d us\n", (int)(tpc - delta));
++			usleep(tpc - delta);
++		}
++	}
++
++	nfs_close(nfs, nfsfh);
++	nfs_destroy_context(nfs);
++	nfs_destroy_url(url);
++	return 0;
++}
+--
+1.9.1
+
+
+From 225e1c47727871c6ca74d6e3fef79ee6234923a1 Mon Sep 17 00:00:00 2001
+From: Ronnie Sahlberg <ronniesahlberg@gmail.com>
+Date: Sat, 7 Feb 2015 13:31:02 -0800
+Subject: [PATCH 3/7] streaming: only try refilling 2 blocks at a time instead
+ of 4
+
+Signed-off-by: Ronnie Sahlberg <ronniesahlberg@gmail.com>
+---
+ lib/libnfs.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/lib/libnfs.c b/lib/libnfs.c
+index 5fc921d..84e76b6 100644
+--- a/lib/libnfs.c
++++ b/lib/libnfs.c
+@@ -2448,8 +2448,8 @@ static int nfs_pread_async_internal(struct nfs_context *nfs, struct nfsfh *nfsfh
+			nfsfh->sr->blocks[nfsfh->sr->num_blocks - 1].ptr = ptr;
+		}
+
+-		/* try to prefetch four more blocks */
+-		prefetch_streaming_blocks(nfs, nfsfh, offset + count, 4);
++		/* try to prefetch to more blocks */
++		prefetch_streaming_blocks(nfs, nfsfh, offset + count, 2);
+
+		/* can we service the request straight out of cache ? */
+		if (offset < nfsfh->sr->buf_offset) {
+--
+1.9.1
+
+
+From ceb35bb17425dda7408ae43ae80a997f4e1c1f95 Mon Sep 17 00:00:00 2001
+From: Ronnie Sahlberg <ronniesahlberg@gmail.com>
+Date: Sat, 7 Feb 2015 16:19:59 -0800
+Subject: [PATCH 4/7] read 32kb at a time, not 8kb
+
+crapadoodle,  if we measure 32kb blob read speed we should actually read
+a 32kb blob too.   not a 8kb one.
+
+Signed-off-by: Ronnie Sahlberg <ronniesahlberg@gmail.com>
+---
+ nfs-stream.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/nfs-stream.c b/nfs-stream.c
+index 5570cd6..dd01218 100644
+--- a/nfs-stream.c
++++ b/nfs-stream.c
+@@ -47,13 +47,13 @@ int main(int argc, char *argv[])
+	printf("Read one 32kb chunk every %d us\n", (int)tpc);
+	for (offset = 0; offset < st.nfs_size; offset += 32768) {
+		gettimeofday(&t1, NULL);
+-		nfs_read(nfs, nfsfh, 8192, buf);
++		nfs_read(nfs, nfsfh, 32768, buf);
+		gettimeofday(&t2, NULL);
+		delta = t2.tv_sec * 1000000LL + t2.tv_usec -
+		  t1.tv_sec * 1000000LL - t1.tv_usec;
+		printf("Read latency:%lld us\n", (long long)delta);
+		if (tpc > delta) {
+-			printf("Sleep for %d us\n", (int)(tpc - delta));
++			//printf("Sleep for %d us\n", (int)(tpc - delta));
+			usleep(tpc - delta);
+		}
+	}
+--
+1.9.1
+
+
+From 5f5faa8cfb86057081ccb3e30f987ecdec40fa13 Mon Sep 17 00:00:00 2001
+From: Ronnie Sahlberg <ronniesahlberg@gmail.com>
+Date: Mon, 9 Feb 2015 20:46:25 -0800
+Subject: [PATCH 5/7] prefetch: limit the amount of prefetches we have in
+ flight to 2
+
+Signed-off-by: Ronnie Sahlberg <ronniesahlberg@gmail.com>
+---
+ lib/libnfs.c | 16 +++++++++++++---
+ nfs-stream.c |  7 +++++++
+ 2 files changed, 20 insertions(+), 3 deletions(-)
+
+diff --git a/lib/libnfs.c b/lib/libnfs.c
+index 84e76b6..929d3e0 100644
+--- a/lib/libnfs.c
++++ b/lib/libnfs.c
+@@ -2103,8 +2103,6 @@ static void nfs_open_cb(struct rpc_context *rpc, int status, void *command_data,
+	nfsfh->fh = data->fh;
+	data->fh.data.data_val = NULL;
+
+-	nfs_set_streaming_mode(nfsfh, 200 * NFS_STREAM_BUF_SIZE);
+-
+	data->cb(0, nfs, nfsfh, data->private_data);
+	free_nfs_cb_data(data);
+ }
+@@ -2374,12 +2372,24 @@ static void nfs_stream_cb(struct rpc_context *rpc, int status, void *command_dat
+
+ static void prefetch_streaming_blocks(struct nfs_context *nfs, struct nfsfh *nfsfh, uint64_t next_offset, int num_blocks)
+ {
+-	int i;
++	int i, num_pending = 0;
+
+	for (i = 0; i < nfsfh->sr->num_blocks && num_blocks; i++) {
+		struct stream_cb_data *stream_data;
+		READ3args args;
+
++		/*
++		 * BSS_PENDING means we have a request for prefetch in flight.
++		 * We don't want an unlimited amount of requests in flight
++		 * since it can cause wild latency spikes while initially
++		 * filling the prefetch buffer.
++		 */
++		if (nfsfh->sr->blocks[i].state == BSS_PENDING) {
++			num_pending++;
++		}
++		if (num_pending >= num_blocks) {
++			continue;
++		}
+		if (nfsfh->sr->blocks[i].state != BSS_UNUSED) {
+			continue;
+		}
+diff --git a/nfs-stream.c b/nfs-stream.c
+index dd01218..f5a1b0a 100644
+--- a/nfs-stream.c
++++ b/nfs-stream.c
+@@ -18,6 +18,11 @@ int main(int argc, char *argv[])
+	struct timeval t1, t2;
+	uint64_t delta, tpc;
+
++	if (argc != 3) {
++		fprintf(stderr, "Usage: nfs-stream <nfs-url> <bytes-per-second>\n");
++		exit(1);
++	}
++
+	nfs = nfs_init_context();
+	url = nfs_parse_url_full(nfs, argv[1]);
+	if (!url) {
+@@ -36,6 +41,8 @@ int main(int argc, char *argv[])
+			nfs_get_error(nfs));
+		exit(1);
+	}
++	nfs_set_streaming_mode(nfsfh, 5 * 1024 * 1024);
++
+	if (nfs_fstat64(nfs, nfsfh, &st)) {
+		fprintf(stderr, "Failed to stat file %s: %s\n",
+			url->file,
+--
+1.9.1
+
+
+From 503492873f27cefc3bfb368a96c4c7e1c99b303f Mon Sep 17 00:00:00 2001
+From: Ronnie Sahlberg <ronniesahlberg@gmail.com>
+Date: Tue, 10 Feb 2015 16:40:53 -0800
+Subject: [PATCH 6/7] streaming mode: wait until we have 10 sequential reads
+ before we prefetch
+
+Signed-off-by: Ronnie Sahlberg <ronniesahlberg@gmail.com>
+---
+ lib/libnfs.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/lib/libnfs.c b/lib/libnfs.c
+index 929d3e0..53b71fd 100644
+--- a/lib/libnfs.c
++++ b/lib/libnfs.c
+@@ -2433,7 +2433,7 @@ static int nfs_pread_async_internal(struct nfs_context *nfs, struct nfsfh *nfsfh
+		}
+		nfsfh->sr->next_offset = offset + count;
+
+-		if (nfsfh->sr->num_seq < 5) {
++		if (nfsfh->sr->num_seq < 10) {
+			goto end_of_streaming;
+		}
+
+--
+1.9.1
+
+
+From 55a673ae81514f109553d36b71647e8c334f8d81 Mon Sep 17 00:00:00 2001
+From: Ronnie Sahlberg <ronniesahlberg@gmail.com>
+Date: Wed, 11 Feb 2015 01:25:05 -0800
+Subject: [PATCH 7/7] nfs-stream.c: move this tool to the examples directory
+
+Signed-off-by: Ronnie Sahlberg <ronniesahlberg@gmail.com>
+---
+ examples/nfs-stream.c | 72 +++++++++++++++++++++++++++++++++++++++++++++++++++
+ nfs-stream.c          | 72 ---------------------------------------------------
+ 2 files changed, 72 insertions(+), 72 deletions(-)
+ create mode 100644 examples/nfs-stream.c
+ delete mode 100644 nfs-stream.c
+
+diff --git a/examples/nfs-stream.c b/examples/nfs-stream.c
+new file mode 100644
+index 0000000..f5a1b0a
+--- /dev/null
++++ b/examples/nfs-stream.c
+@@ -0,0 +1,72 @@
++#include <fcntl.h>
++#include <stdio.h>
++#include <stdlib.h>
++#include <sys/stat.h>
++#include <sys/time.h>
++#include <sys/types.h>
++#include <unistd.h>
++#include "nfsc/libnfs.h"
++
++int main(int argc, char *argv[])
++{
++	struct nfs_context *nfs;
++	struct nfs_url *url;
++	struct nfsfh *nfsfh = NULL;
++	struct nfs_stat_64 st;
++	uint64_t offset;
++	char buf[32768];
++	struct timeval t1, t2;
++	uint64_t delta, tpc;
++
++	if (argc != 3) {
++		fprintf(stderr, "Usage: nfs-stream <nfs-url> <bytes-per-second>\n");
++		exit(1);
++	}
++
++	nfs = nfs_init_context();
++	url = nfs_parse_url_full(nfs, argv[1]);
++	if (!url) {
++		fprintf(stderr, "Can not parse URL. %s\n",
++			nfs_get_error(nfs));
++		exit(1);
++	}
++	if (nfs_mount(nfs, url->server, url->path) != 0) {
++		fprintf(stderr, "Failed to mount nfs share : %s\n",
++			       nfs_get_error(nfs));
++		exit(1);
++	}
++	if (nfs_open(nfs, url->file, O_RDONLY, &nfsfh) != 0) {
++		fprintf(stderr, "Failed to open file %s: %s\n",
++			url->file,
++			nfs_get_error(nfs));
++		exit(1);
++	}
++	nfs_set_streaming_mode(nfsfh, 5 * 1024 * 1024);
++
++	if (nfs_fstat64(nfs, nfsfh, &st)) {
++		fprintf(stderr, "Failed to stat file %s: %s\n",
++			url->file,
++			nfs_get_error(nfs));
++		exit(1);
++	}
++	printf("File size:%lld\n", (long long)st.nfs_size);
++	tpc = 1000000 / (strtol(argv[2], NULL, 10) / 32768);
++	printf("Read one 32kb chunk every %d us\n", (int)tpc);
++	for (offset = 0; offset < st.nfs_size; offset += 32768) {
++		gettimeofday(&t1, NULL);
++		nfs_read(nfs, nfsfh, 32768, buf);
++		gettimeofday(&t2, NULL);
++		delta = t2.tv_sec * 1000000LL + t2.tv_usec -
++		  t1.tv_sec * 1000000LL - t1.tv_usec;
++		printf("Read latency:%lld us\n", (long long)delta);
++		if (tpc > delta) {
++			//printf("Sleep for %d us\n", (int)(tpc - delta));
++			usleep(tpc - delta);
++		}
++	}
++
++	nfs_close(nfs, nfsfh);
++	nfs_destroy_context(nfs);
++	nfs_destroy_url(url);
++	return 0;
++}
+diff --git a/nfs-stream.c b/nfs-stream.c
+deleted file mode 100644
+index f5a1b0a..0000000
+--- a/nfs-stream.c
++++ /dev/null
+@@ -1,72 +0,0 @@
+-#include <fcntl.h>
+-#include <stdio.h>
+-#include <stdlib.h>
+-#include <sys/stat.h>
+-#include <sys/time.h>
+-#include <sys/types.h>
+-#include <unistd.h>
+-#include "nfsc/libnfs.h"
+-
+-int main(int argc, char *argv[])
+-{
+-	struct nfs_context *nfs;
+-	struct nfs_url *url;
+-	struct nfsfh *nfsfh = NULL;
+-	struct nfs_stat_64 st;
+-	uint64_t offset;
+-	char buf[32768];
+-	struct timeval t1, t2;
+-	uint64_t delta, tpc;
+-
+-	if (argc != 3) {
+-		fprintf(stderr, "Usage: nfs-stream <nfs-url> <bytes-per-second>\n");
+-		exit(1);
+-	}
+-
+-	nfs = nfs_init_context();
+-	url = nfs_parse_url_full(nfs, argv[1]);
+-	if (!url) {
+-		fprintf(stderr, "Can not parse URL. %s\n",
+-			nfs_get_error(nfs));
+-		exit(1);
+-	}
+-	if (nfs_mount(nfs, url->server, url->path) != 0) {
+-		fprintf(stderr, "Failed to mount nfs share : %s\n",
+-			       nfs_get_error(nfs));
+-		exit(1);
+-	}
+-	if (nfs_open(nfs, url->file, O_RDONLY, &nfsfh) != 0) {
+-		fprintf(stderr, "Failed to open file %s: %s\n",
+-			url->file,
+-			nfs_get_error(nfs));
+-		exit(1);
+-	}
+-	nfs_set_streaming_mode(nfsfh, 5 * 1024 * 1024);
+-
+-	if (nfs_fstat64(nfs, nfsfh, &st)) {
+-		fprintf(stderr, "Failed to stat file %s: %s\n",
+-			url->file,
+-			nfs_get_error(nfs));
+-		exit(1);
+-	}
+-	printf("File size:%lld\n", (long long)st.nfs_size);
+-	tpc = 1000000 / (strtol(argv[2], NULL, 10) / 32768);
+-	printf("Read one 32kb chunk every %d us\n", (int)tpc);
+-	for (offset = 0; offset < st.nfs_size; offset += 32768) {
+-		gettimeofday(&t1, NULL);
+-		nfs_read(nfs, nfsfh, 32768, buf);
+-		gettimeofday(&t2, NULL);
+-		delta = t2.tv_sec * 1000000LL + t2.tv_usec -
+-		  t1.tv_sec * 1000000LL - t1.tv_usec;
+-		printf("Read latency:%lld us\n", (long long)delta);
+-		if (tpc > delta) {
+-			//printf("Sleep for %d us\n", (int)(tpc - delta));
+-			usleep(tpc - delta);
+-		}
+-	}
+-
+-	nfs_close(nfs, nfsfh);
+-	nfs_destroy_context(nfs);
+-	nfs_destroy_url(url);
+-	return 0;
+-}
+--
+1.9.1
diff --git a/tools/depends/target/libnfs/Makefile b/tools/depends/target/libnfs/Makefile
index 642fba8..aa6bde1 100644
--- a/tools/depends/target/libnfs/Makefile
+++ b/tools/depends/target/libnfs/Makefile
@@ -25,6 +25,7 @@ $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 	cd $(PLATFORM); ./bootstrap
 	cd $(PLATFORM); patch -p0 < ../utils.patch
 	cd $(PLATFORM); patch -p1 < ../readahead.patch
+	cd $(PLATFORM); patch -p1 < ../0001-Sequential-Readahead-Mode.patch
 	cd $(PLATFORM); $(CONFIGURE)
 
 $(LIBDYLIB): $(PLATFORM)
diff --git a/xbmc/filesystem/DllLibNfs.h b/xbmc/filesystem/DllLibNfs.h
index 4b5ba29..9ba8ebc 100644
--- a/xbmc/filesystem/DllLibNfs.h
+++ b/xbmc/filesystem/DllLibNfs.h
@@ -85,6 +85,7 @@ class DllLibNfsInterface
   virtual int nfs_pread(struct nfs_context *nfs,     struct nfsfh *nfsfh,  uint64_t offset, uint64_t count, char *buf)=0;
   virtual int nfs_pwrite(struct nfs_context *nfs,    struct nfsfh *nfsfh,  uint64_t offset, uint64_t count, char *buf)=0;
   virtual int nfs_lseek(struct nfs_context *nfs,     struct nfsfh *nfsfh,  uint64_t offset, int whence,   uint64_t *current_offset)=0;
+  virtual void nfs_set_streaming_mode(struct nfsfh *nfsfh, uint32_t v)=0;
 };
 
 class DllLibNfs : public DllDynamic, DllLibNfsInterface
@@ -131,6 +132,7 @@ class DllLibNfs : public DllDynamic, DllLibNfsInterface
   DEFINE_METHOD5(int, nfs_pread,     (struct nfs_context *p1, struct nfsfh *p2,  uint64_t p3,   uint64_t p4,  char *p5))
   DEFINE_METHOD5(int, nfs_pwrite,    (struct nfs_context *p1, struct nfsfh *p2,  uint64_t p3,   uint64_t p4,  char *p5))
   DEFINE_METHOD5(int, nfs_lseek,     (struct nfs_context *p1, struct nfsfh *p2,  uint64_t p3,   int p4,     uint64_t *p5))
+  DEFINE_METHOD2(void,nfs_set_streaming_mode,     (struct nfsfh *p1, uint32_t p2))
 
 
 
@@ -176,6 +178,7 @@ class DllLibNfs : public DllDynamic, DllLibNfsInterface
     RESOLVE_METHOD_RENAME(nfs_symlink,   nfs_symlink)
     RESOLVE_METHOD_RENAME(nfs_rename,    nfs_rename)
     RESOLVE_METHOD_RENAME(nfs_link,      nfs_link)      
+    RESOLVE_METHOD_RENAME(nfs_set_streaming_mode,      nfs_set_streaming_mode)
   END_METHOD_RESOLVE()
 };
 
diff --git a/xbmc/filesystem/NFSFile.cpp b/xbmc/filesystem/NFSFile.cpp
index 9354fd5..eaa1dd7 100644
--- a/xbmc/filesystem/NFSFile.cpp
+++ b/xbmc/filesystem/NFSFile.cpp
@@ -562,6 +562,8 @@ bool CNFSFile::Open(const CURL& url)
   CLog::Log(LOGDEBUG,"CNFSFile::Open - opened %s",url.GetFileName().c_str());
   m_url=url;
   
+  //gNfsConnection.GetImpl()->nfs_set_streaming_mode(m_pFileHandle, 5 * 1024 * 1024);
+
   struct __stat64 tmpBuffer;
 
   if( Stat(&tmpBuffer) )

From 37b404211c9d8c6e1545f2f6fd6dda25ce553ad7 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sun, 15 Feb 2015 14:06:12 +0000
Subject: [PATCH 53/89] [mmal] Allow mmal codec for dvd stills

---
 xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
index 0cd267a..9d8de2a 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
@@ -49,6 +49,9 @@
 #include "Video/DVDVideoCodecAndroidMediaCodec.h"
 #include "android/activity/AndroidFeatures.h"
 #endif
+#if defined(HAS_MMAL)
+#include "linux/RBP.h"
+#endif
 #include "Audio/DVDAudioCodecFFmpeg.h"
 #include "Audio/DVDAudioCodecPassthrough.h"
 #include "Overlay/DVDOverlayCodecSSA.h"
@@ -199,6 +202,10 @@ CDVDVideoCodec* CDVDFactoryCodec::CreateVideoCodec(CDVDStreamInfo &hint, unsigne
 #endif
   CLog::Log(LOGDEBUG, "CDVDFactoryCodec: compiled in hardware support: %s", hwSupport.c_str());
 
+#if defined(HAS_MMAL)
+  // mmal can handle dvd playback including stills
+  if (!CSettings::Get().GetBool("videoplayer.usemmal") || !g_RBP.GetCodecMpg2())
+#endif
   if (hint.stills && (hint.codec == AV_CODEC_ID_MPEG2VIDEO || hint.codec == AV_CODEC_ID_MPEG1VIDEO))
   {
      // If dvd is an mpeg2 and hint.stills

From 1c666d5d6570d68e1099f8961cc9f2c52d6e04e1 Mon Sep 17 00:00:00 2001
From: Claudio-Sjo <Claudio.Porfiri@gmail.com>
Date: Mon, 16 Feb 2015 14:51:26 +0100
Subject: [PATCH 54/89] - allow reads < CDIO_CD_FRAMESIZE_RAW by using a buffer
 - fixes #15794

---
 xbmc/filesystem/CDDAFile.cpp | 120 ++++++++++++++++++++++++++++++++-----------
 xbmc/filesystem/CDDAFile.h   |   3 ++
 2 files changed, 92 insertions(+), 31 deletions(-)

diff --git a/xbmc/filesystem/CDDAFile.cpp b/xbmc/filesystem/CDDAFile.cpp
index 16796f5..066b49f 100644
--- a/xbmc/filesystem/CDDAFile.cpp
+++ b/xbmc/filesystem/CDDAFile.cpp
@@ -43,10 +43,14 @@ CFileCDDA::CFileCDDA(void)
   m_lsnEnd = CDIO_INVALID_LSN;
   m_cdio = CLibcdio::GetInstance();
   m_iSectorCount = 52;
+  m_TrackBuf = (uint8_t *) malloc(CDIO_CD_FRAMESIZE_RAW);
+  p_TrackBuf = 0;
+  f_TrackBuf = 0;
 }
 
 CFileCDDA::~CFileCDDA(void)
 {
+  free(m_TrackBuf);
   Close();
 }
 
@@ -54,6 +58,9 @@ bool CFileCDDA::Open(const CURL& url)
 {
   std::string strURL = url.GetWithoutFilename();
 
+  // Flag TrackBuffer = FALSE, TrackBuffer is empty
+  f_TrackBuf = 0;
+
   if (!g_mediaManager.IsDiscInDrive(strURL) || !IsValidFile(url))
     return false;
 
@@ -118,50 +125,98 @@ int CFileCDDA::Stat(const CURL& url, struct __stat64* buffer)
 
 ssize_t CFileCDDA::Read(void* lpBuf, size_t uiBufSize)
 {
-  if (!m_pCdIo || !g_mediaManager.IsDiscInDrive())
-    return -1;
 
-  if (uiBufSize > SSIZE_MAX)
-    uiBufSize = SSIZE_MAX;
+  ssize_t returnValue;
+  int iSectorCount;
+  void *destBuf;
 
-  // limit number of sectors that fits in buffer by m_iSectorCount
-  int iSectorCount = std::min((int)uiBufSize / CDIO_CD_FRAMESIZE_RAW, m_iSectorCount);
 
-  if (iSectorCount <= 0)
+  if (!m_pCdIo || !g_mediaManager.IsDiscInDrive())
+  {
+    CLog::Log(LOGERROR, "file cdda: Aborted because no disc in drive or no m_pCdIo");
     return -1;
+  }
 
-  // Are there enough sectors left to read
-  if (m_lsnCurrent + iSectorCount > m_lsnEnd)
-    iSectorCount = m_lsnEnd - m_lsnCurrent;
+  uiBufSize = std::min( uiBufSize, (size_t)SSIZE_MAX );
 
-  // The loop tries to solve read error problem by lowering number of sectors to read (iSectorCount).
-  // When problem is solved the proper number of sectors is stored in m_iSectorCount
-  int big_iSectorCount = iSectorCount;
-  while (iSectorCount > 0)
+  // If we have data in the TrackBuffer, they must be used first
+  if (f_TrackBuf)
   {
-    int iret = m_cdio->cdio_read_audio_sectors(m_pCdIo, lpBuf, m_lsnCurrent, iSectorCount);
+    // Get at most the remaining data in m_TrackBuf
+    uiBufSize = std::min(uiBufSize, CDIO_CD_FRAMESIZE_RAW - p_TrackBuf);
+    memcpy(lpBuf, m_TrackBuf + p_TrackBuf, uiBufSize);
+    // Update the data offset
+    p_TrackBuf += uiBufSize;
+    // Is m_TrackBuf empty?
+    f_TrackBuf = (CDIO_CD_FRAMESIZE_RAW == p_TrackBuf);
+    // All done, return read bytes
+    return uiBufSize;
+  }
+
+  // No data left in buffer
+
+  // Is this a short read?
+  if (uiBufSize < CDIO_CD_FRAMESIZE_RAW)
+  {
+    // short request, buffer one full sector
+    iSectorCount = 1;
+    destBuf = m_TrackBuf;
+  }
+  else // normal request
+  {
+    // limit number of sectors that fits in buffer by m_iSectorCount
+    iSectorCount = std::min((int)uiBufSize / CDIO_CD_FRAMESIZE_RAW, m_iSectorCount);
+    destBuf = lpBuf;
+  }
 
+  // Are there enough sectors left to read?
+  iSectorCount = std::min(iSectorCount, m_lsnEnd - m_lsnCurrent);
+
+  // Have we reached EOF?
+  if (iSectorCount == 0)
+  {
+    CLog::Log(LOGNOTICE, "file cdda: Read EoF");
+    return 0; // Success, but nothing read
+  } // Reached EoF
+
+  // At leat one sector to read
+  int retries;
+  int iret;
+  // Try reading a decresing number of sectors, then 3 times with 1 sector
+  for (retries = 3; retries > 0; iSectorCount>1 ? iSectorCount-- : retries--)
+  {
+    iret = m_cdio->cdio_read_audio_sectors(m_pCdIo, destBuf, m_lsnCurrent, iSectorCount);
     if (iret == DRIVER_OP_SUCCESS)
+      break; // Get out from the loop
+    else
     {
-      // If lower iSectorCount solved the problem limit it's value
-      if (iSectorCount < big_iSectorCount)
-      {
-        m_iSectorCount = iSectorCount;
-      }
-      break;
-    }
-
-    // iSectorCount is low so it cannot solve read problem
-    if (iSectorCount <= 10)
-    {
-      CLog::Log(LOGERROR, "file cdda: Reading %d sectors of audio data starting at lsn %d failed with error code %i", iSectorCount, m_lsnCurrent, iret);
-      return -1;
-    }
-
-    iSectorCount = 10;
+      CLog::Log(LOGERROR, "file cdda: Read cdio error when reading track ");
+    } // Errors when reading file
   }
+  // retries == 0 only if failed reading at least one sector
+  if (retries == 0)
+  {
+    CLog::Log(LOGERROR, "file cdda: Reading %d sectors of audio data starting at lsn %d failed with error code %i", iSectorCount, m_lsnCurrent, iret);
+    return -1;
+  }
+
+  // Update position in file
   m_lsnCurrent += iSectorCount;
 
+  // Was it a short request?
+  if (uiBufSize < CDIO_CD_FRAMESIZE_RAW)
+  {
+    // We copy the amount if requested data into the destination buffer
+    memcpy(lpBuf, m_TrackBuf, uiBufSize);
+    // and keep track of the first available data
+    p_TrackBuf = uiBufSize;
+    // Finally, we set the buffer flag as TRUE
+    f_TrackBuf = true;
+    // We will return uiBufSize
+    return uiBufSize;
+  }
+
+  // Otherwise, just return the size of read data
   return iSectorCount*CDIO_CD_FRAMESIZE_RAW;
 }
 
@@ -195,6 +250,9 @@ int64_t CFileCDDA::Seek(int64_t iFilePosition, int iWhence /*=SEEK_SET*/)
 
 void CFileCDDA::Close()
 {
+  // Flag TrackBuffer = FALSE, TrackBuffer is empty
+  f_TrackBuf = 0;
+
   if (m_pCdIo)
   {
     m_cdio->cdio_destroy(m_pCdIo);
diff --git a/xbmc/filesystem/CDDAFile.h b/xbmc/filesystem/CDDAFile.h
index 0427af4..e992362 100644
--- a/xbmc/filesystem/CDDAFile.h
+++ b/xbmc/filesystem/CDDAFile.h
@@ -50,6 +50,9 @@ class CFileCDDA : public IFile
 
 protected:
   CdIo_t* m_pCdIo;
+  uint8_t *m_TrackBuf;
+  size_t   p_TrackBuf;
+  int      f_TrackBuf;
   lsn_t m_lsnStart;  // Start of m_iTrack in logical sector number
   lsn_t m_lsnCurrent; // Position inside the track in logical sector number
   lsn_t m_lsnEnd;   // End of m_iTrack in logical sector number

From bc5577e298d7939945b5700dbbbc42b4fe196a1e Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 20 Feb 2015 14:11:57 +0000
Subject: [PATCH 55/89] libavformat: add mvcC handling in .mov/.mp4

---
 ...ibavformat-add-mvcC-handling-in-.mov-.mp4.patch | 57 ++++++++++++++++++++++
 tools/depends/target/ffmpeg/Makefile               |  3 +-
 2 files changed, 59 insertions(+), 1 deletion(-)
 create mode 100644 tools/depends/target/ffmpeg/0001-libavformat-add-mvcC-handling-in-.mov-.mp4.patch

diff --git a/tools/depends/target/ffmpeg/0001-libavformat-add-mvcC-handling-in-.mov-.mp4.patch b/tools/depends/target/ffmpeg/0001-libavformat-add-mvcC-handling-in-.mov-.mp4.patch
new file mode 100644
index 0000000..72fbcb9
--- /dev/null
+++ b/tools/depends/target/ffmpeg/0001-libavformat-add-mvcC-handling-in-.mov-.mp4.patch
@@ -0,0 +1,57 @@
+From 40bca2ae81bb9cd131b90bf262e976674ca6fab8 Mon Sep 17 00:00:00 2001
+From: Deborah Crook <deborah@kynesim.co.uk>
+Date: Fri, 16 Jan 2015 14:24:17 +0000
+Subject: [PATCH] libavformat: add mvcC handling in .mov/.mp4
+
+---
+ libavformat/mov.c |   28 ++++++++++++++++++++++++++++
+ 1 file changed, 28 insertions(+)
+
+diff --git a/libavformat/mov.c b/libavformat/mov.c
+index 7455e3b..29bfec9 100644
+--- a/libavformat/mov.c
++++ b/libavformat/mov.c
+@@ -1201,6 +1201,33 @@ static int mov_read_glbl(MOVContext *c, AVIOContext *pb, MOVAtom atom)
+     return 0;
+ }
+
++static int mov_read_mvcc(MOVContext *c, AVIOContext *pb, MOVAtom atom)
++{
++    int extradata_size;
++    int ret, i;
++    uint32_t n;
++    AVStream *st;
++
++    if (c->fc->nb_streams < 1)
++        return 0;
++    st = c->fc->streams[c->fc->nb_streams-1];
++    extradata_size = st->codec->extradata_size;
++
++    if ((uint64_t)atom.size > (1<<30))
++        return AVERROR_INVALIDDATA;
++
++    if (extradata_size == 0)
++        return 0;
++    if ((ret = mov_read_extradata(c, pb, atom, AV_CODEC_ID_H264)) < 0)
++        return ret;
++    for (i = 0, n = 0; i < 4; i++)
++        n = (n << 8) | st->codec->extradata[extradata_size+i];
++    n -= 4;
++    for (i = 0; i < 4; i++)
++        st->codec->extradata[extradata_size+i] = (n >> ((3 - i) << 3)) & 0xff;
++    return 0;
++}
++
+ static int mov_read_dvc1(MOVContext *c, AVIOContext *pb, MOVAtom atom)
+ {
+     AVStream *st;
+@@ -3383,6 +3410,7 @@ static const MOVParseTableEntry mov_default_parse_table[] = {
+ { MKTAG('C','i','n', 0x8e), mov_read_targa_y216 },
+ { MKTAG('f','r','e','e'), mov_read_free },
+ { MKTAG('-','-','-','-'), mov_read_custom },
++{ MKTAG('m','v','c','C'), mov_read_mvcc },
+ { 0, NULL }
+ };
+
+--
+1.7.10.4
diff --git a/tools/depends/target/ffmpeg/Makefile b/tools/depends/target/ffmpeg/Makefile
index 6e8364a..43dc4ff 100644
--- a/tools/depends/target/ffmpeg/Makefile
+++ b/tools/depends/target/ffmpeg/Makefile
@@ -1,6 +1,6 @@
 include ../../Makefile.include
 include FFMPEG-VERSION
-DEPS= ../../Makefile.include FFMPEG-VERSION Makefile ffmpeg_Speed_up_wtv_index_creation.patch
+DEPS= ../../Makefile.include FFMPEG-VERSION Makefile ffmpeg_Speed_up_wtv_index_creation.patch 0001-libavformat-add-mvcC-handling-in-.mov-.mp4.patch
 
 # set to "yes" to enable patching
 # we don't apply patches until we move to a vanilla ffmpeg tarball
@@ -69,6 +69,7 @@ $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 	cd $(PLATFORM); $(ARCHIVE_TOOL) $(ARCHIVE_TOOL_FLAGS) $(TARBALLS_LOCATION)/$(ARCHIVE)
 	cd $(PLATFORM); sed -i".bak" -e "s%pkg_config_default=pkg-config%export PKG_CONFIG_LIBDIR=$(PREFIX)/lib/pkgconfig \&\& pkg_config_default=$(NATIVEPREFIX)/bin/pkg-config%" configure
 	cd $(PLATFORM); patch -p3 < ../ffmpeg_Speed_up_wtv_index_creation.patch
+	cd $(PLATFORM); patch -p1 < ../0001-libavformat-add-mvcC-handling-in-.mov-.mp4.patch
 	cd $(PLATFORM);\
 	CFLAGS="$(CFLAGS)" CXXFLAGS="$(CXXFLAGS)" CPPFLAGS="$(CPPFLAGS)" LDFLAGS="$(LDFLAGS)" \
 	./configure $(ffmpg_config)

From fccae33d78ecc18c9edcec5f6e5a36005c6b8b8c Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 24 Feb 2015 15:57:29 +0000
Subject: [PATCH 56/89] [mmalrenderer] Fix for stereo view modes

PR6090 (dirty regions for video) meant that RenderUpate is no longer called with the expected stereo view mode.
So, just explicitly set this before calling ManageDisplay to get the desired rectangles
---
 xbmc/cores/VideoRenderers/MMALRenderer.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/xbmc/cores/VideoRenderers/MMALRenderer.cpp b/xbmc/cores/VideoRenderers/MMALRenderer.cpp
index 3329980..d53de35 100644
--- a/xbmc/cores/VideoRenderers/MMALRenderer.cpp
+++ b/xbmc/cores/VideoRenderers/MMALRenderer.cpp
@@ -351,7 +351,11 @@ void CMMALRenderer::RenderUpdate(bool clear, DWORD flags, DWORD alpha)
 
   if (!m_bConfigured) return;
 
+  if (g_graphicsContext.GetStereoMode())
+    g_graphicsContext.SetStereoView(RENDER_STEREO_VIEW_LEFT);
   ManageDisplay();
+  if (g_graphicsContext.GetStereoMode())
+    g_graphicsContext.SetStereoView(RENDER_STEREO_VIEW_OFF);
 
   // if running bypass, then the player might need the src/dst rects
   // for sizing video playback on a layer other than the gles layer.

From 76958643f9e7aa870f3038a960baf3f987c39be8 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 27 Feb 2015 14:37:27 +0000
Subject: [PATCH 57/89] ffmpeg: Add some upstream HEVC optimisations

---
 tools/depends/target/ffmpeg/Makefile               |   5 +-
 ...hevcdsp_ARM_NEON_optimized_epel_functions.patch | 406 +++++++++++++++++++++
 2 files changed, 410 insertions(+), 1 deletion(-)
 create mode 100644 tools/depends/target/ffmpeg/hevcdsp_ARM_NEON_optimized_epel_functions.patch

diff --git a/tools/depends/target/ffmpeg/Makefile b/tools/depends/target/ffmpeg/Makefile
index 43dc4ff..757721c 100644
--- a/tools/depends/target/ffmpeg/Makefile
+++ b/tools/depends/target/ffmpeg/Makefile
@@ -1,6 +1,7 @@
 include ../../Makefile.include
 include FFMPEG-VERSION
-DEPS= ../../Makefile.include FFMPEG-VERSION Makefile ffmpeg_Speed_up_wtv_index_creation.patch 0001-libavformat-add-mvcC-handling-in-.mov-.mp4.patch
+DEPS= ../../Makefile.include FFMPEG-VERSION Makefile ffmpeg_Speed_up_wtv_index_creation.patch 0001-libavformat-add-mvcC-handling-in-.mov-.mp4.patch \
+  hevcdsp_ARM_NEON_optimized_epel_functions.patch
 
 # set to "yes" to enable patching
 # we don't apply patches until we move to a vanilla ffmpeg tarball
@@ -70,6 +71,8 @@ $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 	cd $(PLATFORM); sed -i".bak" -e "s%pkg_config_default=pkg-config%export PKG_CONFIG_LIBDIR=$(PREFIX)/lib/pkgconfig \&\& pkg_config_default=$(NATIVEPREFIX)/bin/pkg-config%" configure
 	cd $(PLATFORM); patch -p3 < ../ffmpeg_Speed_up_wtv_index_creation.patch
 	cd $(PLATFORM); patch -p1 < ../0001-libavformat-add-mvcC-handling-in-.mov-.mp4.patch
+	cd $(PLATFORM); patch -p1 < ../hevcdsp_ARM_NEON_optimized_epel_functions.patch
+
 	cd $(PLATFORM);\
 	CFLAGS="$(CFLAGS)" CXXFLAGS="$(CXXFLAGS)" CPPFLAGS="$(CPPFLAGS)" LDFLAGS="$(LDFLAGS)" \
 	./configure $(ffmpg_config)
diff --git a/tools/depends/target/ffmpeg/hevcdsp_ARM_NEON_optimized_epel_functions.patch b/tools/depends/target/ffmpeg/hevcdsp_ARM_NEON_optimized_epel_functions.patch
new file mode 100644
index 0000000..de95ba6
--- /dev/null
+++ b/tools/depends/target/ffmpeg/hevcdsp_ARM_NEON_optimized_epel_functions.patch
@@ -0,0 +1,406 @@
+From 5114c6fb870fe3aea5da05ea218760a47a29ad74 Mon Sep 17 00:00:00 2001
+From: Seppo Tomperi <seppo.tomperi@vtt.fi>
+Date: Thu, 5 Feb 2015 13:32:28 +0000
+Subject: [PATCH] hevcdsp: ARM NEON optimized epel functions
+
+---
+ libavcodec/arm/Makefile            |   1 +
+ libavcodec/arm/hevcdsp_epel_neon.S | 334 +++++++++++++++++++++++++++++++++++++
+ libavcodec/arm/hevcdsp_init_neon.c |  23 +++
+ 3 files changed, 358 insertions(+)
+ create mode 100644 libavcodec/arm/hevcdsp_epel_neon.S
+
+diff --git a/libavcodec/arm/Makefile b/libavcodec/arm/Makefile
+index 434a2d1..95eb814 100644
+--- a/libavcodec/arm/Makefile
++++ b/libavcodec/arm/Makefile
+@@ -134,6 +134,7 @@ NEON-OBJS-$(CONFIG_DCA_DECODER)        += arm/dcadsp_neon.o             \
+                                           arm/synth_filter_neon.o
+ NEON-OBJS-$(CONFIG_HEVC_DECODER)       += arm/hevcdsp_init_neon.o       \
+                                           arm/hevcdsp_deblock_neon.o    \
++                                          arm/hevcdsp_epel_neon.o       \
+                                           arm/hevcdsp_idct_neon.o       \
+                                           arm/hevcdsp_qpel_neon.o
+ NEON-OBJS-$(CONFIG_RV30_DECODER)       += arm/rv34dsp_neon.o
+diff --git a/libavcodec/arm/hevcdsp_epel_neon.S b/libavcodec/arm/hevcdsp_epel_neon.S
+new file mode 100644
+index 0000000..424416d
+--- /dev/null
++++ b/libavcodec/arm/hevcdsp_epel_neon.S
+@@ -0,0 +1,334 @@
++/*
++ * Copyright (c) 2014 - 2015 Seppo Tomperi <seppo.tomperi@vtt.fi>
++ *
++ * This file is part of FFmpeg.
++ *
++ * FFmpeg is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU Lesser General Public
++ * License as published by the Free Software Foundation; either
++ * version 2.1 of the License, or (at your option) any later version.
++ *
++ * FFmpeg is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * Lesser General Public License for more details.
++ *
++ * You should have received a copy of the GNU Lesser General Public
++ * License along with FFmpeg; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
++ */
++
++#include "libavutil/arm/asm.S"
++#include "neon.S"
++
++#define MAX_PB_SIZE #64
++
++.macro vextin_d4
++    vld1.8    {q10}, [r1], r2
++    vmov      d16, d20
++    vext.8    d17, d20, d21, #1
++    vext.8    d18, d20, d21, #2
++    vext.8    d19, d20, d21, #3
++.endm
++
++.macro vextin_d4_8
++    vld1.8    d16, [r1], r2
++    vext.8    d17, d16, d16, #1
++    vext.8    d18, d16, d16, #2
++    vext.8    d19, d16, d16, #3
++.endm
++
++.macro load_coeffs_16b coeffs
++    ldr      \coeffs, [\coeffs]
++    vdup.i8  d0, \coeffs
++    lsr      \coeffs, #8
++    vdup.i8  d1, \coeffs
++    lsr      \coeffs, #8
++    vdup.i8  d2, \coeffs
++    lsr      \coeffs, #8
++    vdup.i8  d3, \coeffs
++.endm
++
++.macro epel_filter_16b out=q12
++    vmull.u8 q3, d16, d0
++    vmull.u8 q11, d19, d3
++    vmull.u8 \out, d17, d1
++    vmull.u8 q10, d18, d2
++    vadd.s16 q3, q11
++    vadd.s16 \out, q10
++    vsub.s16 \out, q3
++.endm
++
++.macro load_coeffs_32b coeffs
++    ldr      \coeffs, [\coeffs]
++    vmov.i64 d4, #0
++    vmov.8   d4[0], \coeffs
++    lsr      \coeffs, #8
++    vmov.8   d4[2], \coeffs
++    lsr      \coeffs, #8
++    vmov.8   d4[4], \coeffs
++    lsr      \coeffs, #8
++    vmov.8   d4[6], \coeffs
++.endm
++
++.macro epel_filter_32b
++    vmull.s16 q3, d24, d4[0] //q12
++    vmull.s16 q4, d25, d4[0]
++    vmull.s16 q5, d30, d4[3] //q15
++    vmull.s16 q6, d31, d4[3]
++
++    vmull.s16 q7, d26, d4[1] // q13
++    vmull.s16 q8, d27, d4[1]
++    vmull.s16 q9, d28, d4[2] // q14
++    vmull.s16 q10, d29, d4[2]
++    vadd.s32 q3, q5
++    vadd.s32 q4, q6
++    vadd.s32 q7, q9
++    vadd.s32 q8, q10
++    vsub.s32 q7, q3
++    vsub.s32 q8, q4
++    vqshrn.s32  d6, q7, #6
++    vqshrn.s32  d7, q8, #6
++.endm
++
++.macro epel_filter_32b_4
++    vmull.s16 q3, d24, d4[0] //q12
++    vmull.s16 q5, d30, d4[3] //q15
++    vmull.s16 q7, d26, d4[1] // q13
++    vmull.s16 q9, d28, d4[2] // q14
++    vadd.s32 q3, q5
++    vadd.s32 q7, q9
++    vsub.s32 q7, q3
++    vqshrn.s32  d6, q7, #6
++.endm
++
++function ff_hevc_put_epel_h_neon_8, export=1
++        push   {r4-r7}
++        mov    r4, MAX_PB_SIZE
++        ldr    r7, [sp, #16] // mx
++        ldr    r5, [sp, #24] // width
++        sub    r7, #1
++        lsl    r7, #2
++        vpush {d8-d15}
++        adrl   r12, epel_coeffs
++        add    r7, r12
++        sub       r1, #1
++        lsl       r4, #1
++        load_coeffs_16b r7
++        mov   r12, r3
++        mov   r6, r0
++        mov   r7, r1
++        cmp       r5, #6
++        bgt       8f
++        cmp       r5, #4
++        blt       2f
++        b         4f
++8:      subs r3, #1
++        pld [r1]
++        vextin_d4
++        epel_filter_16b
++        vst1.16    {q12}, [r0], r4
++        bne 8b
++        subs    r5, #8
++        beq  99f
++        mov       r3, r12
++        add       r6, #16
++        mov       r0, r6
++        add       r7, #8
++        mov       r1, r7
++        cmp       r5, #4
++        bgt       8b
++4:      subs r3, #1
++        pld [r1]
++        vextin_d4_8
++        epel_filter_16b
++        vst1.16    d24, [r0], r4
++        bne 4b
++        subs      r5, #4
++        beq       99f
++        mov       r3, r12
++        add       r6, #8
++        mov       r0, r6
++        add       r7, #4
++        mov       r1, r7
++2:      subs r3, #1
++        pld [r1]
++        vextin_d4_8
++        epel_filter_16b
++        vst1.32    d24[0], [r0], r4
++        bne 2b
++99:     vpop {d8-d15}
++        pop {r4-r7}
++        bx lr
++endfunc
++
++function ff_hevc_put_epel_v_neon_8, export=1
++        push   {r4-r7}
++        mov    r4, MAX_PB_SIZE
++        ldr    r7, [sp, #20] // my
++        ldr    r5, [sp, #24] // width
++        sub    r7, #1
++        lsl    r7, #2
++        vpush {d8-d15}
++        adrl   r12, epel_coeffs
++        add    r7, r12
++        load_coeffs_16b r7
++        sub       r1, r2
++        lsl       r4, #1
++        mov   r12, r3
++        mov   r6, r0
++        mov   r7, r1
++0:      pld [r1]
++        vld1.8    {d16}, [r1], r2
++        pld [r1]
++        vld1.8    {d17}, [r1], r2
++        pld [r1]
++        vld1.8    {d18}, [r1], r2
++        cmp       r5, #6
++        bgt       8f
++        cmp       r5, #4
++        blt       2f
++        b         4f
++8:      pld [r1]
++        vld1.8    {d19}, [r1], r2
++        subs r3, #1
++        epel_filter_16b
++        vst1.16    {q12}, [r0], r4
++        vmov d16, d17
++        vmov d17, d18
++        vmov d18, d19
++        bne 8b
++        subs    r5, #8
++        beq  99f
++        mov       r3, r12
++        add       r6, #16
++        mov       r0, r6
++        add       r7, #8
++        mov       r1, r7
++        b         0b
++4:      pld       [r1]
++        vld1.8    {d19}, [r1], r2
++        subs r3, #1
++        epel_filter_16b
++        vst1.16    d24, [r0], r4
++        vmov d16, d17
++        vmov d17, d18
++        vmov d18, d19
++        bne 4b
++        subs      r5, #4
++        beq       99f
++        mov       r3, r12
++        add       r6, #8
++        mov       r0, r6
++        add       r7, #4
++        mov       r1, r7
++        b         0b
++2:      pld [r1]
++        vld1.8    {d19}, [r1], r2
++        subs r3, #1
++        epel_filter_16b
++        vst1.32    d24[0], [r0], r4
++        vmov d16, d17
++        vmov d17, d18
++        vmov d18, d19
++        bne 2b
++99:     vpop {d8-d15}
++        pop {r4-r7}
++        bx lr
++endfunc
++
++function ff_hevc_put_epel_hv_neon_8, export=1
++        push   {r4-r7}
++        mov    r4, MAX_PB_SIZE
++        ldr    r6, [sp, #16] // mx
++        ldr    r7, [sp, #20] // my
++        ldr    r5, [sp, #24] // width
++        sub    r7, #1
++        lsl    r7, #2
++        vpush {d8-d15}
++        adrl   r12, epel_coeffs
++        sub    r6, #1
++        lsl    r6, #2
++        add    r6, r12 // mx epel coeff offset
++        add    r7, r12
++        sub       r1, #1
++        sub       r1, r2
++        lsl       r4, #1
++        load_coeffs_16b r6
++        load_coeffs_32b r7
++        mov   r12, r3
++        mov   r6, r0
++        mov   r7, r1
++0:      pld   [r1]
++        vextin_d4
++        epel_filter_16b q12
++        pld   [r1]
++        vextin_d4
++        epel_filter_16b q13
++        pld   [r1]
++        vextin_d4
++        epel_filter_16b q14
++        cmp       r5, #6
++        bgt       8f
++        cmp       r5, #4
++        blt       2f
++        b         4f
++8:      pld     [r1]
++        vextin_d4
++        epel_filter_16b q15
++        subs r3, #1
++        epel_filter_32b
++        vst1.16    {q3}, [r0], r4
++        vmov q12, q13
++        vmov q13, q14
++        vmov q14, q15
++        bne 8b
++        subs    r5, #8
++        beq  99f
++        mov       r3, r12
++        add       r6, #16
++        mov       r0, r6
++        add       r7, #8
++        mov       r1, r7
++        b         0b
++4:      pld      [r1]
++        vextin_d4_8
++        epel_filter_16b q15
++        subs r3, #1
++        epel_filter_32b_4
++        vst1.16    d6, [r0], r4
++        vmov q12, q13
++        vmov q13, q14
++        vmov q14, q15
++        bne 4b
++        subs      r5, #4
++        beq       99f
++        mov       r3, r12
++        add       r6, #8
++        mov       r0, r6
++        add       r7, #4
++        mov       r1, r7
++        b         0b
++2:      pld      [r1]
++        vextin_d4_8
++        epel_filter_16b q15
++        subs r3, #1
++        epel_filter_32b_4
++        vst1.32    d6[0], [r0], r4
++        vmov q12, q13
++        vmov q13, q14
++        vmov q14, q15
++        bne 2b
++99:     vpop {d8-d15}
++        pop {r4-r7}
++        bx lr
++endfunc
++
++epel_coeffs:
++       .byte 2, 58, 10, 2
++       .byte 4, 54, 16, 2
++       .byte 6, 46, 28, 4
++       .byte 4, 36, 36, 4
++       .byte 4, 28, 46, 6
++       .byte 2, 16, 54, 4
++       .byte 2, 10, 58, 2
+diff --git a/libavcodec/arm/hevcdsp_init_neon.c b/libavcodec/arm/hevcdsp_init_neon.c
+index 61e6462..917abc4 100644
+--- a/libavcodec/arm/hevcdsp_init_neon.c
++++ b/libavcodec/arm/hevcdsp_init_neon.c
+@@ -57,6 +57,15 @@ PUT_PIXELS(ff_hevc_put_pixels_w32_neon_8);
+ PUT_PIXELS(ff_hevc_put_pixels_w48_neon_8);
+ PUT_PIXELS(ff_hevc_put_pixels_w64_neon_8);
+ #undef PUT_PIXELS
++void ff_hevc_put_epel_h_neon_8(int16_t *dst, uint8_t *src,
++                                ptrdiff_t srcstride, int height,
++                                intptr_t mx, intptr_t my, int width);
++void ff_hevc_put_epel_v_neon_8(int16_t *dst, uint8_t *src,
++                                ptrdiff_t srcstride, int height,
++                                intptr_t mx, intptr_t my, int width);
++void ff_hevc_put_epel_hv_neon_8(int16_t *dst, uint8_t *src,
++                                ptrdiff_t srcstride, int height,
++                                intptr_t mx, intptr_t my, int width);
+
+ static void (*put_hevc_qpel_neon[4][4])(int16_t *dst, ptrdiff_t dststride, uint8_t *src, ptrdiff_t srcstride,
+                                    int height, int width);
+@@ -201,7 +210,21 @@ static av_cold void hevcdsp_init_neon(HEVCDSPContext *c, const int bit_depth)
+             c->put_hevc_qpel_bi[x][1][0]      = ff_hevc_put_qpel_bi_neon_wrapper;
+             c->put_hevc_qpel_bi[x][0][1]      = ff_hevc_put_qpel_bi_neon_wrapper;
+             c->put_hevc_qpel_bi[x][1][1]      = ff_hevc_put_qpel_bi_neon_wrapper;
++            c->put_hevc_epel[x][1][0]         = ff_hevc_put_epel_v_neon_8;
++            c->put_hevc_epel[x][0][1]         = ff_hevc_put_epel_h_neon_8;
++            c->put_hevc_epel[x][1][1]         = ff_hevc_put_epel_hv_neon_8;
+         }
++        c->put_hevc_epel[0][0][0]  = ff_hevc_put_pixels_w2_neon_8;
++        c->put_hevc_epel[1][0][0]  = ff_hevc_put_pixels_w4_neon_8;
++        c->put_hevc_epel[2][0][0]  = ff_hevc_put_pixels_w6_neon_8;
++        c->put_hevc_epel[3][0][0]  = ff_hevc_put_pixels_w8_neon_8;
++        c->put_hevc_epel[4][0][0]  = ff_hevc_put_pixels_w12_neon_8;
++        c->put_hevc_epel[5][0][0]  = ff_hevc_put_pixels_w16_neon_8;
++        c->put_hevc_epel[6][0][0]  = ff_hevc_put_pixels_w24_neon_8;
++        c->put_hevc_epel[7][0][0]  = ff_hevc_put_pixels_w32_neon_8;
++        c->put_hevc_epel[8][0][0]  = ff_hevc_put_pixels_w48_neon_8;
++        c->put_hevc_epel[9][0][0]  = ff_hevc_put_pixels_w64_neon_8;
++
+         c->put_hevc_qpel[0][0][0]  = ff_hevc_put_pixels_w2_neon_8;
+         c->put_hevc_qpel[1][0][0]  = ff_hevc_put_pixels_w4_neon_8;
+         c->put_hevc_qpel[2][0][0]  = ff_hevc_put_pixels_w6_neon_8;

From e885adeaa52b27c769c7c0f599e95c772f93f0fa Mon Sep 17 00:00:00 2001
From: anaconda <anaconda@menakite.eu>
Date: Wed, 25 Feb 2015 18:22:21 +0100
Subject: [PATCH 58/89] Load OSD dialogs on startup.

Fixes skipped frames the first time they're loaded in memory on less powered
devices, like a Raspberry Pi, when using DVDPlayer.
See http://forum.kodi.tv/showthread.php?tid=211501&pid=1938811#pid1938811
---
 xbmc/pvr/dialogs/GUIDialogPVRChannelsOSD.cpp          | 1 +
 xbmc/pvr/dialogs/GUIDialogPVRGuideOSD.cpp             | 1 +
 xbmc/video/dialogs/GUIDialogAudioSubtitleSettings.cpp | 4 +++-
 xbmc/video/dialogs/GUIDialogSubtitles.cpp             | 2 +-
 xbmc/video/dialogs/GUIDialogVideoOSD.cpp              | 2 +-
 xbmc/video/dialogs/GUIDialogVideoSettings.cpp         | 4 +++-
 6 files changed, 10 insertions(+), 4 deletions(-)

diff --git a/xbmc/pvr/dialogs/GUIDialogPVRChannelsOSD.cpp b/xbmc/pvr/dialogs/GUIDialogPVRChannelsOSD.cpp
index 499f926..9f85783 100644
--- a/xbmc/pvr/dialogs/GUIDialogPVRChannelsOSD.cpp
+++ b/xbmc/pvr/dialogs/GUIDialogPVRChannelsOSD.cpp
@@ -50,6 +50,7 @@ CGUIDialogPVRChannelsOSD::CGUIDialogPVRChannelsOSD() :
     CGUIDialog(WINDOW_DIALOG_PVR_OSD_CHANNELS, "DialogPVRChannelsOSD.xml"),
     Observer()
 {
+  m_loadType = LOAD_ON_GUI_INIT;
   m_vecItems = new CFileItemList;
 }
 
diff --git a/xbmc/pvr/dialogs/GUIDialogPVRGuideOSD.cpp b/xbmc/pvr/dialogs/GUIDialogPVRGuideOSD.cpp
index 1670190..329a3b8 100644
--- a/xbmc/pvr/dialogs/GUIDialogPVRGuideOSD.cpp
+++ b/xbmc/pvr/dialogs/GUIDialogPVRGuideOSD.cpp
@@ -35,6 +35,7 @@ using namespace PVR;
 CGUIDialogPVRGuideOSD::CGUIDialogPVRGuideOSD()
     : CGUIDialog(WINDOW_DIALOG_PVR_OSD_GUIDE, "DialogPVRGuideOSD.xml")
 {
+  m_loadType = LOAD_ON_GUI_INIT;
   m_vecItems = new CFileItemList;
 }
 
diff --git a/xbmc/video/dialogs/GUIDialogAudioSubtitleSettings.cpp b/xbmc/video/dialogs/GUIDialogAudioSubtitleSettings.cpp
index 5e091eb..35b417f 100644
--- a/xbmc/video/dialogs/GUIDialogAudioSubtitleSettings.cpp
+++ b/xbmc/video/dialogs/GUIDialogAudioSubtitleSettings.cpp
@@ -62,7 +62,9 @@ using namespace std;
 CGUIDialogAudioSubtitleSettings::CGUIDialogAudioSubtitleSettings()
   : CGUIDialogSettingsManualBase(WINDOW_DIALOG_AUDIO_OSD_SETTINGS, "VideoOSDSettings.xml"),
     m_passthrough(false)
-{ }
+{
+  m_loadType = LOAD_ON_GUI_INIT;
+}
 
 CGUIDialogAudioSubtitleSettings::~CGUIDialogAudioSubtitleSettings()
 { }
diff --git a/xbmc/video/dialogs/GUIDialogSubtitles.cpp b/xbmc/video/dialogs/GUIDialogSubtitles.cpp
index 6c14cd5..7e960ad 100644
--- a/xbmc/video/dialogs/GUIDialogSubtitles.cpp
+++ b/xbmc/video/dialogs/GUIDialogSubtitles.cpp
@@ -100,7 +100,7 @@ class CSubtitlesJob: public CJob
 CGUIDialogSubtitles::CGUIDialogSubtitles(void)
     : CGUIDialog(WINDOW_DIALOG_SUBTITLES, "DialogSubtitles.xml")
 {
-  m_loadType  = KEEP_IN_MEMORY;
+  m_loadType  = LOAD_ON_GUI_INIT;
   m_subtitles = new CFileItemList;
   m_serviceItems = new CFileItemList;
   m_pausedOnRun = false;
diff --git a/xbmc/video/dialogs/GUIDialogVideoOSD.cpp b/xbmc/video/dialogs/GUIDialogVideoOSD.cpp
index 8a856e1..18b25fd 100644
--- a/xbmc/video/dialogs/GUIDialogVideoOSD.cpp
+++ b/xbmc/video/dialogs/GUIDialogVideoOSD.cpp
@@ -35,7 +35,7 @@ using namespace PVR;
 CGUIDialogVideoOSD::CGUIDialogVideoOSD(void)
     : CGUIDialog(WINDOW_DIALOG_VIDEO_OSD, "VideoOSD.xml")
 {
-  m_loadType = KEEP_IN_MEMORY;
+  m_loadType = LOAD_ON_GUI_INIT;
 }
 
 CGUIDialogVideoOSD::~CGUIDialogVideoOSD(void)
diff --git a/xbmc/video/dialogs/GUIDialogVideoSettings.cpp b/xbmc/video/dialogs/GUIDialogVideoSettings.cpp
index 4940561..f52698c 100644
--- a/xbmc/video/dialogs/GUIDialogVideoSettings.cpp
+++ b/xbmc/video/dialogs/GUIDialogVideoSettings.cpp
@@ -64,7 +64,9 @@ using namespace std;
 CGUIDialogVideoSettings::CGUIDialogVideoSettings()
     : CGUIDialogSettingsManualBase(WINDOW_DIALOG_VIDEO_OSD_SETTINGS, "VideoOSDSettings.xml"),
       m_viewModeChanged(false)
-{ }
+{
+  m_loadType = LOAD_ON_GUI_INIT;
+}
 
 CGUIDialogVideoSettings::~CGUIDialogVideoSettings()
 { }

From 018f759a0be60d10f72bb35df22e074ceb88ae72 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 5 Mar 2015 20:00:59 +0000
Subject: [PATCH 59/89] [ffmpmeg] Discard data before VO/VOL in mpeg-4 over
 mpegts

---
 ...-data-before-VO-VOL-in-mpeg-4-over-mpegts.patch | 69 ++++++++++++++++++++++
 tools/depends/target/ffmpeg/Makefile               |  4 +-
 2 files changed, 72 insertions(+), 1 deletion(-)
 create mode 100644 tools/depends/target/ffmpeg/0001-Discard-data-before-VO-VOL-in-mpeg-4-over-mpegts.patch

diff --git a/tools/depends/target/ffmpeg/0001-Discard-data-before-VO-VOL-in-mpeg-4-over-mpegts.patch b/tools/depends/target/ffmpeg/0001-Discard-data-before-VO-VOL-in-mpeg-4-over-mpegts.patch
new file mode 100644
index 0000000..eef7385
--- /dev/null
+++ b/tools/depends/target/ffmpeg/0001-Discard-data-before-VO-VOL-in-mpeg-4-over-mpegts.patch
@@ -0,0 +1,69 @@
+From ff289b3678b3b102f76c0fc0ffc802e3c8026fdb Mon Sep 17 00:00:00 2001
+From: Deborah Crook <deborah@kynesim.co.uk>
+Date: Thu, 5 Mar 2015 19:48:43 +0000
+Subject: [PATCH] Discard data before VO/VOL in mpeg-4 over mpegts
+
+---
+ libavcodec/mpeg4video_parser.c | 26 ++++++++++++++++++++++----
+ 1 file changed, 22 insertions(+), 4 deletions(-)
+
+diff --git a/libavcodec/mpeg4video_parser.c b/libavcodec/mpeg4video_parser.c
+index aa5e87a..0d8b15a 100644
+--- a/libavcodec/mpeg4video_parser.c
++++ b/libavcodec/mpeg4video_parser.c
+@@ -43,18 +43,32 @@ int ff_mpeg4_find_frame_end(ParseContext *pc, const uint8_t *buf, int buf_size)
+     state     = pc->state;
+
+     i = 0;
+-    if (!vop_found) {
++    if (vop_found < 0) {
++        for (i = 0; i < buf_size; i++) {
++            state = (state << 8) | buf[i];
++            if (state >= 0x100 && state <= 0x12f) {
++                i++;
++                vop_found = 0;
++                break;
++            }
++        }
++    }
++
++    if (vop_found == 0)
++        vop_found = 1;
++
++    if (vop_found == 1) {
+         for (i = 0; i < buf_size; i++) {
+             state = (state << 8) | buf[i];
+             if (state == 0x1B6) {
+                 i++;
+-                vop_found = 1;
++                vop_found = 2;
+                 break;
+             }
+         }
+     }
+
+-    if (vop_found) {
++    if (vop_found == 2) {
+         /* EOF considered as end of frame */
+         if (buf_size == 0)
+             return 0;
+@@ -133,12 +147,16 @@ static int mpeg4video_parse(AVCodecParserContext *s,
+     ParseContext *pc = s->priv_data;
+     int next;
+
++    if (pc->frame_start_found == 0 && !avctx->extradata)
++        pc->frame_start_found = -1;
++
+     if (s->flags & PARSER_FLAG_COMPLETE_FRAMES) {
+         next = buf_size;
+     } else {
+         next = ff_mpeg4_find_frame_end(pc, buf, buf_size);
+
+-        if (ff_combine_frame(pc, next, &buf, &buf_size) < 0) {
++        if (pc->frame_start_found < 0 ||
++            ff_combine_frame(pc, next, &buf, &buf_size) < 0) {
+             *poutbuf      = NULL;
+             *poutbuf_size = 0;
+             return buf_size;
+--
+2.1.4
diff --git a/tools/depends/target/ffmpeg/Makefile b/tools/depends/target/ffmpeg/Makefile
index 757721c..fbef09a 100644
--- a/tools/depends/target/ffmpeg/Makefile
+++ b/tools/depends/target/ffmpeg/Makefile
@@ -1,7 +1,8 @@
 include ../../Makefile.include
 include FFMPEG-VERSION
 DEPS= ../../Makefile.include FFMPEG-VERSION Makefile ffmpeg_Speed_up_wtv_index_creation.patch 0001-libavformat-add-mvcC-handling-in-.mov-.mp4.patch \
-  hevcdsp_ARM_NEON_optimized_epel_functions.patch
+  hevcdsp_ARM_NEON_optimized_epel_functions.patch \
+  0001-Discard-data-before-VO-VOL-in-mpeg-4-over-mpegts.patch
 
 # set to "yes" to enable patching
 # we don't apply patches until we move to a vanilla ffmpeg tarball
@@ -72,6 +73,7 @@ $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 	cd $(PLATFORM); patch -p3 < ../ffmpeg_Speed_up_wtv_index_creation.patch
 	cd $(PLATFORM); patch -p1 < ../0001-libavformat-add-mvcC-handling-in-.mov-.mp4.patch
 	cd $(PLATFORM); patch -p1 < ../hevcdsp_ARM_NEON_optimized_epel_functions.patch
+	cd $(PLATFORM); patch -p1 < ../0001-Discard-data-before-VO-VOL-in-mpeg-4-over-mpegts.patch
 
 	cd $(PLATFORM);\
 	CFLAGS="$(CFLAGS)" CXXFLAGS="$(CXXFLAGS)" CPPFLAGS="$(CPPFLAGS)" LDFLAGS="$(LDFLAGS)" \

From 91db23dc25c5ea12f5183dc99379ac79d9e6a1dd Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 7 Mar 2015 22:46:21 +0000
Subject: [PATCH 60/89] configure: Add raspberry-pi2 platform

---
 configure.ac                                      | 14 +++++++--
 m4/xbmc_arch.m4                                   |  8 ++---
 tools/depends/Makefile.include.in                 |  2 +-
 tools/depends/configure.ac                        | 38 ++++++++++++++++-------
 tools/depends/target/Toolchain.cmake.in           |  2 +-
 tools/depends/target/Toolchain_binaddons.cmake.in |  2 +-
 6 files changed, 44 insertions(+), 22 deletions(-)

diff --git a/configure.ac b/configure.ac
index b7b2a87..be28bf6 100644
--- a/configure.ac
+++ b/configure.ac
@@ -746,8 +746,17 @@ case $use_platform in
   raspberry-pi)
      target_platform=target_raspberry_pi
      use_neon=no
-     use_arch="arm"
      use_cpu=arm1176jzf-s
+     ;;
+  raspberry-pi2)
+     target_platform=target_raspberry_pi
+     use_neon=yes
+     use_cpu=cortex-a7
+     ;;
+esac
+
+if test "$target_platform" = "target_raspberry_pi" ; then
+     use_arch="arm"
      use_hardcoded_tables="yes"
      ARCH="arm"
      AC_DEFINE(HAS_EGLGLES, [1], [Define if supporting EGL based GLES Framebuffer])
@@ -755,8 +764,7 @@ case $use_platform in
      USE_MMAL=1; AC_DEFINE([HAS_MMAL],[1],["Define to 1 if MMAL libs is enabled"])
      CFLAGS="$CFLAGS"
      CXXFLAGS="$CXXFLAGS"
-     ;;
-esac
+fi
 
 XBMC_SETUP_ARCH_DEFINES()
 
diff --git a/m4/xbmc_arch.m4 b/m4/xbmc_arch.m4
index 0b66a82..adb8e97 100644
--- a/m4/xbmc_arch.m4
+++ b/m4/xbmc_arch.m4
@@ -77,9 +77,7 @@ if test "$target_platform" = "target_android" ; then
   AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_ANDROID")
 fi
 
-case $use_platform in
-  raspberry-pi)
-     AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -D_ARMEL -DTARGET_RASPBERRY_PI")
-     ;;
-esac
+if test "$target_platform" = "target_raspberry_pi" ; then
+  AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -D_ARMEL -DTARGET_RASPBERRY_PI")
+fi
 ])
diff --git a/tools/depends/Makefile.include.in b/tools/depends/Makefile.include.in
index e1ac05c..d60cccf 100644
--- a/tools/depends/Makefile.include.in
+++ b/tools/depends/Makefile.include.in
@@ -20,7 +20,7 @@ NATIVE_OS=@build_os@
 CROSS_COMPILING=@cross_compiling@
 ARCH_DEFINES=@ARCH_DEFINES@
 NATIVE_ARCH_DEFINES=@NATIVE_ARCH_DEFINES@
-TARGET_PLATFORM=@use_platform@
+TARGET_PLATFORM=@target_platform@
 XCODE_VERSION=@use_xcode@
 AAPT=@AAPT@
 DX=@DX@
diff --git a/tools/depends/configure.ac b/tools/depends/configure.ac
index 9435fca..4eff331 100644
--- a/tools/depends/configure.ac
+++ b/tools/depends/configure.ac
@@ -17,7 +17,8 @@ AC_ARG_WITH([toolchain],
 AC_ARG_WITH([platform],
   [AS_HELP_STRING([--with-platform],
   [target platform [auto]])],
-  [use_platform=$withval])
+  [use_platform=$withval],
+  [target_platform=$withval])
 
 AC_ARG_WITH([firmware],
   [AS_HELP_STRING([--with-firmware],
@@ -300,34 +301,49 @@ case $host in
     AC_MSG_ERROR(unsupported host ($use_host))
 esac
 
-if test "$use_platform" = "raspberry-pi"; then
+case $use_platform in
+  raspberry-pi)
+     target_platform=raspberry_pi
+     use_neon=no
+     use_cpu=arm1176jzf-s
+     platform_cflags="-mcpu=arm1176jzf-s -mtune=arm1176jzf-s -mfloat-abi=hard -mfpu=vfp"
+     platform_cxxflags="-mcpu=arm1176jzf-s -mtune=arm1176jzf-s -mfloat-abi=hard -mfpu=vfp"
+     platform_ldflags=""
+     ;;
+  raspberry-pi2)
+     target_platform=raspberry_pi
+     use_neon=yes
+     use_cpu=cortex-a7
+     platform_cflags="-fPIC -mcpu=cortex-a7 -mfloat-abi=hard -mfpu=neon-vfpv4"
+     platform_cxxflags="-fPIC -mcpu=cortex-a7 -mfloat-abi=hard -mfpu=neon-vfpv4"
+     platform_ldflags="-lpthread"
+     ;;
+esac
+
+if test "$target_platform" = "raspberry_pi" ; then
   if test -d "${use_firmware}/opt/vc/include"; then
     :
   else
     AC_MSG_ERROR([Raspberry Pi firmware not found])
   fi
-  use_neon=no
   use_arch="arm"
-  use_cpu="arm1176jzf-s"
   use_hardcoded_tables="yes"
-  use_alsa="no"
   ARCH="arm"
   platform_os="linux"
   cross_compiling="yes"
   use_host="arm-linux-gnueabihf"
   deps_dir="$use_host"
-  platform_cflags="-pipe -mcpu=arm1176jzf-s -mtune=arm1176jzf-s -mfloat-abi=hard \
-   -mfpu=vfp -mabi=aapcs-linux -Wno-psabi -Wa,-mno-warn-deprecated \
-   -Wno-deprecated-declarations -isystem${use_firmware}/opt/vc/include \
+  platform_cflags+=" -pipe -mabi=aapcs-linux -Wno-psabi \
+   -Wa,-mno-warn-deprecated -Wno-deprecated-declarations \
+   -isystem${use_firmware}/opt/vc/include \
    -isystem${use_firmware}/opt/vc/include/interface/vcos/pthreads \
    -isystem${use_firmware}/opt/vc/include/interface/vmcs_host/linux"
-  platform_cxxflags="-pipe -mcpu=arm1176jzf-s -mtune=arm1176jzf-s \
-   -mfloat-abi=hard -mfpu=vfp -mabi=aapcs-linux -Wno-psabi \
+  platform_cxxflags+=" -pipe -mabi=aapcs-linux -Wno-psabi \
    -Wa,-mno-warn-deprecated -Wno-deprecated-declarations \
    -isystem${use_firmware}/opt/vc/include \
    -isystem${use_firmware}/opt/vc/include/interface/vcos/pthreads \
    -isystem${use_firmware}/opt/vc/include/interface/vmcs_host/linux"
-  platform_ldflags="-L${use_firmware}/opt/vc/lib -lEGL -lGLESv2 -lbcm_host -lvcos \
+  platform_ldflags+=" -L${use_firmware}/opt/vc/lib -lEGL -lGLESv2 -lbcm_host -lvcos \
    -lvchiq_arm"
 fi
 
diff --git a/tools/depends/target/Toolchain.cmake.in b/tools/depends/target/Toolchain.cmake.in
index 943be73..59385e8 100644
--- a/tools/depends/target/Toolchain.cmake.in
+++ b/tools/depends/target/Toolchain.cmake.in
@@ -1,6 +1,6 @@
 SET(OS "@platform_os@")
 SET(CPU "@use_cpu@")
-SET(PLATFORM "@use_platform@")
+SET(PLATFORM "@target_platform@")
 IF("${OS}" STREQUAL "linux" OR "${OS}" STREQUAL "android")
 SET(CMAKE_SYSTEM_NAME Linux)
 ENDIF()
diff --git a/tools/depends/target/Toolchain_binaddons.cmake.in b/tools/depends/target/Toolchain_binaddons.cmake.in
index cdc2fe4..379bd1d 100644
--- a/tools/depends/target/Toolchain_binaddons.cmake.in
+++ b/tools/depends/target/Toolchain_binaddons.cmake.in
@@ -1,7 +1,7 @@
 set(CMAKE_SYSTEM_VERSION 1)
 set(OS "@platform_os@")
 set(CPU "@use_cpu@")
-set(PLATFORM "@use_platform@")
+set(PLATFORM "@target_platform@")
 if("${OS}" STREQUAL "linux" OR "${OS}" STREQUAL "android")
   set(CMAKE_SYSTEM_NAME Linux)
 endif()

From ae3bcf13b7c5e8f372410cea93f85fc44067d402 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 16 Apr 2014 21:18:06 +0100
Subject: [PATCH 61/89] [omxplayer] Don't propagate 3d flags based on supported
 3d modes

---
 xbmc/cores/omxplayer/OMXPlayerVideo.cpp | 29 +++--------------------------
 1 file changed, 3 insertions(+), 26 deletions(-)

diff --git a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
index 8becff1..86d97bd 100644
--- a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
@@ -763,40 +763,17 @@ void OMXPlayerVideo::ResolutionUpdateCallBack(uint32_t width, uint32_t height, f
   uint32_t video_width   = CDisplaySettings::Get().GetResolutionInfo(res).iScreenWidth;
   uint32_t video_height  = CDisplaySettings::Get().GetResolutionInfo(res).iScreenHeight;
 
-  unsigned flags = 0;
   ERenderFormat format = RENDER_FMT_BYPASS;
 
+  /* figure out steremode expected based on user settings and hints */
+  unsigned flags = GetStereoModeFlags(GetStereoMode());
+
   if(m_bAllowFullscreen)
   {
     flags |= CONF_FLAGS_FULLSCREEN;
     m_bAllowFullscreen = false; // only allow on first configure
   }
 
-  flags |= GetStereoModeFlags(GetStereoMode());
-
-  if(flags & CONF_FLAGS_STEREO_MODE_SBS)
-  {
-    if(g_Windowing.Support3D(video_width, video_height, D3DPRESENTFLAG_MODE3DSBS))
-      CLog::Log(LOGNOTICE, "3DSBS movie found");
-    else
-    {
-      flags &= ~CONF_FLAGS_STEREO_MODE_MASK(~0);
-      CLog::Log(LOGNOTICE, "3DSBS movie found but not supported");
-    }
-  }
-  else if(flags & CONF_FLAGS_STEREO_MODE_TAB)
-  {
-    if(g_Windowing.Support3D(video_width, video_height, D3DPRESENTFLAG_MODE3DTB))
-      CLog::Log(LOGNOTICE, "3DTB movie found");
-    else
-    {
-      flags &= ~CONF_FLAGS_STEREO_MODE_MASK(~0);
-      CLog::Log(LOGNOTICE, "3DTB movie found but not supported");
-    }
-  }
-  else
-    CLog::Log(LOGNOTICE, "not a 3D movie");
-
   unsigned int iDisplayWidth  = width;
   unsigned int iDisplayHeight = height;
 

From a969c6c631b7fbf6b9c246ed3152448df288339a Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 17 Apr 2014 13:01:51 +0100
Subject: [PATCH 62/89] [graphics] Allow switching to a more suitable 3D
 resolution

---
 xbmc/guilib/GraphicContext.cpp | 40 +++++++++++++++++++++++++++++++++++++++-
 xbmc/guilib/GraphicContext.h   |  1 +
 2 files changed, 40 insertions(+), 1 deletion(-)

diff --git a/xbmc/guilib/GraphicContext.cpp b/xbmc/guilib/GraphicContext.cpp
index 58406f7..a476cd8 100644
--- a/xbmc/guilib/GraphicContext.cpp
+++ b/xbmc/guilib/GraphicContext.cpp
@@ -35,6 +35,7 @@
 #include "utils/JobManager.h"
 #include "video/VideoReferenceClock.h"
 #include "cores/IPlayer.h"
+#include <float.h>
 
 using namespace std;
 
@@ -500,6 +501,43 @@ RESOLUTION CGraphicContext::GetVideoResolution() const
   return m_Resolution;
 }
 
+RESOLUTION CGraphicContext::Get3DVideoResolution(RESOLUTION resolution, RENDER_STEREO_MODE mode) const
+{
+  RESOLUTION best = resolution;
+  RESOLUTION_INFO curr = CDisplaySettings::Get().GetResolutionInfo(best);
+  // Find closest refresh rate
+  for (size_t i = (int)RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); i++)
+  {
+    const RESOLUTION_INFO info = CDisplaySettings::Get().GetResolutionInfo((RESOLUTION)i);
+
+    //discard resolutions that are not the same width and height (and interlaced/3D flags)
+    //or have a too low refreshrate
+    if (info.iScreenWidth  != curr.iScreenWidth
+    ||  info.iScreenHeight != curr.iScreenHeight
+    ||  info.iScreen       != curr.iScreen
+    ||  (info.dwFlags & D3DPRESENTFLAG_INTERLACED) != (curr.dwFlags & D3DPRESENTFLAG_INTERLACED)
+    ||  fabs(info.fRefreshRate - curr.fRefreshRate) >= FLT_EPSILON)
+      continue;
+
+    if (mode == RENDER_STEREO_MODE_SPLIT_VERTICAL && info.dwFlags & D3DPRESENTFLAG_MODE3DSBS)
+    {
+      best = (RESOLUTION)i;
+      break;
+    }
+    else if (mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL && info.dwFlags & D3DPRESENTFLAG_MODE3DTB)
+    {
+      best = (RESOLUTION)i;
+      break;
+    }
+    else if ((mode == RENDER_STEREO_MODE_OFF || mode == RENDER_STEREO_MODE_MONO) && !(info.dwFlags & (D3DPRESENTFLAG_MODE3DSBS|D3DPRESENTFLAG_MODE3DTB)))
+    {
+      best = (RESOLUTION)i;
+      break;
+    }
+  }
+  return best;
+}
+
 void CGraphicContext::ResetOverscan(RESOLUTION_INFO &res)
 {
   res.Overscan.left = 0;
@@ -1037,7 +1075,7 @@ void CGraphicContext::Flip(const CDirtyRegionList& dirty)
   if(m_stereoMode != m_nextStereoMode)
   {
     m_stereoMode = m_nextStereoMode;
-    SetVideoResolution(GetVideoResolution(), true);
+    SetVideoResolution(Get3DVideoResolution(m_Resolution, m_stereoMode), true);
     g_windowManager.SendMessage(GUI_MSG_NOTIFY_ALL, 0, 0, GUI_MSG_RENDERER_RESET);
   }
 }
diff --git a/xbmc/guilib/GraphicContext.h b/xbmc/guilib/GraphicContext.h
index 5c1501a..aba11cd 100644
--- a/xbmc/guilib/GraphicContext.h
+++ b/xbmc/guilib/GraphicContext.h
@@ -108,6 +108,7 @@ class CGraphicContext : public CCriticalSection,
   bool IsValidResolution(RESOLUTION res);
   void SetVideoResolution(RESOLUTION res, bool forceUpdate = false);
   RESOLUTION GetVideoResolution() const;
+  RESOLUTION Get3DVideoResolution(RESOLUTION resolution, RENDER_STEREO_MODE mode) const;
   void ResetOverscan(RESOLUTION res, OVERSCAN &overscan);
   void ResetOverscan(RESOLUTION_INFO &resinfo);
   void ResetScreenParameters(RESOLUTION res);

From eb7a1712a184b4d997998b97359d20d6a2ab95ac Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 17 Apr 2014 13:38:55 +0100
Subject: [PATCH 63/89] [3D] Support switching to 3D resolutions

Include matching 3D flags (SBS/TAB) in the score of a resolution to switch to, to enable switching to 3d modes.
Also remove the old code that treated 3D modes differently when assigning a score.
---
 xbmc/cores/VideoRenderers/BaseRenderer.cpp | 47 +++++++++++-------------------
 1 file changed, 17 insertions(+), 30 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/BaseRenderer.cpp b/xbmc/cores/VideoRenderers/BaseRenderer.cpp
index 4345c0f..cc5dc60 100644
--- a/xbmc/cores/VideoRenderers/BaseRenderer.cpp
+++ b/xbmc/cores/VideoRenderers/BaseRenderer.cpp
@@ -222,10 +222,14 @@ void CBaseRenderer::FindResolutionFromFpsMatch(float fps, float& weight)
 RESOLUTION CBaseRenderer::FindClosestResolution(float fps, float multiplier, RESOLUTION current, float& weight)
 {
   RESOLUTION_INFO curr = g_graphicsContext.GetResInfo(current);
+  unsigned int stereo_mode  = CONF_FLAGS_STEREO_MODE_MASK(m_iFlags);
 
   float fRefreshRate = fps;
 
-  float last_diff = fRefreshRate;
+  int c_weight = MathUtils::round_int(RefreshWeight(curr.fRefreshRate, fRefreshRate * multiplier) * 1000.0);
+  if (!(stereo_mode == CONF_FLAGS_STEREO_MODE_SBS) != !(curr.dwFlags & D3DPRESENTFLAG_MODE3DSBS) ||
+      !(stereo_mode == CONF_FLAGS_STEREO_MODE_TAB) != !(curr.dwFlags & D3DPRESENTFLAG_MODE3DTB))
+    c_weight += 1000;
 
   // Find closest refresh rate
   for (size_t i = (int)RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); i++)
@@ -241,40 +245,23 @@ RESOLUTION CBaseRenderer::FindClosestResolution(float fps, float multiplier, RES
     ||  info.fRefreshRate < (fRefreshRate * multiplier / 1.001) - 0.001)
       continue;
 
-    // For 3D choose the closest refresh rate 
-    if(CONF_FLAGS_STEREO_MODE_MASK(m_iFlags))
-    {
-      float diff = (info.fRefreshRate - fRefreshRate);
-      if(diff < 0)
-        diff *= -1.0f;
+    int i_weight = MathUtils::round_int(RefreshWeight(info.fRefreshRate, fRefreshRate * multiplier) * 1000.0);
 
-      if(diff < last_diff)
-      {
-        last_diff = diff;
-        current = (RESOLUTION)i;
-        curr = info;
-      }
-    }
-    else
-    {
-      int c_weight = MathUtils::round_int(RefreshWeight(curr.fRefreshRate, fRefreshRate * multiplier) * 1000.0);
-      int i_weight = MathUtils::round_int(RefreshWeight(info.fRefreshRate, fRefreshRate * multiplier) * 1000.0);
+    if (!(stereo_mode == CONF_FLAGS_STEREO_MODE_SBS) != !(info.dwFlags & D3DPRESENTFLAG_MODE3DSBS) ||
+        !(stereo_mode == CONF_FLAGS_STEREO_MODE_TAB) != !(info.dwFlags & D3DPRESENTFLAG_MODE3DTB))
+      i_weight += 1000;
 
-      // Closer the better, prefer higher refresh rate if the same
-      if ((i_weight <  c_weight)
-      ||  (i_weight == c_weight && info.fRefreshRate > curr.fRefreshRate))
-      {
-        current = (RESOLUTION)i;
-        curr    = info;
-      }
+    // Closer the better, prefer higher refresh rate if the same
+    if ((i_weight <  c_weight)
+    ||  (i_weight == c_weight && info.fRefreshRate > curr.fRefreshRate))
+    {
+      current  = (RESOLUTION)i;
+      curr     = info;
+      c_weight = i_weight;
     }
   }
 
-  // For 3D overwrite weight
-  if(CONF_FLAGS_STEREO_MODE_MASK(m_iFlags))
-    weight = 0;
-  else
-    weight = RefreshWeight(curr.fRefreshRate, fRefreshRate * multiplier);
+  weight = RefreshWeight(curr.fRefreshRate, fRefreshRate * multiplier);
 
   return current;
 }

From 776a7d653349f024a92f4ee065527cb558ad389c Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 23 Apr 2014 00:05:07 +0100
Subject: [PATCH 64/89] [graphics] Make pixel ratio for 3d modes consistent

Note: Use the stored stereo flags from lists of resolutions.
Use current stereo mode for current resolution.
---
 xbmc/cores/VideoRenderers/BaseRenderer.cpp      | 10 +++----
 xbmc/guilib/GraphicContext.cpp                  | 37 ++++++++++++-------------
 xbmc/guilib/GraphicContext.h                    | 12 ++++++--
 xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp |  8 ------
 4 files changed, 32 insertions(+), 35 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/BaseRenderer.cpp b/xbmc/cores/VideoRenderers/BaseRenderer.cpp
index cc5dc60..0c23290 100644
--- a/xbmc/cores/VideoRenderers/BaseRenderer.cpp
+++ b/xbmc/cores/VideoRenderers/BaseRenderer.cpp
@@ -119,7 +119,7 @@ bool CBaseRenderer::FindResolutionFromOverride(float fps, float& weight, bool fa
 
     for (size_t j = (int)RES_DESKTOP; j < CDisplaySettings::Get().ResolutionInfoSize(); j++)
     {
-      RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)j);
+      RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)j, g_graphicsContext.GetStereoMode((RESOLUTION)j));
 
       if (info.iScreenWidth  == curr.iScreenWidth
        && info.iScreenHeight == curr.iScreenHeight
@@ -179,7 +179,7 @@ void CBaseRenderer::FindResolutionFromFpsMatch(float fps, float& weight)
       //get the resolution with the refreshrate closest to 60 hertz
       for (size_t i = (int)RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); i++)
       {
-        RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)i);
+        RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)i, g_graphicsContext.GetStereoMode((RESOLUTION)i));
 
         if (MathUtils::round_int(info.fRefreshRate) == 60
          && info.iScreenWidth  == curr.iScreenWidth
@@ -200,7 +200,7 @@ void CBaseRenderer::FindResolutionFromFpsMatch(float fps, float& weight)
         CLog::Log(LOGDEBUG, "60 hertz refreshrate not available, choosing highest");
         for (size_t i = (int)RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); i++)
         {
-          RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)i);
+          RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)i, g_graphicsContext.GetStereoMode((RESOLUTION)i));
 
           if (info.fRefreshRate  >  curr.fRefreshRate
            && info.iScreenWidth  == curr.iScreenWidth
@@ -234,14 +234,14 @@ RESOLUTION CBaseRenderer::FindClosestResolution(float fps, float multiplier, RES
   // Find closest refresh rate
   for (size_t i = (int)RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); i++)
   {
-    const RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)i);
+    const RESOLUTION_INFO info = g_graphicsContext.GetResInfo((RESOLUTION)i, g_graphicsContext.GetStereoMode((RESOLUTION)i));
 
     //discard resolutions that are not the same width and height (and interlaced/3D flags)
     //or have a too low refreshrate
     if (info.iScreenWidth  != curr.iScreenWidth
     ||  info.iScreenHeight != curr.iScreenHeight
     ||  info.iScreen       != curr.iScreen
-    ||  (info.dwFlags & D3DPRESENTFLAG_MODEMASK) != (curr.dwFlags & D3DPRESENTFLAG_MODEMASK)
+    ||  (info.dwFlags & D3DPRESENTFLAG_INTERLACED) != (curr.dwFlags & D3DPRESENTFLAG_INTERLACED)
     ||  info.fRefreshRate < (fRefreshRate * multiplier / 1.001) - 0.001)
       continue;
 
diff --git a/xbmc/guilib/GraphicContext.cpp b/xbmc/guilib/GraphicContext.cpp
index a476cd8..9882935 100644
--- a/xbmc/guilib/GraphicContext.cpp
+++ b/xbmc/guilib/GraphicContext.cpp
@@ -747,32 +747,33 @@ void CGraphicContext::ApplyStateBlock()
   g_Windowing.ApplyStateBlock();
 }
 
-const RESOLUTION_INFO CGraphicContext::GetResInfo(RESOLUTION res) const
+RENDER_STEREO_MODE CGraphicContext::GetStereoMode(RESOLUTION res) const
 {
   RESOLUTION_INFO info = CDisplaySettings::Get().GetResolutionInfo(res);
+  return (info.dwFlags & D3DPRESENTFLAG_MODE3DTB)  ? RENDER_STEREO_MODE_SPLIT_HORIZONTAL :
+         (info.dwFlags & D3DPRESENTFLAG_MODE3DSBS) ? RENDER_STEREO_MODE_SPLIT_VERTICAL : RENDER_STEREO_MODE_OFF;
+}
 
-  if(m_stereoMode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
+const RESOLUTION_INFO CGraphicContext::GetResInfo(RESOLUTION res, RENDER_STEREO_MODE stereoMode) const
+{
+  RESOLUTION_INFO info = CDisplaySettings::Get().GetResolutionInfo(res);
+
+  if(stereoMode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
   {
-    if((info.dwFlags & D3DPRESENTFLAG_MODE3DTB) == 0)
-    {
-      info.fPixelRatio     /= 2;
-      info.iBlanking        = 0;
-      info.dwFlags         |= D3DPRESENTFLAG_MODE3DTB;
-    }
+    info.fPixelRatio     /= 2;
+    info.iBlanking        = 0;
+    info.dwFlags         |= D3DPRESENTFLAG_MODE3DTB;
     info.iHeight          = (info.iHeight         - info.iBlanking) / 2;
     info.Overscan.top    /= 2;
     info.Overscan.bottom  = (info.Overscan.bottom - info.iBlanking) / 2;
     info.iSubtitles       = (info.iSubtitles      - info.iBlanking) / 2;
   }
 
-  if(m_stereoMode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
+  if(stereoMode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
   {
-    if((info.dwFlags & D3DPRESENTFLAG_MODE3DSBS) == 0)
-    {
-      info.fPixelRatio     *= 2;
-      info.iBlanking        = 0;
-      info.dwFlags         |= D3DPRESENTFLAG_MODE3DSBS;
-    }
+    info.fPixelRatio     *= 2;
+    info.iBlanking        = 0;
+    info.dwFlags         |= D3DPRESENTFLAG_MODE3DSBS;
     info.iWidth           = (info.iWidth         - info.iBlanking) / 2;
     info.Overscan.left   /= 2;
     info.Overscan.right   = (info.Overscan.right - info.iBlanking) / 2;
@@ -790,16 +791,14 @@ void CGraphicContext::SetResInfo(RESOLUTION res, const RESOLUTION_INFO& info)
   if(info.dwFlags & D3DPRESENTFLAG_MODE3DSBS)
   {
     curr.Overscan.right  = info.Overscan.right  * 2 + info.iBlanking;
-    if((curr.dwFlags & D3DPRESENTFLAG_MODE3DSBS) == 0)
-      curr.fPixelRatio  /= 2.0;
+    curr.fPixelRatio  /= 2.0;
   }
 
   if(info.dwFlags & D3DPRESENTFLAG_MODE3DTB)
   {
     curr.Overscan.bottom = info.Overscan.bottom * 2 + info.iBlanking;
     curr.iSubtitles      = info.iSubtitles      * 2 + info.iBlanking;
-    if((curr.dwFlags & D3DPRESENTFLAG_MODE3DTB) == 0)
-      curr.fPixelRatio  *= 2.0;
+    curr.fPixelRatio  *= 2.0;
   }
 }
 
diff --git a/xbmc/guilib/GraphicContext.h b/xbmc/guilib/GraphicContext.h
index aba11cd..c84aed0 100644
--- a/xbmc/guilib/GraphicContext.h
+++ b/xbmc/guilib/GraphicContext.h
@@ -120,11 +120,15 @@ class CGraphicContext : public CCriticalSection,
   void GetAllowedResolutions(std::vector<RESOLUTION> &res);
 
   // output scaling
+  const RESOLUTION_INFO GetResInfo(RESOLUTION res) const
+  {
+    return GetResInfo(res, GetStereoMode());
+  }
   const RESOLUTION_INFO GetResInfo() const
   {
     return GetResInfo(m_Resolution);
   }
-  const RESOLUTION_INFO GetResInfo(RESOLUTION res) const;
+  const RESOLUTION_INFO GetResInfo(RESOLUTION res, RENDER_STEREO_MODE stereo_mode) const;
   void SetResInfo(RESOLUTION res, const RESOLUTION_INFO& info);
 
   /* \brief Get UI scaling information from a given resolution to the screen resolution.
@@ -161,9 +165,11 @@ class CGraphicContext : public CCriticalSection,
   void RestoreOrigin();
   void SetCameraPosition(const CPoint &camera);
   void SetStereoView(RENDER_STEREO_VIEW view);
-  RENDER_STEREO_VIEW GetStereoView()  { return m_stereoView; }
+  RENDER_STEREO_VIEW GetStereoView() const { return m_stereoView; }
   void SetStereoMode(RENDER_STEREO_MODE mode) { m_nextStereoMode = mode; }
-  RENDER_STEREO_MODE GetStereoMode()  { return m_stereoMode; }
+  RENDER_STEREO_MODE GetStereoMode() const { return m_stereoMode; }
+  RENDER_STEREO_MODE GetStereoMode(RESOLUTION res) const;
+
   void RestoreCameraPosition();
   /*! \brief Set a region in which to clip all rendering
    Anything that is rendered after setting a clip region will be clipped so that no part renders
diff --git a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
index d388373..ba14e40 100644
--- a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
@@ -546,15 +546,9 @@ bool CEGLNativeTypeRaspberryPI::ProbeResolutions(std::vector<RESOLUTION_INFO> &r
       m_desktopRes.fPixelRatio  = tv_state.display.hdmi.display_options.aspect == 0 ? 1.0f : get_display_aspect_ratio((HDMI_ASPECT_T)tv_state.display.hdmi.display_options.aspect) / ((float)m_desktopRes.iScreenWidth / (float)m_desktopRes.iScreenHeight);
       // Also add 3D flags
       if (tv_state.display.hdmi.format_3d == HDMI_3D_FORMAT_SBS_HALF)
-      {
         m_desktopRes.dwFlags |= D3DPRESENTFLAG_MODE3DSBS;
-        m_desktopRes.fPixelRatio *= 2.0;
-      }
       else if (tv_state.display.hdmi.format_3d == HDMI_3D_FORMAT_TB_HALF)
-      {
         m_desktopRes.dwFlags |= D3DPRESENTFLAG_MODE3DTB;
-        m_desktopRes.fPixelRatio *= 0.5;
-      }
       HDMI_PROPERTY_PARAM_T property;
       property.property = HDMI_PROPERTY_PIXEL_CLOCK_TYPE;
       vc_tv_hdmi_get_property(&property);
@@ -694,7 +688,6 @@ void CEGLNativeTypeRaspberryPI::GetSupportedModes(HDMI_RES_GROUP_T group, std::v
         RESOLUTION_INFO res2 = res;
         res2.dwFlags |= D3DPRESENTFLAG_MODE3DSBS;
         res2.fPixelRatio    = get_display_aspect_ratio((HDMI_ASPECT_T)tv->aspect_ratio) / ((float)res2.iScreenWidth / (float)res2.iScreenHeight);
-        res2.fPixelRatio   *= 2.0f;
         res2.iSubtitles    = (int)(0.965 * res2.iHeight);
 
         AddUniqueResolution(res2, resolutions);
@@ -710,7 +703,6 @@ void CEGLNativeTypeRaspberryPI::GetSupportedModes(HDMI_RES_GROUP_T group, std::v
         RESOLUTION_INFO res2 = res;
         res2.dwFlags |= D3DPRESENTFLAG_MODE3DTB;
         res2.fPixelRatio    = get_display_aspect_ratio((HDMI_ASPECT_T)tv->aspect_ratio) / ((float)res2.iScreenWidth / (float)res2.iScreenHeight);
-        res2.fPixelRatio   *= 0.5f;
         res2.iSubtitles    = (int)(0.965 * res2.iHeight);
 
         AddUniqueResolution(res2, resolutions);

From d341efba61fba5ce9738b208a23fdb4cb4b95e96 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 10 Mar 2015 17:05:18 +0000
Subject: [PATCH 65/89] [players] Add settings option to enable MVC support

---
 addons/resource.language.en_gb/resources/strings.po | 10 ++++++++++
 system/settings/rbp.xml                             | 10 ++++++++++
 xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp  |  5 +++++
 xbmc/cores/omxplayer/OMXVideo.cpp                   |  5 +++++
 4 files changed, 30 insertions(+)

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index bf466b0..d45f05d 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -16667,6 +16667,16 @@ msgctxt "#38102"
 msgid "%i ms"
 msgstr ""
 
+#: system/settings/rbp.xml
+msgctxt "#38110"
+msgid "Support MVC video (full frame 3D)"
+msgstr ""
+
+#: system/settings/rbp.xml
+msgctxt "#38111"
+msgid "This option decodes frames for both eyes of MVC video. Disabling may improve performance if you don't require 3D"
+msgstr ""
+
 #: system/settings/settings.xml
 msgctxt "#38103"
 msgid "Extract thumbnails from video files"
diff --git a/system/settings/rbp.xml b/system/settings/rbp.xml
index 6e9ceaf..ed61ca6 100644
--- a/system/settings/rbp.xml
+++ b/system/settings/rbp.xml
@@ -30,6 +30,16 @@
           <control type="edit" format="integer" />
         </setting>
       </group>
+      <group id="3">
+        <setting id="videoplayer.supportmvc" type="boolean" label="38110" help="38111">
+          <dependencies>
+            <dependency type="enable" setting="videoplayer.decodingmethod" operator="is">1</dependency>
+          </dependencies>
+          <level>2</level>
+          <default>true</default>
+          <control type="toggle" />
+        </setting>
+      </group>
     </category>
     <category id="myvideos">
       <group id="1">
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
index df282f3..9e0aa66 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
@@ -549,6 +549,11 @@ bool CMMALVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, MMALVide
       // H.264
       m_codingType = MMAL_ENCODING_H264;
       m_pFormatName = "mmal-h264";
+      if (CSettings::Get().GetBool("videoplayer.supportmvc"))
+      {
+        m_codingType = MMAL_ENCODING_MVC;
+        m_pFormatName= "mmal-mvc";
+      }
     break;
     case AV_CODEC_ID_H263:
     case AV_CODEC_ID_MPEG4:
diff --git a/xbmc/cores/omxplayer/OMXVideo.cpp b/xbmc/cores/omxplayer/OMXVideo.cpp
index ca40a37..ec8fe9c 100644
--- a/xbmc/cores/omxplayer/OMXVideo.cpp
+++ b/xbmc/cores/omxplayer/OMXVideo.cpp
@@ -430,6 +430,11 @@ bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, EDEINTERLACEMODE de
           break;
       }
     }
+    if (CSettings::Get().GetBool("videoplayer.supportmvc"))
+    {
+      m_codingType = OMX_VIDEO_CodingMVC;
+      m_video_codec_name = "omx-mvc";
+    }
     break;
     case AV_CODEC_ID_MPEG4:
       // (role name) video_decoder.mpeg4

From 6802d4a755bb5609e27a797242b7f858d722716a Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Sat, 14 Mar 2015 12:38:08 +0000
Subject: [PATCH 66/89] [mmalrenderer] Switch to using transform flags for 3d
 modes

---
 .../resource.language.en_gb/resources/strings.po   | 10 +++
 system/settings/rbp.xml                            |  8 ++
 xbmc/cores/VideoRenderers/MMALRenderer.cpp         | 92 ++++++----------------
 xbmc/cores/omxplayer/OMXPlayerVideo.cpp            | 46 ++---------
 xbmc/cores/omxplayer/OMXVideo.cpp                  | 36 ++++-----
 xbmc/cores/omxplayer/OMXVideo.h                    |  2 +-
 xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp    | 11 ++-
 7 files changed, 75 insertions(+), 130 deletions(-)

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index d45f05d..bce7527 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -16677,6 +16677,16 @@ msgctxt "#38111"
 msgid "This option decodes frames for both eyes of MVC video. Disabling may improve performance if you don't require 3D"
 msgstr ""
 
+#: system/settings/rbp.xml
+msgctxt "#38112"
+msgid "Use Full HD HDMI modes for 3D"
+msgstr ""
+
+#: system/settings/rbp.xml
+msgctxt "#38113"
+msgid "This option uses frame-packing to output full resolution for 3D through HDMI"
+msgstr ""
+
 #: system/settings/settings.xml
 msgctxt "#38103"
 msgid "Extract thumbnails from video files"
diff --git a/system/settings/rbp.xml b/system/settings/rbp.xml
index ed61ca6..42d4da7 100644
--- a/system/settings/rbp.xml
+++ b/system/settings/rbp.xml
@@ -39,6 +39,14 @@
           <default>true</default>
           <control type="toggle" />
         </setting>
+        <setting id="videoplayer.framepacking" type="boolean" label="38112" help="38113">
+          <dependencies>
+            <dependency type="enable" setting="videoplayer.supportmvc">true</dependency>
+          </dependencies>
+          <level>2</level>
+          <default>true</default>
+          <control type="toggle" />
+        </setting>
       </group>
     </category>
     <category id="myvideos">
diff --git a/xbmc/cores/VideoRenderers/MMALRenderer.cpp b/xbmc/cores/VideoRenderers/MMALRenderer.cpp
index d53de35..c30de9c 100644
--- a/xbmc/cores/VideoRenderers/MMALRenderer.cpp
+++ b/xbmc/cores/VideoRenderers/MMALRenderer.cpp
@@ -351,11 +351,7 @@ void CMMALRenderer::RenderUpdate(bool clear, DWORD flags, DWORD alpha)
 
   if (!m_bConfigured) return;
 
-  if (g_graphicsContext.GetStereoMode())
-    g_graphicsContext.SetStereoView(RENDER_STEREO_VIEW_LEFT);
   ManageDisplay();
-  if (g_graphicsContext.GetStereoMode())
-    g_graphicsContext.SetStereoView(RENDER_STEREO_VIEW_OFF);
 
   // if running bypass, then the player might need the src/dst rects
   // for sizing video playback on a layer other than the gles layer.
@@ -560,9 +556,7 @@ EINTERLACEMETHOD CMMALRenderer::AutoInterlaceMethod()
 
 void CMMALRenderer::SetVideoRect(const CRect& InSrcRect, const CRect& InDestRect)
 {
-  // we get called twice a frame for left/right. Can ignore the rights.
-  if (g_graphicsContext.GetStereoView() == RENDER_STEREO_VIEW_RIGHT)
-    return;
+  assert(g_graphicsContext.GetStereoView() != RENDER_STEREO_VIEW_RIGHT);
 
   if (!m_vout_input)
     return;
@@ -604,41 +598,10 @@ void CMMALRenderer::SetVideoRect(const CRect& InSrcRect, const CRect& InDestRect
   CRect gui(0, 0, CDisplaySettings::Get().GetResolutionInfo(res).iWidth, CDisplaySettings::Get().GetResolutionInfo(res).iHeight);
   CRect display(0, 0, CDisplaySettings::Get().GetResolutionInfo(res).iScreenWidth, CDisplaySettings::Get().GetResolutionInfo(res).iScreenHeight);
 
-  if (display_stereo_mode != RENDER_STEREO_MODE_OFF && display_stereo_mode != RENDER_STEREO_MODE_MONO)
-  switch (video_stereo_mode)
-  {
-  case RENDER_STEREO_MODE_SPLIT_VERTICAL:
-    // optimisation - use simpler display mode in common case of unscaled 3d with same display mode
-    if (video_stereo_mode == display_stereo_mode && DestRect.x1 == 0.0f && DestRect.x2 * 2.0f == gui.Width() && !stereo_invert)
-    {
-      SrcRect.x2 *= 2.0f;
-      DestRect.x2 *= 2.0f;
-      video_stereo_mode = RENDER_STEREO_MODE_OFF;
-      display_stereo_mode = RENDER_STEREO_MODE_OFF;
-    }
-    else if (display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_RED_CYAN || display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_GREEN_MAGENTA || display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_YELLOW_BLUE)
-    {
-      SrcRect.x2 *= 2.0f;
-    }
-    break;
-
-  case RENDER_STEREO_MODE_SPLIT_HORIZONTAL:
-    // optimisation - use simpler display mode in common case of unscaled 3d with same display mode
-    if (video_stereo_mode == display_stereo_mode && DestRect.y1 == 0.0f && DestRect.y2 * 2.0f == gui.Height() && !stereo_invert)
-    {
-      SrcRect.y2 *= 2.0f;
-      DestRect.y2 *= 2.0f;
-      video_stereo_mode = RENDER_STEREO_MODE_OFF;
-      display_stereo_mode = RENDER_STEREO_MODE_OFF;
-    }
-    else if (display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_RED_CYAN || display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_GREEN_MAGENTA || display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_YELLOW_BLUE)
-    {
-      SrcRect.y2 *= 2.0f;
-    }
-    break;
-
-  default: break;
-  }
+  if (display_stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
+    DestRect.x2 *= 2.0f;
+  else if (display_stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
+    DestRect.y2 *= 2.0f;
 
   if (gui != display)
   {
@@ -653,7 +616,7 @@ void CMMALRenderer::SetVideoRect(const CRect& InSrcRect, const CRect& InDestRect
   MMAL_DISPLAYREGION_T region;
   memset(&region, 0, sizeof region);
 
-  region.set                 = MMAL_DISPLAY_SET_DEST_RECT|MMAL_DISPLAY_SET_SRC_RECT|MMAL_DISPLAY_SET_FULLSCREEN|MMAL_DISPLAY_SET_NOASPECT|MMAL_DISPLAY_SET_MODE;
+  region.set                 = MMAL_DISPLAY_SET_DEST_RECT|MMAL_DISPLAY_SET_SRC_RECT|MMAL_DISPLAY_SET_FULLSCREEN|MMAL_DISPLAY_SET_NOASPECT|MMAL_DISPLAY_SET_MODE|MMAL_DISPLAY_SET_TRANSFORM;
   region.dest_rect.x         = lrintf(DestRect.x1);
   region.dest_rect.y         = lrintf(DestRect.y1);
   region.dest_rect.width     = lrintf(DestRect.Width());
@@ -666,35 +629,32 @@ void CMMALRenderer::SetVideoRect(const CRect& InSrcRect, const CRect& InDestRect
 
   region.fullscreen = MMAL_FALSE;
   region.noaspect = MMAL_TRUE;
+  region.mode = MMAL_DISPLAY_MODE_LETTERBOX;
+
+  if (m_renderOrientation == 90)
+    region.transform = MMAL_DISPLAY_ROT90;
+  else if (m_renderOrientation == 180)
+    region.transform = MMAL_DISPLAY_ROT180;
+  else if (m_renderOrientation == 270)
+    region.transform = MMAL_DISPLAY_ROT270;
+  else
+    region.transform = MMAL_DISPLAY_ROT0;
 
-  if (m_renderOrientation)
-  {
-    region.set |= MMAL_DISPLAY_SET_TRANSFORM;
-    if (m_renderOrientation == 90)
-      region.transform = MMAL_DISPLAY_ROT90;
-    else if (m_renderOrientation == 180)
-      region.transform = MMAL_DISPLAY_ROT180;
-    else if (m_renderOrientation == 270)
-      region.transform = MMAL_DISPLAY_ROT270;
-    else assert(0);
-  }
-
-  if (video_stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL && display_stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
-    region.mode = MMAL_DISPLAY_MODE_STEREO_TOP_TO_TOP;
-  else if (video_stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL && display_stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
-    region.mode = MMAL_DISPLAY_MODE_STEREO_TOP_TO_LEFT;
-  else if (video_stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL && display_stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
-    region.mode = MMAL_DISPLAY_MODE_STEREO_LEFT_TO_TOP;
-  else if (video_stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL && display_stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
-    region.mode = MMAL_DISPLAY_MODE_STEREO_LEFT_TO_LEFT;
+  if (m_video_stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
+    region.transform = (MMAL_DISPLAYTRANSFORM_T)(region.transform | DISPMANX_STEREOSCOPIC_TB);
+  else if (m_video_stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
+    region.transform = (MMAL_DISPLAYTRANSFORM_T)(region.transform | DISPMANX_STEREOSCOPIC_SBS);
   else
-    region.mode = MMAL_DISPLAY_MODE_LETTERBOX;
+    region.transform = (MMAL_DISPLAYTRANSFORM_T)(region.transform | DISPMANX_STEREOSCOPIC_MONO);
+
+  if (m_StereoInvert)
+    region.transform = (MMAL_DISPLAYTRANSFORM_T)(region.transform | DISPMANX_STEREOSCOPIC_INVERT);
 
   MMAL_STATUS_T status = mmal_util_set_display_region(m_vout_input, &region);
   if (status != MMAL_SUCCESS)
     CLog::Log(LOGERROR, "%s::%s Failed to set display region (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
 
-  CLog::Log(LOGDEBUG, "%s::%s %d,%d,%d,%d -> %d,%d,%d,%d mode:%d", CLASSNAME, __func__,
+  CLog::Log(LOGDEBUG, "%s::%s %d,%d,%d,%d -> %d,%d,%d,%d t:%x", CLASSNAME, __func__,
       region.src_rect.x, region.src_rect.y, region.src_rect.width, region.src_rect.height,
-      region.dest_rect.x, region.dest_rect.y, region.dest_rect.width, region.dest_rect.height, region.mode);
+      region.dest_rect.x, region.dest_rect.y, region.dest_rect.width, region.dest_rect.height, region.transform);
 }
diff --git a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
index 86d97bd..018e65f 100644
--- a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
@@ -660,9 +660,7 @@ int OMXPlayerVideo::GetFreeSpace()
 
 void OMXPlayerVideo::SetVideoRect(const CRect &InSrcRect, const CRect &InDestRect)
 {
-  // we get called twice a frame for left/right. Can ignore the rights.
-  if (g_graphicsContext.GetStereoView() == RENDER_STEREO_VIEW_RIGHT)
-    return;
+  assert(g_graphicsContext.GetStereoView() != RENDER_STEREO_VIEW_RIGHT);
 
   CRect SrcRect = InSrcRect, DestRect = InDestRect;
   unsigned flags = GetStereoModeFlags(GetStereoMode());
@@ -702,42 +700,10 @@ void OMXPlayerVideo::SetVideoRect(const CRect &InSrcRect, const CRect &InDestRec
   CRect gui(0, 0, CDisplaySettings::Get().GetResolutionInfo(res).iWidth, CDisplaySettings::Get().GetResolutionInfo(res).iHeight);
   CRect display(0, 0, CDisplaySettings::Get().GetResolutionInfo(res).iScreenWidth, CDisplaySettings::Get().GetResolutionInfo(res).iScreenHeight);
 
-  switch (video_stereo_mode)
-  {
-  case RENDER_STEREO_MODE_SPLIT_VERTICAL:
-    // optimisation - use simpler display mode in common case of unscaled 3d with same display mode
-    if (video_stereo_mode == display_stereo_mode && DestRect.x1 == 0.0f && DestRect.x2 * 2.0f == gui.Width() && !stereo_invert)
-    {
-      SrcRect.x2 *= 2.0f;
-      DestRect.x2 *= 2.0f;
-      video_stereo_mode = RENDER_STEREO_MODE_OFF;
-      display_stereo_mode = RENDER_STEREO_MODE_OFF;
-    }
-    else if (stereo_invert)
-    {
-      SrcRect.x1 += m_hints.width / 2;
-      SrcRect.x2 += m_hints.width / 2;
-    }
-    break;
-
-  case RENDER_STEREO_MODE_SPLIT_HORIZONTAL:
-    // optimisation - use simpler display mode in common case of unscaled 3d with same display mode
-    if (video_stereo_mode == display_stereo_mode && DestRect.y1 == 0.0f && DestRect.y2 * 2.0f == gui.Height() && !stereo_invert)
-    {
-      SrcRect.y2 *= 2.0f;
-      DestRect.y2 *= 2.0f;
-      video_stereo_mode = RENDER_STEREO_MODE_OFF;
-      display_stereo_mode = RENDER_STEREO_MODE_OFF;
-    }
-    else if (stereo_invert)
-    {
-      SrcRect.y1 += m_hints.height / 2;
-      SrcRect.y2 += m_hints.height / 2;
-    }
-    break;
-
-  default: break;
-  }
+  if (display_stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
+    DestRect.x2 *= 2.0f;
+  else if (display_stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
+    DestRect.y2 *= 2.0f;
 
   if (gui != display)
   {
@@ -748,7 +714,7 @@ void OMXPlayerVideo::SetVideoRect(const CRect &InSrcRect, const CRect &InDestRec
     DestRect.y1 *= yscale;
     DestRect.y2 *= yscale;
   }
-  m_omxVideo.SetVideoRect(SrcRect, DestRect, video_stereo_mode, display_stereo_mode);
+  m_omxVideo.SetVideoRect(SrcRect, DestRect, m_video_stereo_mode, m_display_stereo_mode, m_StereoInvert);
 }
 
 void OMXPlayerVideo::RenderUpdateCallBack(const void *ctx, const CRect &SrcRect, const CRect &DestRect)
diff --git a/xbmc/cores/omxplayer/OMXVideo.cpp b/xbmc/cores/omxplayer/OMXVideo.cpp
index ec8fe9c..3f37d44 100644
--- a/xbmc/cores/omxplayer/OMXVideo.cpp
+++ b/xbmc/cores/omxplayer/OMXVideo.cpp
@@ -220,15 +220,6 @@ bool COMXVideo::PortSettingsChanged()
   OMX_INIT_STRUCTURE(configDisplay);
   configDisplay.nPortIndex = m_omx_render.GetInputPort();
 
-  configDisplay.set = OMX_DISPLAY_SET_TRANSFORM;
-  configDisplay.transform = m_transform;
-  omx_err = m_omx_render.SetConfig(OMX_IndexConfigDisplayRegion, &configDisplay);
-  if(omx_err != OMX_ErrorNone)
-  {
-    CLog::Log(LOGWARNING, "%s::%s - could not set transform : %d", CLASSNAME, __func__, m_transform);
-    return false;
-  }
-
   if(m_hdmi_clock_sync)
   {
     OMX_CONFIG_LATENCYTARGETTYPE latencyTarget;
@@ -860,7 +851,7 @@ void COMXVideo::Reset(void)
 }
 
 ///////////////////////////////////////////////////////////////////////////////////////////
-void COMXVideo::SetVideoRect(const CRect& SrcRect, const CRect& DestRect, RENDER_STEREO_MODE video_mode, RENDER_STEREO_MODE display_mode)
+void COMXVideo::SetVideoRect(const CRect& SrcRect, const CRect& DestRect, RENDER_STEREO_MODE video_mode, RENDER_STEREO_MODE display_mode, bool stereo_invert)
 {
   CSingleLock lock (m_critSection);
   if(!m_is_open)
@@ -870,7 +861,7 @@ void COMXVideo::SetVideoRect(const CRect& SrcRect, const CRect& DestRect, RENDER
 
   OMX_INIT_STRUCTURE(configDisplay);
   configDisplay.nPortIndex = m_omx_render.GetInputPort();
-  configDisplay.set                 = (OMX_DISPLAYSETTYPE)(OMX_DISPLAY_SET_DEST_RECT|OMX_DISPLAY_SET_SRC_RECT|OMX_DISPLAY_SET_FULLSCREEN|OMX_DISPLAY_SET_NOASPECT|OMX_DISPLAY_SET_MODE);
+  configDisplay.set                 = (OMX_DISPLAYSETTYPE)(OMX_DISPLAY_SET_DEST_RECT|OMX_DISPLAY_SET_SRC_RECT|OMX_DISPLAY_SET_FULLSCREEN|OMX_DISPLAY_SET_NOASPECT|OMX_DISPLAY_SET_MODE|OMX_DISPLAY_SET_TRANSFORM);
   configDisplay.dest_rect.x_offset  = lrintf(DestRect.x1);
   configDisplay.dest_rect.y_offset  = lrintf(DestRect.y1);
   configDisplay.dest_rect.width     = lrintf(DestRect.Width());
@@ -883,23 +874,24 @@ void COMXVideo::SetVideoRect(const CRect& SrcRect, const CRect& DestRect, RENDER
 
   configDisplay.fullscreen = OMX_FALSE;
   configDisplay.noaspect = OMX_TRUE;
+  configDisplay.mode = OMX_DISPLAY_MODE_LETTERBOX;
+  configDisplay.transform = m_transform;
 
-  if (video_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL && display_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
-    configDisplay.mode = OMX_DISPLAY_MODE_STEREO_TOP_TO_TOP;
-  else if (video_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL && display_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
-    configDisplay.mode = OMX_DISPLAY_MODE_STEREO_TOP_TO_LEFT;
-  else if (video_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL && display_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
-    configDisplay.mode = OMX_DISPLAY_MODE_STEREO_LEFT_TO_TOP;
-  else if (video_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL && display_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
-    configDisplay.mode = OMX_DISPLAY_MODE_STEREO_LEFT_TO_LEFT;
+  if (video_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
+    configDisplay.transform = (OMX_DISPLAYTRANSFORMTYPE)(configDisplay.transform | DISPMANX_STEREOSCOPIC_TB);
+  else if (video_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
+    configDisplay.transform = (OMX_DISPLAYTRANSFORMTYPE)(configDisplay.transform | DISPMANX_STEREOSCOPIC_SBS);
   else
-    configDisplay.mode = OMX_DISPLAY_MODE_LETTERBOX;
+    configDisplay.transform = (OMX_DISPLAYTRANSFORMTYPE)(configDisplay.transform | DISPMANX_STEREOSCOPIC_MONO);
+
+  if (stereo_invert)
+    configDisplay.transform = (OMX_DISPLAYTRANSFORMTYPE)(configDisplay.transform | DISPMANX_STEREOSCOPIC_INVERT);
 
   m_omx_render.SetConfig(OMX_IndexConfigDisplayRegion, &configDisplay);
 
-  CLog::Log(LOGDEBUG, "%s::%s %d,%d,%d,%d -> %d,%d,%d,%d mode:%d", CLASSNAME, __func__,
+  CLog::Log(LOGDEBUG, "%s::%s %d,%d,%d,%d -> %d,%d,%d,%d t:%x", CLASSNAME, __func__,
       configDisplay.src_rect.x_offset, configDisplay.src_rect.y_offset, configDisplay.src_rect.width, configDisplay.src_rect.height,
-      configDisplay.dest_rect.x_offset, configDisplay.dest_rect.y_offset, configDisplay.dest_rect.width, configDisplay.dest_rect.height, configDisplay.mode);
+      configDisplay.dest_rect.x_offset, configDisplay.dest_rect.y_offset, configDisplay.dest_rect.width, configDisplay.dest_rect.height, configDisplay.transform);
 }
 
 int COMXVideo::GetInputBufferSize()
diff --git a/xbmc/cores/omxplayer/OMXVideo.h b/xbmc/cores/omxplayer/OMXVideo.h
index 9f26427..3ea02dc 100644
--- a/xbmc/cores/omxplayer/OMXVideo.h
+++ b/xbmc/cores/omxplayer/OMXVideo.h
@@ -59,7 +59,7 @@ class COMXVideo
   void Reset(void);
   void SetDropState(bool bDrop);
   std::string GetDecoderName() { return m_video_codec_name; };
-  void SetVideoRect(const CRect& SrcRect, const CRect& DestRect, RENDER_STEREO_MODE video_mode, RENDER_STEREO_MODE display_mode);
+  void SetVideoRect(const CRect& SrcRect, const CRect& DestRect, RENDER_STEREO_MODE video_mode, RENDER_STEREO_MODE display_mode, bool stereo_invert);
   int GetInputBufferSize();
   bool GetPlayerInfo(double &match, double &phase, double &pll);
   void SubmitEOS();
diff --git a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
index ba14e40..10a0409 100644
--- a/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
@@ -284,7 +284,9 @@ bool CEGLNativeTypeRaspberryPI::SetNativeResolution(const RESOLUTION_INFO &res)
       /* inform TV of any 3D settings. Note this property just applies to next hdmi mode change, so no need to call for 2D modes */
       HDMI_PROPERTY_PARAM_T property;
       property.property = HDMI_PROPERTY_3D_STRUCTURE;
-      if (res.dwFlags & D3DPRESENTFLAG_MODE3DSBS)
+      if (CSettings::Get().GetBool("videoplayer.framepacking"))
+        property.param1 = HDMI_3D_FORMAT_FRAME_PACKING;
+      else if (res.dwFlags & D3DPRESENTFLAG_MODE3DSBS)
         property.param1 = HDMI_3D_FORMAT_SBS_HALF;
       else if (res.dwFlags & D3DPRESENTFLAG_MODE3DTB)
         property.param1 = HDMI_3D_FORMAT_TB_HALF;
@@ -384,6 +386,13 @@ bool CEGLNativeTypeRaspberryPI::SetNativeResolution(const RESOLUTION_INFO &res)
   DISPMANX_TRANSFORM_T transform = DISPMANX_NO_ROTATE;
   DISPMANX_UPDATE_HANDLE_T dispman_update = m_DllBcmHost->vc_dispmanx_update_start(0);
 
+  if (res.dwFlags & D3DPRESENTFLAG_MODE3DSBS)
+    transform = DISPMANX_STEREOSCOPIC_SBS;
+  else if (res.dwFlags & D3DPRESENTFLAG_MODE3DTB)
+    transform = DISPMANX_STEREOSCOPIC_TB;
+  else
+    transform = DISPMANX_STEREOSCOPIC_MONO;
+
   CLog::Log(LOGDEBUG, "EGL set resolution %dx%d -> %dx%d @ %.2f fps (%d,%d) flags:%x aspect:%.2f\n",
       m_width, m_height, dst_rect.width, dst_rect.height, res.fRefreshRate, GETFLAGS_GROUP(res.dwFlags), GETFLAGS_MODE(res.dwFlags), (int)res.dwFlags, res.fPixelRatio);
 

From 3531e8d698ce4d38ce16c7697f6a5111563a9238 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 17 Mar 2015 20:33:54 +0000
Subject: [PATCH 67/89] alsa: enable-shared is required

---
 tools/depends/target/alsa-lib/Makefile | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/tools/depends/target/alsa-lib/Makefile b/tools/depends/target/alsa-lib/Makefile
index b03fc19..a04d933 100644
--- a/tools/depends/target/alsa-lib/Makefile
+++ b/tools/depends/target/alsa-lib/Makefile
@@ -19,7 +19,7 @@ CONFIGURE=cp -f $(CONFIG_SUB) $(CONFIG_GUESS) .; \
           --with-ctl-plugins=ext \
           --with-pcm-plugins="copy,linear,route,mulaw,alaw,adpcm,rate,plug,multi,file,null,empty,share,meter,hooks,lfloat,ladspa,asym,iec958,softvol,extplug,ioplug,mmap_emul" \
           --disable-resmgr --enable-aload --enable-mixer  --enable-pcm  --disable-rawmidi  --enable-hwdep  --disable-seq  --disable-alisp  --disable-old-symbols --disable-python \
-          --with-softfloat=yes --with-libdl=yes --with-pthread=yes --with-librt=no --disable-shared \
+          --with-softfloat=yes --with-libdl=yes --with-pthread=yes --with-librt=no --enable-shared \
 
 LIBDYLIB=$(PLATFORM)/src/.libs/$(LIBNAME).a
 

From 63a3a45ee208669b1b74a4f88aa9802ab5bf6c49 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 31 Mar 2015 17:31:47 +0100
Subject: [PATCH 70/89] [mmalrenderer] Add SetCodecControl function and prefer
 to return pictures when renderer is low (disabled)

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMMAL.cpp |  5 +++++
 xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMMAL.h   |  1 +
 xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp         | 12 ++++++++++++
 xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h           |  2 ++
 4 files changed, 20 insertions(+)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMMAL.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMMAL.cpp
index 262283d..ee7d6f2 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMMAL.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMMAL.cpp
@@ -96,6 +96,11 @@ bool CDVDVideoCodecMMAL::GetCodecStats(double &pts, int &droppedPics)
   return m_decoder->GetCodecStats(pts, droppedPics);
 }
 
+void CDVDVideoCodecMMAL::SetCodecControl(int flags)
+{
+  m_decoder->SetCodecControl(flags);
+}
+
 void CDVDVideoCodecMMAL::SetSpeed(int iSpeed)
 {
   m_decoder->SetSpeed(iSpeed);
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMMAL.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMMAL.h
index a768e70..aa8e87f 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMMAL.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMMAL.h
@@ -42,6 +42,7 @@ class CDVDVideoCodecMMAL : public CDVDVideoCodec
   virtual void SetDropState(bool bDrop);
   virtual const char* GetName(void);
   virtual bool GetCodecStats(double &pts, int &droppedPics);
+  virtual void SetCodecControl(int flags);
   virtual void SetSpeed(int iSpeed);
 
 protected:
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
index 9e0aa66..1e711b4 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
@@ -128,6 +128,7 @@ CMMALVideo::CMMALVideo()
   m_es_format = mmal_format_alloc();
   m_preroll = true;
   m_speed = DVD_PLAYSPEED_NORMAL;
+  m_codecControlFlags = 0;
 }
 
 CMMALVideo::~CMMALVideo()
@@ -944,6 +945,9 @@ int CMMALVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
     if (g_advancedSettings.CanLogComponent(LOGVIDEO))
       CLog::Log(LOGDEBUG, "%s::%s -  got output picture:%d", CLASSNAME, __func__, m_output_ready.size());
     ret |= VC_PICTURE;
+    // renderer is low - give priority to returning pictures
+    if (0 && m_codecControlFlags & DVD_CODEC_CTRL_DRAIN)
+      ret &= ~VC_BUFFER;
   }
   if (!ret)
   {
@@ -995,6 +999,7 @@ void CMMALVideo::Reset(void)
   m_startframe = false;
   m_decoderPts = DVD_NOPTS_VALUE;
   m_preroll = !m_hints.stills && (m_speed == DVD_PLAYSPEED_NORMAL || m_speed == DVD_PLAYSPEED_PAUSE);
+  m_codecControlFlags = 0;
 }
 
 void CMMALVideo::SetSpeed(int iSpeed)
@@ -1128,3 +1133,10 @@ bool CMMALVideo::GetCodecStats(double &pts, int &droppedPics)
   //  CLog::Log(LOGDEBUG, "%s::%s - pts:%.0f droppedPics:%d", CLASSNAME, __func__, pts, droppedPics);
   return true;
 }
+
+void CMMALVideo::SetCodecControl(int flags)
+{
+  m_codecControlFlags = flags;
+  if (g_advancedSettings.CanLogComponent(LOGVIDEO))
+    CLog::Log(LOGDEBUG, "%s::%s flags:%x", CLASSNAME, __func__, flags);
+}
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h
index 4c9b20f..c405aa1 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h
@@ -89,6 +89,7 @@ class CMMALVideo
   virtual void SetDropState(bool bDrop);
   virtual const char* GetName(void) { return (const char*)m_pFormatName; }
   virtual bool GetCodecStats(double &pts, int &droppedPics);
+  virtual void SetCodecControl(int flags);
   virtual void SetSpeed(int iSpeed);
 
   // MMAL decoder callback routines.
@@ -140,6 +141,7 @@ class CMMALVideo
   unsigned int      m_droppedPics;
   int               m_speed;
   bool              m_preroll;
+  int               m_codecControlFlags;
 
   MMAL_COMPONENT_T *m_dec;
   MMAL_PORT_T *m_dec_input;

From be88e53ace69911dd0400e19c087f6bac7318ec9 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 1 Apr 2015 16:31:37 +0100
Subject: [PATCH 71/89] [mmalcodec] Limit submitted video frames. Seems to
 avoid stutter issues with low bitrate videos

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
index 1e711b4..77c31f2 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
@@ -928,7 +928,8 @@ int CMMALVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
       break;
   }
   int ret = 0;
-  if (mmal_queue_length(m_dec_input_pool->queue) > 0 && !m_demux_queue_length)
+  int fps = m_hints.fpsrate && m_hints.fpsscale ? (float)m_hints.fpsrate / (float)m_hints.fpsscale : 25;
+  if (mmal_queue_length(m_dec_input_pool->queue) > 0 && !m_demux_queue_length && m_dts_queue.size() <= fps/2)
   {
     if (g_advancedSettings.CanLogComponent(LOGVIDEO))
       CLog::Log(LOGDEBUG, "%s::%s - got space for output: demux_queue(%d) space(%d)", CLASSNAME, __func__, m_demux_queue_length, mmal_queue_length(m_dec_input_pool->queue) * m_dec_input->buffer_size);

From ae1a4baf6e3fe6ebd229a1b56d5cd6314c2390a0 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 6 Apr 2015 19:06:26 +0100
Subject: [PATCH 72/89] [mmalcodec] Remove the decoder queue and use gpu
 timestamps

There are too many streams that don't have a 1:1 mapping of encoded video frames to decoded pictures.
If that isn't true, the dts queues gets out of sync with the real frames.

Interlaces streams and streams with errors cause issues.

Instead remove the dts queue and use the gpu's timestamps.
---
 xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp | 88 +++++++++++-----------
 xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h   |  2 +-
 2 files changed, 46 insertions(+), 44 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
index 77c31f2..d8d733e 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
@@ -129,6 +129,7 @@ CMMALVideo::CMMALVideo()
   m_preroll = true;
   m_speed = DVD_PLAYSPEED_NORMAL;
   m_codecControlFlags = 0;
+  m_history_valid_pts = 0;
 }
 
 CMMALVideo::~CMMALVideo()
@@ -258,27 +259,7 @@ void CMMALVideo::dec_output_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buf
     {
       assert(!(buffer->flags & MMAL_BUFFER_HEADER_FLAG_DECODEONLY));
       double dts = DVD_NOPTS_VALUE;
-      if (buffer->flags & MMAL_BUFFER_HEADER_FLAG_USER0)
-      {
-        pthread_mutex_lock(&m_output_mutex);
-        if (!m_dts_queue.empty())
-        {
-          dts = m_dts_queue.front();
-          m_dts_queue.pop();
-        }
-        else assert(0);
-        pthread_mutex_unlock(&m_output_mutex);
-      }
-
-      if (m_drop_state)
-      {
-        pthread_mutex_lock(&m_output_mutex);
-        m_droppedPics++;
-        pthread_mutex_unlock(&m_output_mutex);
-        if (g_advancedSettings.CanLogComponent(LOGVIDEO))
-          CLog::Log(LOGDEBUG, "%s::%s - dropping %p (drop:%d)", CLASSNAME, __func__, buffer, m_drop_state);
-      }
-      else
+      if (!m_drop_state) // && !(g_advancedSettings.m_omxDecodeStartWithValidFrame && (buffer->flags & MMAL_BUFFER_HEADER_FLAG_CORRUPTED)))
       {
         CMMALVideoBuffer *omvb = new CMMALVideoBuffer(this);
         if (g_advancedSettings.CanLogComponent(LOGVIDEO))
@@ -297,6 +278,14 @@ void CMMALVideo::dec_output_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buf
         pthread_mutex_unlock(&m_output_mutex);
         kept = true;
       }
+      else
+      {
+        pthread_mutex_lock(&m_output_mutex);
+        m_droppedPics++;
+        pthread_mutex_unlock(&m_output_mutex);
+        if (g_advancedSettings.CanLogComponent(LOGVIDEO))
+          CLog::Log(LOGDEBUG, "%s::%s - dropping %p dts:%.3f pts:%.3f (drop:%d len:%d flags:%x)", CLASSNAME, __func__, buffer, dts*1e-6, buffer->pts*1e-6, m_drop_state, buffer->length, buffer->flags);
+      }
     }
   }
   else if (buffer->cmd == MMAL_EVENT_FORMAT_CHANGED)
@@ -653,6 +642,10 @@ bool CMMALVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, MMALVide
   if (status != MMAL_SUCCESS)
     CLog::Log(LOGERROR, "%s::%s Failed to enable extra buffers on %s (status=%x %s)", CLASSNAME, __func__, m_dec_input->name, status, mmal_status_to_string(status));
 
+  status = mmal_port_parameter_set_uint32(m_dec_input, MMAL_PARAMETER_VIDEO_TIMESTAMP_FIFO, 1);
+  if (status != MMAL_SUCCESS)
+    CLog::Log(LOGERROR, "%s::%s Failed to enable timestamp fifo mode on %s (status=%x %s)", CLASSNAME, __func__, m_dec_input->name, status, mmal_status_to_string(status));
+
   status = mmal_port_format_commit(m_dec_input);
   if (status != MMAL_SUCCESS)
   {
@@ -721,6 +714,8 @@ bool CMMALVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, MMALVide
   m_startframe = false;
   m_preroll = !m_hints.stills;
   m_speed = DVD_PLAYSPEED_NORMAL;
+  // start from assuming all recent frames had valid pts
+  m_history_valid_pts = ~0;
 
   return true;
 }
@@ -736,10 +731,9 @@ void CMMALVideo::Dispose()
     done = true;
   pthread_mutex_unlock(&m_output_mutex);
   if (g_advancedSettings.CanLogComponent(LOGVIDEO))
-    CLog::Log(LOGDEBUG, "%s::%s dts_queue(%d) ready_queue(%d) busy_queue(%d) done:%d", CLASSNAME, __func__, m_dts_queue.size(), m_output_ready.size(), m_output_busy, done);
+    CLog::Log(LOGDEBUG, "%s::%s ready_queue(%d) busy_queue(%d) done:%d", CLASSNAME, __func__, m_output_ready.size(), m_output_busy, done);
   if (done)
   {
-    assert(m_dts_queue.empty());
     m_myself.reset();
   }
 }
@@ -772,11 +766,19 @@ void CMMALVideo::SetDropState(bool bDrop)
   }
 }
 
+static unsigned count_bits(int32_t value)
+{
+  unsigned bits = 0;
+  for(;value;++bits)
+    value &= value - 1;
+  return bits;
+}
+
 int CMMALVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
 {
   //if (g_advancedSettings.CanLogComponent(LOGVIDEO))
-  //  CLog::Log(LOGDEBUG, "%s::%s - %-8p %-6d dts:%.3f pts:%.3f dts_queue(%d) ready_queue(%d) busy_queue(%d)",
-  //    CLASSNAME, __func__, pData, iSize, dts == DVD_NOPTS_VALUE ? 0.0 : dts*1e-6, pts == DVD_NOPTS_VALUE ? 0.0 : pts*1e-6, m_dts_queue.size(), m_output_ready.size(), m_output_busy);
+  //  CLog::Log(LOGDEBUG, "%s::%s - %-8p %-6d dts:%.3f pts:%.3f ready_queue(%d) busy_queue(%d)",
+  //    CLASSNAME, __func__, pData, iSize, dts == DVD_NOPTS_VALUE ? 0.0 : dts*1e-6, pts == DVD_NOPTS_VALUE ? 0.0 : pts*1e-6, m_output_ready.size(), m_output_busy);
 
   unsigned int demuxer_bytes = 0;
   uint8_t *demuxer_content = NULL;
@@ -840,6 +842,13 @@ int CMMALVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
          return VC_ERROR;
        }
 
+       // some packed bitstream AVI files set almost all pts values to DVD_NOPTS_VALUE, but have a scattering of real pts values.
+       // the valid pts values match the dts values.
+       // if a stream has had more than 4 valid pts values in the last 16, the use UNKNOWN, otherwise use dts
+       m_history_valid_pts = (m_history_valid_pts << 1) | (pts != DVD_NOPTS_VALUE);
+       if (count_bits(m_history_valid_pts & 0xffff) < 4)
+         pts = dts;
+
        mmal_buffer_header_reset(buffer);
        buffer->cmd = 0;
        if (!m_startframe && pts == DVD_NOPTS_VALUE)
@@ -862,8 +871,8 @@ int CMMALVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
          buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_END;
 
        if (g_advancedSettings.CanLogComponent(LOGVIDEO))
-         CLog::Log(LOGDEBUG, "%s::%s - %-8p %-6d/%-6d dts:%.3f pts:%.3f flags:%x dts_queue(%d) ready_queue(%d) busy_queue(%d) demux_queue(%d) space(%d)",
-            CLASSNAME, __func__, buffer, buffer->length, demuxer_bytes, dts == DVD_NOPTS_VALUE ? 0.0 : dts*1e-6, pts == DVD_NOPTS_VALUE ? 0.0 : pts*1e-6, buffer->flags, m_dts_queue.size(), m_output_ready.size(), m_output_busy, m_demux_queue_length, mmal_queue_length(m_dec_input_pool->queue) * m_dec_input->buffer_size);
+         CLog::Log(LOGDEBUG, "%s::%s - %-8p %-6d/%-6d dts:%.3f pts:%.3f flags:%x ready_queue(%d) busy_queue(%d) demux_queue(%d) space(%d)",
+            CLASSNAME, __func__, buffer, buffer->length, demuxer_bytes, dts == DVD_NOPTS_VALUE ? 0.0 : dts*1e-6, pts == DVD_NOPTS_VALUE ? 0.0 : pts*1e-6, buffer->flags, m_output_ready.size(), m_output_busy, m_demux_queue_length, mmal_queue_length(m_dec_input_pool->queue) * m_dec_input->buffer_size);
        assert((int)buffer->length > 0);
        status = mmal_port_send_buffer(m_dec_input, buffer);
        if (status != MMAL_SUCCESS)
@@ -880,12 +889,6 @@ int CMMALVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
          {
            m_droppedPics += m_deint ? 2:1;
          }
-         else
-         {
-           // only push if we are successful with feeding mmal
-           m_dts_queue.push(dts);
-           assert(m_dts_queue.size() < 5000);
-         }
          pthread_mutex_unlock(&m_output_mutex);
          if (m_changed_count_dec != m_changed_count)
          {
@@ -928,11 +931,11 @@ int CMMALVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
       break;
   }
   int ret = 0;
-  int fps = m_hints.fpsrate && m_hints.fpsscale ? (float)m_hints.fpsrate / (float)m_hints.fpsscale : 25;
-  if (mmal_queue_length(m_dec_input_pool->queue) > 0 && !m_demux_queue_length && m_dts_queue.size() <= fps/2)
+  double queued = m_decoderPts != DVD_NOPTS_VALUE && pts != DVD_NOPTS_VALUE ? pts - m_decoderPts : 0.0;
+  if (mmal_queue_length(m_dec_input_pool->queue) > 0 && !m_demux_queue_length && queued <= DVD_MSEC_TO_TIME(500))
   {
     if (g_advancedSettings.CanLogComponent(LOGVIDEO))
-      CLog::Log(LOGDEBUG, "%s::%s - got space for output: demux_queue(%d) space(%d)", CLASSNAME, __func__, m_demux_queue_length, mmal_queue_length(m_dec_input_pool->queue) * m_dec_input->buffer_size);
+      CLog::Log(LOGDEBUG, "%s::%s - got space for output: demux_queue(%d) space(%d) queued(%.2f)", CLASSNAME, __func__, m_demux_queue_length, mmal_queue_length(m_dec_input_pool->queue) * m_dec_input->buffer_size, queued*1e-6);
     ret |= VC_BUFFER;
   }
   else
@@ -953,8 +956,8 @@ int CMMALVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
   if (!ret)
   {
     if (g_advancedSettings.CanLogComponent(LOGVIDEO))
-      CLog::Log(LOGDEBUG, "%s::%s - Nothing to do: dts_queue(%d) ready_queue(%d) busy_queue(%d) demux_queue(%d) space(%d) preroll(%d)",
-        CLASSNAME, __func__, m_dts_queue.size(), m_output_ready.size(), m_output_busy, m_demux_queue_length, mmal_queue_length(m_dec_input_pool->queue) * m_dec_input->buffer_size, m_preroll);
+      CLog::Log(LOGDEBUG, "%s::%s - Nothing to do: ready_queue(%d) busy_queue(%d) demux_queue(%d) space(%d) preroll(%d)",
+        CLASSNAME, __func__, m_output_ready.size(), m_output_busy, m_demux_queue_length, mmal_queue_length(m_dec_input_pool->queue) * m_dec_input->buffer_size, m_preroll);
     Sleep(10); // otherwise we busy spin
   }
   return ret;
@@ -984,8 +987,6 @@ void CMMALVideo::Reset(void)
   bool old_drop_state = m_drop_state;
   SetDropState(true);
   pthread_mutex_lock(&m_output_mutex);
-  while(!m_dts_queue.empty())
-    m_dts_queue.pop();
   while (!m_demux_queue.empty())
     m_demux_queue.pop();
   m_demux_queue_length = 0;
@@ -1001,6 +1002,7 @@ void CMMALVideo::Reset(void)
   m_decoderPts = DVD_NOPTS_VALUE;
   m_preroll = !m_hints.stills && (m_speed == DVD_PLAYSPEED_NORMAL || m_speed == DVD_PLAYSPEED_PAUSE);
   m_codecControlFlags = 0;
+  m_history_valid_pts = ~0;
 }
 
 void CMMALVideo::SetSpeed(int iSpeed)
@@ -1020,8 +1022,8 @@ void CMMALVideo::Recycle(MMAL_BUFFER_HEADER_T *buffer)
   mmal_buffer_header_reset(buffer);
   buffer->cmd = 0;
   if (g_advancedSettings.CanLogComponent(LOGVIDEO))
-    CLog::Log(LOGDEBUG, "%s::%s Send buffer %p from pool to decoder output port %p dts_queue(%d) ready_queue(%d) busy_queue(%d)", CLASSNAME, __func__, buffer, m_dec_output,
-      m_dts_queue.size(), m_output_ready.size(), m_output_busy);
+    CLog::Log(LOGDEBUG, "%s::%s Send buffer %p from pool to decoder output port %p ready_queue(%d) busy_queue(%d)", CLASSNAME, __func__, buffer, m_dec_output,
+      m_output_ready.size(), m_output_busy);
   status = mmal_port_send_buffer(m_dec_output, buffer);
   if (status != MMAL_SUCCESS)
   {
@@ -1048,7 +1050,7 @@ void CMMALVideo::ReleaseBuffer(CMMALVideoBuffer *buffer)
   if (done)
     m_myself.reset();
   if (g_advancedSettings.CanLogComponent(LOGVIDEO))
-    CLog::Log(LOGDEBUG, "%s::%s %p (%p) dts_queue(%d) ready_queue(%d) busy_queue(%d) done:%d", CLASSNAME, __func__, buffer, buffer->mmal_buffer, m_dts_queue.size(), m_output_ready.size(), m_output_busy, done);
+    CLog::Log(LOGDEBUG, "%s::%s %p (%p) ready_queue(%d) busy_queue(%d) done:%d", CLASSNAME, __func__, buffer, buffer->mmal_buffer, m_output_ready.size(), m_output_busy, done);
   delete buffer;
 }
 
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h
index c405aa1..f5f664a 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h
@@ -118,7 +118,6 @@ class CMMALVideo
   const char        *m_pFormatName;
   MMALVideoPtr      m_myself;
 
-  std::queue<double> m_dts_queue;
   std::queue<mmal_demux_packet> m_demux_queue;
   unsigned           m_demux_queue_length;
 
@@ -142,6 +141,7 @@ class CMMALVideo
   int               m_speed;
   bool              m_preroll;
   int               m_codecControlFlags;
+  uint32_t          m_history_valid_pts;
 
   MMAL_COMPONENT_T *m_dec;
   MMAL_PORT_T *m_dec_input;

From 2f763b28cb818300befb9f7a4c6fd79c7ced9d7f Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 9 Apr 2015 18:18:09 +0100
Subject: [PATCH 73/89] [mmalrenderer] Remove dropping logic. It only seems to
 make things worse

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp | 76 +++++++---------------
 xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h   |  2 -
 2 files changed, 23 insertions(+), 55 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
index d8d733e..cfe106a 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
@@ -97,7 +97,6 @@ CMMALVideo::CMMALVideo()
     CLog::Log(LOGDEBUG, "%s::%s %p", CLASSNAME, __func__, this);
   pthread_mutex_init(&m_output_mutex, NULL);
 
-  m_drop_state = false;
   m_decoded_width = 0;
   m_decoded_height = 0;
 
@@ -108,7 +107,6 @@ CMMALVideo::CMMALVideo()
   m_interlace_method = VS_INTERLACEMETHOD_NONE;
   m_startframe = false;
   m_decoderPts = DVD_NOPTS_VALUE;
-  m_droppedPics = 0;
 
   m_dec = NULL;
   m_dec_input = NULL;
@@ -259,7 +257,7 @@ void CMMALVideo::dec_output_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buf
     {
       assert(!(buffer->flags & MMAL_BUFFER_HEADER_FLAG_DECODEONLY));
       double dts = DVD_NOPTS_VALUE;
-      if (!m_drop_state) // && !(g_advancedSettings.m_omxDecodeStartWithValidFrame && (buffer->flags & MMAL_BUFFER_HEADER_FLAG_CORRUPTED)))
+      if (1)//(!(g_advancedSettings.m_omxDecodeStartWithValidFrame && (buffer->flags & MMAL_BUFFER_HEADER_FLAG_CORRUPTED)))
       {
         CMMALVideoBuffer *omvb = new CMMALVideoBuffer(this);
         if (g_advancedSettings.CanLogComponent(LOGVIDEO))
@@ -280,11 +278,8 @@ void CMMALVideo::dec_output_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buf
       }
       else
       {
-        pthread_mutex_lock(&m_output_mutex);
-        m_droppedPics++;
-        pthread_mutex_unlock(&m_output_mutex);
         if (g_advancedSettings.CanLogComponent(LOGVIDEO))
-          CLog::Log(LOGDEBUG, "%s::%s - dropping %p dts:%.3f pts:%.3f (drop:%d len:%d flags:%x)", CLASSNAME, __func__, buffer, dts*1e-6, buffer->pts*1e-6, m_drop_state, buffer->length, buffer->flags);
+          CLog::Log(LOGDEBUG, "%s::%s - discarding %p dts:%.3f pts:%.3f (len:%d flags:%x)", CLASSNAME, __func__, buffer, dts*1e-6, buffer->pts*1e-6, buffer->length, buffer->flags);
       }
     }
   }
@@ -710,7 +705,6 @@ bool CMMALVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, MMALVide
   if (!SendCodecConfigData())
     return false;
 
-  m_drop_state = false;
   m_startframe = false;
   m_preroll = !m_hints.stills;
   m_speed = DVD_PLAYSPEED_NORMAL;
@@ -740,30 +734,8 @@ void CMMALVideo::Dispose()
 
 void CMMALVideo::SetDropState(bool bDrop)
 {
-  if (m_drop_state != bDrop)
-    if (g_advancedSettings.CanLogComponent(LOGVIDEO))
-      CLog::Log(LOGDEBUG, "%s::%s - m_drop_state(%d)", CLASSNAME, __func__, bDrop);
-  m_drop_state = bDrop;
-  if (m_drop_state)
-  {
-    while (1)
-    {
-      CMMALVideoBuffer *buffer = NULL;
-      pthread_mutex_lock(&m_output_mutex);
-      // fetch a output buffer and pop it off the ready list
-      if (!m_output_ready.empty())
-      {
-        buffer = m_output_ready.front();
-        m_output_ready.pop();
-        m_droppedPics++;
-      }
-      pthread_mutex_unlock(&m_output_mutex);
-      if (buffer)
-        ReleaseBuffer(buffer);
-      else
-        break;
-    }
-  }
+  if (g_advancedSettings.CanLogComponent(LOGVIDEO))
+    CLog::Log(LOGDEBUG, "%s::%s - bDrop(%d)", CLASSNAME, __func__, bDrop);
 }
 
 static unsigned count_bits(int32_t value)
@@ -859,10 +831,6 @@ int CMMALVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
        // set a flag so we can identify primary frames from generated frames (deinterlace)
        buffer->flags = MMAL_BUFFER_HEADER_FLAG_USER0;
 
-       // Request decode only (maintain ref frames, but don't return a picture)
-       if (m_drop_state)
-         buffer->flags |= MMAL_BUFFER_HEADER_FLAG_DECODEONLY;
-
        memcpy(buffer->data, demuxer_content, buffer->length);
        demuxer_bytes   -= buffer->length;
        demuxer_content += buffer->length;
@@ -885,10 +853,6 @@ int CMMALVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
        {
          pthread_mutex_lock(&m_output_mutex);
          m_startframe = true;
-         if (m_drop_state)
-         {
-           m_droppedPics += m_deint ? 2:1;
-         }
          pthread_mutex_unlock(&m_output_mutex);
          if (m_changed_count_dec != m_changed_count)
          {
@@ -984,16 +948,28 @@ void CMMALVideo::Reset(void)
       mmal_port_enable(m_dec_output, dec_output_port_cb_static);
   }
   // blow all ready video frames
-  bool old_drop_state = m_drop_state;
-  SetDropState(true);
+  while (1)
+  {
+    CMMALVideoBuffer *buffer = NULL;
+    pthread_mutex_lock(&m_output_mutex);
+    // fetch a output buffer and pop it off the ready list
+    if (!m_output_ready.empty())
+    {
+      buffer = m_output_ready.front();
+      m_output_ready.pop();
+    }
+    pthread_mutex_unlock(&m_output_mutex);
+    if (buffer)
+      ReleaseBuffer(buffer);
+    else
+      break;
+  }
+
   pthread_mutex_lock(&m_output_mutex);
   while (!m_demux_queue.empty())
     m_demux_queue.pop();
   m_demux_queue_length = 0;
-  m_droppedPics = 0;
   pthread_mutex_unlock(&m_output_mutex);
-  if (!old_drop_state)
-    SetDropState(false);
 
   if (!m_finished)
     SendCodecConfigData();
@@ -1127,14 +1103,8 @@ bool CMMALVideo::ClearPicture(DVDVideoPicture* pDvdVideoPicture)
 
 bool CMMALVideo::GetCodecStats(double &pts, int &droppedPics)
 {
-  pthread_mutex_lock(&m_output_mutex);
-  pts = m_decoderPts;
-  droppedPics = m_droppedPics;
-  m_droppedPics = 0;
-  pthread_mutex_unlock(&m_output_mutex);
-  //if (g_advancedSettings.CanLogComponent(LOGVIDEO))
-  //  CLog::Log(LOGDEBUG, "%s::%s - pts:%.0f droppedPics:%d", CLASSNAME, __func__, pts, droppedPics);
-  return true;
+  droppedPics= -1;
+  return false;
 }
 
 void CMMALVideo::SetCodecControl(int flags)
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h
index f5f664a..f79fed5 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h
@@ -109,7 +109,6 @@ class CMMALVideo
   bool DestroyDeinterlace();
 
   // Video format
-  bool              m_drop_state;
   int               m_decoded_width;
   int               m_decoded_height;
   unsigned int      m_egl_buffer_count;
@@ -137,7 +136,6 @@ class CMMALVideo
   EINTERLACEMETHOD  m_interlace_method;
   bool              m_startframe;
   double            m_decoderPts;
-  unsigned int      m_droppedPics;
   int               m_speed;
   bool              m_preroll;
   int               m_codecControlFlags;

From d0eb9742af9ecf3de62d560d0e5c57de2531486f Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 8 Apr 2015 12:47:04 +0100
Subject: [PATCH 74/89] [players] Make use of new scheme to submit DTS
 timestamps

Latest firmware supports marking timestamps as DTS,
and it will reorder the timestamps with the decoded frame

This avoids some of the current hacks of supporting PTS and DTS
timestamps in a single field.
---
 xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp | 35 +++++-----------------
 xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h   |  2 --
 xbmc/cores/omxplayer/OMXPlayerVideo.cpp            | 28 ++++++-----------
 xbmc/cores/omxplayer/OMXPlayerVideo.h              |  1 -
 xbmc/cores/omxplayer/OMXVideo.cpp                  | 25 ++++------------
 xbmc/cores/omxplayer/OMXVideo.h                    |  2 +-
 6 files changed, 23 insertions(+), 70 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
index cfe106a..237a581 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
@@ -57,7 +57,6 @@ CMMALVideoBuffer::CMMALVideoBuffer(CMMALVideo *omv)
   height = 0;
   m_aspect_ratio = 0.0f;
   m_changed_count = 0;
-  dts = DVD_NOPTS_VALUE;
 }
 
 CMMALVideoBuffer::~CMMALVideoBuffer()
@@ -127,7 +126,6 @@ CMMALVideo::CMMALVideo()
   m_preroll = true;
   m_speed = DVD_PLAYSPEED_NORMAL;
   m_codecControlFlags = 0;
-  m_history_valid_pts = 0;
 }
 
 CMMALVideo::~CMMALVideo()
@@ -256,17 +254,15 @@ void CMMALVideo::dec_output_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buf
     if (buffer->length > 0)
     {
       assert(!(buffer->flags & MMAL_BUFFER_HEADER_FLAG_DECODEONLY));
-      double dts = DVD_NOPTS_VALUE;
       if (1)//(!(g_advancedSettings.m_omxDecodeStartWithValidFrame && (buffer->flags & MMAL_BUFFER_HEADER_FLAG_CORRUPTED)))
       {
         CMMALVideoBuffer *omvb = new CMMALVideoBuffer(this);
         if (g_advancedSettings.CanLogComponent(LOGVIDEO))
           CLog::Log(LOGDEBUG, "%s::%s - %p (%p) buffer_size(%u) dts:%.3f pts:%.3f flags:%x:%x frame:%d",
-            CLASSNAME, __func__, buffer, omvb, buffer->length, dts*1e-6, buffer->pts*1e-6, buffer->flags, buffer->type->video.flags, omvb->m_changed_count);
+            CLASSNAME, __func__, buffer, omvb, buffer->length, buffer->dts*1e-6, buffer->pts*1e-6, buffer->flags, buffer->type->video.flags, omvb->m_changed_count);
         omvb->mmal_buffer = buffer;
         buffer->user_data = (void *)omvb;
         omvb->m_changed_count = m_changed_count;
-        omvb->dts = dts;
         omvb->width = m_decoded_width;
         omvb->height = m_decoded_height;
         omvb->m_aspect_ratio = m_aspect_ratio;
@@ -279,7 +275,7 @@ void CMMALVideo::dec_output_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buf
       else
       {
         if (g_advancedSettings.CanLogComponent(LOGVIDEO))
-          CLog::Log(LOGDEBUG, "%s::%s - discarding %p dts:%.3f pts:%.3f (len:%d flags:%x)", CLASSNAME, __func__, buffer, dts*1e-6, buffer->pts*1e-6, buffer->length, buffer->flags);
+          CLog::Log(LOGDEBUG, "%s::%s - dropping %p dts:%.3f pts:%.3f (len:%d flags:%x)", CLASSNAME, __func__, buffer, buffer->dts*1e-6, buffer->pts*1e-6, buffer->length, buffer->flags);
       }
     }
   }
@@ -637,7 +633,11 @@ bool CMMALVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, MMALVide
   if (status != MMAL_SUCCESS)
     CLog::Log(LOGERROR, "%s::%s Failed to enable extra buffers on %s (status=%x %s)", CLASSNAME, __func__, m_dec_input->name, status, mmal_status_to_string(status));
 
-  status = mmal_port_parameter_set_uint32(m_dec_input, MMAL_PARAMETER_VIDEO_TIMESTAMP_FIFO, 1);
+  status = mmal_port_parameter_set_uint32(m_dec_input, MMAL_PARAMETER_VIDEO_TIMESTAMP_FIFO, 0);
+  if (status != MMAL_SUCCESS)
+    CLog::Log(LOGERROR, "%s::%s Failed to enable timestamp fifo mode on %s (status=%x %s)", CLASSNAME, __func__, m_dec_input->name, status, mmal_status_to_string(status));
+
+  status = mmal_port_parameter_set_uint32(m_dec_input, MMAL_PARAMETER_VIDEO_INTERPOLATE_TIMESTAMPS, 0);
   if (status != MMAL_SUCCESS)
     CLog::Log(LOGERROR, "%s::%s Failed to enable timestamp fifo mode on %s (status=%x %s)", CLASSNAME, __func__, m_dec_input->name, status, mmal_status_to_string(status));
 
@@ -708,8 +708,6 @@ bool CMMALVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, MMALVide
   m_startframe = false;
   m_preroll = !m_hints.stills;
   m_speed = DVD_PLAYSPEED_NORMAL;
-  // start from assuming all recent frames had valid pts
-  m_history_valid_pts = ~0;
 
   return true;
 }
@@ -738,14 +736,6 @@ void CMMALVideo::SetDropState(bool bDrop)
     CLog::Log(LOGDEBUG, "%s::%s - bDrop(%d)", CLASSNAME, __func__, bDrop);
 }
 
-static unsigned count_bits(int32_t value)
-{
-  unsigned bits = 0;
-  for(;value;++bits)
-    value &= value - 1;
-  return bits;
-}
-
 int CMMALVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
 {
   //if (g_advancedSettings.CanLogComponent(LOGVIDEO))
@@ -813,14 +803,6 @@ int CMMALVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
          CLog::Log(LOGERROR, "%s::%s - mmal_queue_get failed", CLASSNAME, __func__);
          return VC_ERROR;
        }
-
-       // some packed bitstream AVI files set almost all pts values to DVD_NOPTS_VALUE, but have a scattering of real pts values.
-       // the valid pts values match the dts values.
-       // if a stream has had more than 4 valid pts values in the last 16, the use UNKNOWN, otherwise use dts
-       m_history_valid_pts = (m_history_valid_pts << 1) | (pts != DVD_NOPTS_VALUE);
-       if (count_bits(m_history_valid_pts & 0xffff) < 4)
-         pts = dts;
-
        mmal_buffer_header_reset(buffer);
        buffer->cmd = 0;
        if (!m_startframe && pts == DVD_NOPTS_VALUE)
@@ -978,7 +960,6 @@ void CMMALVideo::Reset(void)
   m_decoderPts = DVD_NOPTS_VALUE;
   m_preroll = !m_hints.stills && (m_speed == DVD_PLAYSPEED_NORMAL || m_speed == DVD_PLAYSPEED_PAUSE);
   m_codecControlFlags = 0;
-  m_history_valid_pts = ~0;
 }
 
 void CMMALVideo::SetSpeed(int iSpeed)
@@ -1064,7 +1045,7 @@ bool CMMALVideo::GetPicture(DVDVideoPicture* pDvdVideoPicture)
     }
 
     // timestamp is in microseconds
-    pDvdVideoPicture->dts = buffer->dts;
+    pDvdVideoPicture->dts = buffer->mmal_buffer->dts == MMAL_TIME_UNKNOWN || buffer->mmal_buffer->dts == 0 ? DVD_NOPTS_VALUE : buffer->mmal_buffer->dts;
     pDvdVideoPicture->pts = buffer->mmal_buffer->pts == MMAL_TIME_UNKNOWN || buffer->mmal_buffer->pts == 0 ? DVD_NOPTS_VALUE : buffer->mmal_buffer->pts;
 
     pDvdVideoPicture->MMALBuffer->Acquire();
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h
index f79fed5..415f3e3 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h
@@ -55,7 +55,6 @@ class CMMALVideoBuffer
   int width;
   int height;
   float m_aspect_ratio;
-  double dts;
   uint32_t m_changed_count;
   // reference counting
   CMMALVideoBuffer* Acquire();
@@ -139,7 +138,6 @@ class CMMALVideo
   int               m_speed;
   bool              m_preroll;
   int               m_codecControlFlags;
-  uint32_t          m_history_valid_pts;
 
   MMAL_COMPONENT_T *m_dec;
   MMAL_PORT_T *m_dec_input;
diff --git a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
index 018e65f..4315993 100644
--- a/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
@@ -106,7 +106,6 @@ OMXPlayerVideo::OMXPlayerVideo(OMXClock *av_clock,
   m_iCurrentPts = DVD_NOPTS_VALUE;
   m_nextOverlay = DVD_NOPTS_VALUE;
   m_flush = false;
-  m_history_valid_pts = 0;
 }
 
 OMXPlayerVideo::~OMXPlayerVideo()
@@ -314,14 +313,6 @@ void OMXPlayerVideo::Output(double pts, bool bDropPacket)
   g_renderManager.FlipPage(CThread::m_bStop, time/DVD_TIME_BASE);
 }
 
-static unsigned count_bits(int32_t value)
-{
-  unsigned bits = 0;
-  for(;value;++bits)
-    value &= value - 1;
-  return bits;
-}
-
 void OMXPlayerVideo::Process()
 {
   double frametime = (double)DVD_TIME_BASE / m_fFrameRate;
@@ -496,18 +487,20 @@ void OMXPlayerVideo::Process()
           m_stalled = false;
         }
 
-        // some packed bitstream AVI files set almost all pts values to DVD_NOPTS_VALUE, but have a scattering of real pts values.
-        // the valid pts values match the dts values.
-        // if a stream has had more than 4 valid pts values in the last 16, the use UNKNOWN, otherwise use dts
-        m_history_valid_pts = (m_history_valid_pts << 1) | (pPacket->pts != DVD_NOPTS_VALUE);
+        double dts = pPacket->dts;
         double pts = pPacket->pts;
-        if(count_bits(m_history_valid_pts & 0xffff) < 4)
-          pts = pPacket->dts;
+
+        if (dts != DVD_NOPTS_VALUE)
+          dts += m_iVideoDelay;
 
         if (pts != DVD_NOPTS_VALUE)
           pts += m_iVideoDelay;
 
-        m_omxVideo.Decode(pPacket->pData, pPacket->iSize, pts);
+        m_omxVideo.Decode(pPacket->pData, pPacket->iSize, dts, pts);
+
+        if (pts == DVD_NOPTS_VALUE)
+          pts = dts;
+
         Output(pts, bRequestDrop);
         if(pts != DVD_NOPTS_VALUE)
           m_iCurrentPts = pts;
@@ -583,9 +576,6 @@ bool OMXPlayerVideo::OpenDecoder()
     m_codecname = m_omxVideo.GetDecoderName();
   }
 
-  // start from assuming all recent frames had valid pts
-  m_history_valid_pts = ~0;
-
   return bVideoDecoderOpen;
 }
 
diff --git a/xbmc/cores/omxplayer/OMXPlayerVideo.h b/xbmc/cores/omxplayer/OMXPlayerVideo.h
index 2748a41..3bd5625 100644
--- a/xbmc/cores/omxplayer/OMXPlayerVideo.h
+++ b/xbmc/cores/omxplayer/OMXPlayerVideo.h
@@ -69,7 +69,6 @@ class OMXPlayerVideo : public CThread, public IDVDStreamPlayerVideo
   RENDER_STEREO_MODE        m_video_stereo_mode;
   RENDER_STEREO_MODE        m_display_stereo_mode;
   bool                      m_StereoInvert;
-  uint32_t                  m_history_valid_pts;
   DllBcmHost                m_DllBcmHost;
 
   CDVDOverlayContainer  *m_pOverlayContainer;
diff --git a/xbmc/cores/omxplayer/OMXVideo.cpp b/xbmc/cores/omxplayer/OMXVideo.cpp
index 3f37d44..832a9c9 100644
--- a/xbmc/cores/omxplayer/OMXVideo.cpp
+++ b/xbmc/cores/omxplayer/OMXVideo.cpp
@@ -602,23 +602,6 @@ bool COMXVideo::Open(CDVDStreamInfo &hints, OMXClock *clock, EDEINTERLACEMODE de
     return false;
   }
 
-  // broadcom omx entension:
-  // When enabled, the timestamp fifo mode will change the way incoming timestamps are associated with output images.
-  // In this mode the incoming timestamps get used without re-ordering on output images.
-  // recent firmware will actually automatically choose the timestamp stream with the least variance, so always enable
-  {
-    OMX_CONFIG_BOOLEANTYPE timeStampMode;
-    OMX_INIT_STRUCTURE(timeStampMode);
-    timeStampMode.bEnabled = OMX_TRUE;
-
-    omx_err = m_omx_decoder.SetParameter((OMX_INDEXTYPE)OMX_IndexParamBrcmVideoTimestampFifo, &timeStampMode);
-    if (omx_err != OMX_ErrorNone)
-    {
-      CLog::Log(LOGERROR, "COMXVideo::Open OMX_IndexParamBrcmVideoTimestampFifo error (0%08x)\n", omx_err);
-      return false;
-    }
-  }
-
   if(NaluFormatStartCodes(hints.codec, m_extradata, m_extrasize))
   {
     OMX_NALSTREAMFORMATTYPE nalStreamFormat;
@@ -758,7 +741,7 @@ bool COMXVideo::GetPlayerInfo(double &match, double &phase, double &pll)
 }
 
 
-int COMXVideo::Decode(uint8_t *pData, int iSize, double pts)
+int COMXVideo::Decode(uint8_t *pData, int iSize, double dts, double pts)
 {
   CSingleLock lock (m_critSection);
   OMX_ERRORTYPE omx_err;
@@ -783,6 +766,7 @@ int COMXVideo::Decode(uint8_t *pData, int iSize, double pts)
 
       omx_buffer->nFlags = 0;
       omx_buffer->nOffset = 0;
+      omx_buffer->nTimeStamp = ToOMXTime((uint64_t)(pts != DVD_NOPTS_VALUE ? pts : dts != DVD_NOPTS_VALUE ? dts : 0));
 
       if(m_setStartTime)
       {
@@ -790,10 +774,11 @@ int COMXVideo::Decode(uint8_t *pData, int iSize, double pts)
         CLog::Log(LOGDEBUG, "OMXVideo::Decode VDec : setStartTime %f\n", (pts == DVD_NOPTS_VALUE ? 0.0 : pts) / DVD_TIME_BASE);
         m_setStartTime = false;
       }
-      if(pts == DVD_NOPTS_VALUE)
+      else if (pts == DVD_NOPTS_VALUE && dts == DVD_NOPTS_VALUE)
         omx_buffer->nFlags |= OMX_BUFFERFLAG_TIME_UNKNOWN;
+      else if (pts == DVD_NOPTS_VALUE)
+        omx_buffer->nFlags |= OMX_BUFFERFLAG_TIME_IS_DTS;
 
-      omx_buffer->nTimeStamp = ToOMXTime((uint64_t)(pts == DVD_NOPTS_VALUE) ? 0 : pts);
       omx_buffer->nFilledLen = std::min((OMX_U32)demuxer_bytes, omx_buffer->nAllocLen);
       memcpy(omx_buffer->pBuffer, demuxer_content, omx_buffer->nFilledLen);
 
diff --git a/xbmc/cores/omxplayer/OMXVideo.h b/xbmc/cores/omxplayer/OMXVideo.h
index 3ea02dc..86e94ce 100644
--- a/xbmc/cores/omxplayer/OMXVideo.h
+++ b/xbmc/cores/omxplayer/OMXVideo.h
@@ -55,7 +55,7 @@ class COMXVideo
   void Close(void);
   unsigned int GetFreeSpace();
   unsigned int GetSize();
-  int  Decode(uint8_t *pData, int iSize, double pts);
+  int  Decode(uint8_t *pData, int iSize, double dts, double pts);
   void Reset(void);
   void SetDropState(bool bDrop);
   std::string GetDecoderName() { return m_video_codec_name; };

From c5d5f34a04502ef918ad35de044862e4a6e4f843 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 14 Apr 2015 20:51:14 +0100
Subject: [PATCH 75/89] [gui] Also limit GUI updates when in non full-screen
 video mode

---
 xbmc/Application.cpp | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index 5889613..9ba0d23 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -2496,7 +2496,7 @@ void CApplication::FrameMove(bool processEvents, bool processGUI)
 #if defined(TARGET_RASPBERRY_PI) || defined(HAS_IMXVPU)
     // This code reduces rendering fps of the GUI layer when playing videos in fullscreen mode
     // it makes only sense on architectures with multiple layers
-    if (g_graphicsContext.IsFullScreenVideo() && !m_pPlayer->IsPausedPlayback() && g_renderManager.IsVideoLayer())
+    if (m_pPlayer->IsPlayingVideo() && !m_pPlayer->IsPausedPlayback() && g_renderManager.IsVideoLayer())
       fps = CSettings::Get().GetInt("videoplayer.limitguiupdate");
 #endif
 
@@ -2509,6 +2509,8 @@ void CApplication::FrameMove(bool processEvents, bool processGUI)
     {
       if (!m_skipGuiRender)
         g_windowManager.Process(CTimeUtils::GetFrameTime());
+      else if (!g_graphicsContext.IsFullScreenVideo())
+        g_renderManager.FrameMove();
     }
     g_windowManager.FrameMove();
   }

From e40d733fa86aa4835daaec2484169c05fe5796c9 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 15 Apr 2015 22:57:45 +0100
Subject: [PATCH 76/89] [mmalcodec] Return mmal buffers explicitly

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp | 29 ++++++++++++++--------
 xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h   |  1 +
 2 files changed, 20 insertions(+), 10 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
index 237a581..486dc4b 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
@@ -133,7 +133,6 @@ CMMALVideo::~CMMALVideo()
   if (g_advancedSettings.CanLogComponent(LOGVIDEO))
     CLog::Log(LOGDEBUG, "%s::%s %p", CLASSNAME, __func__, this);
   assert(m_finished);
-  Reset();
 
   pthread_mutex_destroy(&m_output_mutex);
 
@@ -413,7 +412,7 @@ bool CMMALVideo::CreateDeinterlace(EINTERLACEMETHOD interlace_method)
 
   m_dec_output = m_deint->output[0];
   m_interlace_method = interlace_method;
-
+  Prime();
   return true;
 }
 
@@ -469,6 +468,7 @@ bool CMMALVideo::DestroyDeinterlace()
 
   m_dec_output = m_dec->output[0];
   m_interlace_method = VS_INTERLACEMETHOD_NONE;
+  Prime();
   return true;
 }
 
@@ -705,6 +705,7 @@ bool CMMALVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, MMALVide
   if (!SendCodecConfigData())
     return false;
 
+  Prime();
   m_startframe = false;
   m_preroll = !m_hints.stills;
   m_speed = DVD_PLAYSPEED_NORMAL;
@@ -747,8 +748,6 @@ int CMMALVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
   MMAL_BUFFER_HEADER_T *buffer;
   MMAL_STATUS_T status;
 
-  while (buffer = mmal_queue_get(m_dec_output_pool->queue), buffer)
-    Recycle(buffer);
   // we need to queue then de-queue the demux packet, seems silly but
   // mmal might not have an input buffer available when we are called
   // and we must store the demuxer packet and try again later.
@@ -775,9 +774,6 @@ int CMMALVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
 
   while (1)
   {
-     while (buffer = mmal_queue_get(m_dec_output_pool->queue), buffer)
-       Recycle(buffer);
-
      space = mmal_queue_length(m_dec_input_pool->queue) * m_dec_input->buffer_size;
      if (!demuxer_bytes && !m_demux_queue.empty())
      {
@@ -869,8 +865,6 @@ int CMMALVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
            demuxer_content = NULL;
            continue;
          }
-         while (buffer = mmal_queue_get(m_dec_output_pool->queue), buffer)
-           Recycle(buffer);
        }
     }
     if (!demuxer_bytes)
@@ -909,6 +903,13 @@ int CMMALVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
   return ret;
 }
 
+void CMMALVideo::Prime()
+{
+  MMAL_BUFFER_HEADER_T *buffer;
+  while (buffer = mmal_queue_get(m_dec_output_pool->queue), buffer)
+    Recycle(buffer);
+}
+
 void CMMALVideo::Reset(void)
 {
   if (g_advancedSettings.CanLogComponent(LOGVIDEO))
@@ -954,8 +955,10 @@ void CMMALVideo::Reset(void)
   pthread_mutex_unlock(&m_output_mutex);
 
   if (!m_finished)
+  {
     SendCodecConfigData();
-
+    Prime();
+  }
   m_startframe = false;
   m_decoderPts = DVD_NOPTS_VALUE;
   m_preroll = !m_hints.stills && (m_speed == DVD_PLAYSPEED_NORMAL || m_speed == DVD_PLAYSPEED_PAUSE);
@@ -975,6 +978,12 @@ void CMMALVideo::Recycle(MMAL_BUFFER_HEADER_T *buffer)
   if (g_advancedSettings.CanLogComponent(LOGVIDEO))
     CLog::Log(LOGDEBUG, "%s::%s %p", CLASSNAME, __func__, buffer);
 
+  if (m_finished)
+  {
+    mmal_buffer_header_release(buffer);
+    return;
+  }
+
   MMAL_STATUS_T status;
   mmal_buffer_header_reset(buffer);
   buffer->cmd = 0;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h
index 415f3e3..011ae04 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h
@@ -106,6 +106,7 @@ class CMMALVideo
   void QueryCodec(void);
   bool CreateDeinterlace(EINTERLACEMETHOD interlace_method);
   bool DestroyDeinterlace();
+  void Prime();
 
   // Video format
   int               m_decoded_width;

From 444b6fc43e09650a22ac1ef9d6fe4c62fffaff19 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Wed, 15 Apr 2015 23:26:47 +0100
Subject: [PATCH 77/89] [mmalcodec] Handle resolution change from callback

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp | 26 +++++-----------------
 xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h   |  3 ---
 2 files changed, 6 insertions(+), 23 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
index 486dc4b..39d6e60 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
@@ -56,7 +56,6 @@ CMMALVideoBuffer::CMMALVideoBuffer(CMMALVideo *omv)
   width = 0;
   height = 0;
   m_aspect_ratio = 0.0f;
-  m_changed_count = 0;
 }
 
 CMMALVideoBuffer::~CMMALVideoBuffer()
@@ -118,8 +117,6 @@ CMMALVideo::CMMALVideo()
 
   m_codingType = 0;
 
-  m_changed_count = 0;
-  m_changed_count_dec = 0;
   m_output_busy = 0;
   m_demux_queue_length = 0;
   m_es_format = mmal_format_alloc();
@@ -183,7 +180,6 @@ void CMMALVideo::PortSettingsChanged(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *bu
 {
   MMAL_EVENT_FORMAT_CHANGED_T *fmt = mmal_event_format_changed_get(buffer);
   mmal_format_copy(m_es_format, fmt->format);
-  m_changed_count++;
 
   if (m_es_format->es->video.crop.width && m_es_format->es->video.crop.height)
   {
@@ -192,10 +188,13 @@ void CMMALVideo::PortSettingsChanged(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *bu
     m_decoded_width = m_es_format->es->video.crop.width;
     m_decoded_height = m_es_format->es->video.crop.height;
     if (g_advancedSettings.CanLogComponent(LOGVIDEO))
-      CLog::Log(LOGDEBUG, "%s::%s format changed: %dx%d %.2f frame:%d", CLASSNAME, __func__, m_decoded_width, m_decoded_height, m_aspect_ratio, m_changed_count);
+      CLog::Log(LOGDEBUG, "%s::%s format changed: %dx%d %.2f", CLASSNAME, __func__, m_decoded_width, m_decoded_height, m_aspect_ratio);
   }
   else
     CLog::Log(LOGERROR, "%s::%s format changed: Unexpected %dx%d", CLASSNAME, __func__, m_es_format->es->video.crop.width, m_es_format->es->video.crop.height);
+
+  if (!change_dec_output_format())
+    CLog::Log(LOGERROR, "%s::%s - change_dec_output_format() failed", CLASSNAME, __func__);
 }
 
 void CMMALVideo::dec_control_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
@@ -257,11 +256,10 @@ void CMMALVideo::dec_output_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buf
       {
         CMMALVideoBuffer *omvb = new CMMALVideoBuffer(this);
         if (g_advancedSettings.CanLogComponent(LOGVIDEO))
-          CLog::Log(LOGDEBUG, "%s::%s - %p (%p) buffer_size(%u) dts:%.3f pts:%.3f flags:%x:%x frame:%d",
-            CLASSNAME, __func__, buffer, omvb, buffer->length, buffer->dts*1e-6, buffer->pts*1e-6, buffer->flags, buffer->type->video.flags, omvb->m_changed_count);
+          CLog::Log(LOGDEBUG, "%s::%s - %p (%p) buffer_size(%u) dts:%.3f pts:%.3f flags:%x:%x",
+            CLASSNAME, __func__, buffer, omvb, buffer->length, buffer->dts*1e-6, buffer->pts*1e-6, buffer->flags, buffer->type->video.flags);
         omvb->mmal_buffer = buffer;
         buffer->user_data = (void *)omvb;
-        omvb->m_changed_count = m_changed_count;
         omvb->width = m_decoded_width;
         omvb->height = m_decoded_height;
         omvb->m_aspect_ratio = m_aspect_ratio;
@@ -313,7 +311,6 @@ bool CMMALVideo::change_dec_output_format()
   else
     CLog::Log(LOGERROR, "%s::%s Failed to query interlace type on %s (status=%x %s)", CLASSNAME, __func__, m_dec_output->name, status, mmal_status_to_string(status));
 
-  // todo: if we don't disable/enable we can do this from callback
   mmal_format_copy(m_dec_output->format, m_es_format);
   status = mmal_port_format_commit(m_dec_output);
   if (status != MMAL_SUCCESS)
@@ -832,17 +829,6 @@ int CMMALVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
          pthread_mutex_lock(&m_output_mutex);
          m_startframe = true;
          pthread_mutex_unlock(&m_output_mutex);
-         if (m_changed_count_dec != m_changed_count)
-         {
-           if (g_advancedSettings.CanLogComponent(LOGVIDEO))
-             CLog::Log(LOGDEBUG, "%s::%s format changed frame:%d(%d)", CLASSNAME, __func__, m_changed_count_dec, m_changed_count);
-           m_changed_count_dec = m_changed_count;
-           if (!change_dec_output_format())
-           {
-             CLog::Log(LOGERROR, "%s::%s - change_dec_output_format() failed", CLASSNAME, __func__);
-             return VC_ERROR;
-           }
-         }
          EDEINTERLACEMODE deinterlace_request = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
          EINTERLACEMETHOD interlace_method = g_renderManager.AutoInterlaceMethod(CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod);
 
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h
index 011ae04..fcc6a15 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h
@@ -55,7 +55,6 @@ class CMMALVideoBuffer
   int width;
   int height;
   float m_aspect_ratio;
-  uint32_t m_changed_count;
   // reference counting
   CMMALVideoBuffer* Acquire();
   long              Release();
@@ -99,8 +98,6 @@ class CMMALVideo
   void dec_output_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer);
   void dec_control_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer);
   void dec_input_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer);
-  uint32_t          m_changed_count;
-  uint32_t          m_changed_count_dec;
 
 protected:
   void QueryCodec(void);

From 3e33a9a5a6874b992bed68821b8d779380a13f14 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Fri, 17 Apr 2015 20:18:40 +0200
Subject: [PATCH 78/89] dvdplayer: reduce time for initial audio sync

---
 xbmc/cores/dvdplayer/DVDPlayerAudio.cpp | 6 +++---
 xbmc/cores/dvdplayer/DVDPlayerAudio.h   | 4 ++--
 2 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp b/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp
index bd357aa..ebf4d93 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp
@@ -676,7 +676,7 @@ void CDVDPlayerAudio::HandleSyncError(double duration)
   // error because drop/dupe changes the value
   if (m_syncclock && fabs(error) > threshold1)
   {
-    m_errors.Flush(500);
+    m_errors.Flush();
     m_integral = 0.0;
     m_resampleratio = 0.0;
     return;
@@ -693,13 +693,13 @@ void CDVDPlayerAudio::HandleSyncError(double duration)
   // 500ms in order to get first resample ratio early. If we don't adjust rr early, error
   // may get above threshold1 again. Too small values for interval result in worse average errors
 
-  if (!m_errors.Get(m_error, m_syncclock ? 500 : 2000))
+  if (!m_errors.Get(m_error, m_syncclock ? 100 : 2000))
     return;
 
   if (fabs(m_error) > threshold1)
   {
     m_syncclock = true;
-    m_errors.Flush(500);
+    m_errors.Flush(100);
     m_integral = 0.0;
     m_resampleratio = 0.0;
     CLog::Log(LOGDEBUG,"CDVDPlayerAudio::HandleSyncError - average error %f above threshold of %f",
diff --git a/xbmc/cores/dvdplayer/DVDPlayerAudio.h b/xbmc/cores/dvdplayer/DVDPlayerAudio.h
index 635c184..bf51863 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerAudio.h
+++ b/xbmc/cores/dvdplayer/DVDPlayerAudio.h
@@ -69,7 +69,7 @@ class CDVDErrorAverage
     m_count++;
   }
 
-  void Flush(int interval = 500)
+  void Flush(int interval = 100)
   {
     m_buffer = 0.0f;
     m_count  = 0;
@@ -84,7 +84,7 @@ class CDVDErrorAverage
       return 0.0;
   }
 
-  bool Get(double& error, int interval = 500)
+  bool Get(double& error, int interval = 100)
   {
     if(m_timer.IsTimePast())
     {

From 9a35c9bd5494c4b9a39339fe5c9205f8f2890a9b Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Fri, 3 Apr 2015 10:49:55 +0200
Subject: [PATCH 79/89] dvdplayer: cosmetics

---
 xbmc/cores/dvdplayer/DVDPlayer.cpp | 41 ++++++++++++++++++++------------------
 1 file changed, 22 insertions(+), 19 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDPlayer.cpp b/xbmc/cores/dvdplayer/DVDPlayer.cpp
index 8ceb498..1f220c6 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayer.cpp
@@ -1454,16 +1454,18 @@ void CDVDPlayer::Process()
 
         m_OmxPlayerState.bOmxSentEOFs = true;
       }
+
       if(m_CurrentAudio.inited)
-        m_dvdPlayerAudio->SendMessage   (new CDVDMsg(CDVDMsg::GENERAL_EOF));
+        m_dvdPlayerAudio->SendMessage(new CDVDMsg(CDVDMsg::GENERAL_EOF));
       if(m_CurrentVideo.inited)
-        m_dvdPlayerVideo->SendMessage   (new CDVDMsg(CDVDMsg::GENERAL_EOF));
+        m_dvdPlayerVideo->SendMessage(new CDVDMsg(CDVDMsg::GENERAL_EOF));
       if(m_CurrentSubtitle.inited)
         m_dvdPlayerSubtitle->SendMessage(new CDVDMsg(CDVDMsg::GENERAL_EOF));
       if(m_CurrentTeletext.inited)
         m_dvdPlayerTeletext->SendMessage(new CDVDMsg(CDVDMsg::GENERAL_EOF));
-      m_CurrentAudio.inited    = false;
-      m_CurrentVideo.inited    = false;
+
+      m_CurrentAudio.inited = false;
+      m_CurrentVideo.inited = false;
       m_CurrentSubtitle.inited = false;
       m_CurrentTeletext.inited = false;
 
@@ -1573,21 +1575,22 @@ bool CDVDPlayer::CheckIsCurrent(CCurrentStream& current, CDemuxStream* stream, D
 
 void CDVDPlayer::ProcessPacket(CDemuxStream* pStream, DemuxPacket* pPacket)
 {
-    /* process packet if it belongs to selected stream. for dvd's don't allow automatic opening of streams*/
-
-      if (CheckIsCurrent(m_CurrentAudio, pStream, pPacket))
-        ProcessAudioData(pStream, pPacket);
-      else if (CheckIsCurrent(m_CurrentVideo, pStream, pPacket))
-        ProcessVideoData(pStream, pPacket);
-      else if (CheckIsCurrent(m_CurrentSubtitle, pStream, pPacket))
-        ProcessSubData(pStream, pPacket);
-      else if (CheckIsCurrent(m_CurrentTeletext, pStream, pPacket))
-        ProcessTeletextData(pStream, pPacket);
-      else
-      {
-        pStream->SetDiscard(AVDISCARD_ALL);
-        CDVDDemuxUtils::FreeDemuxPacket(pPacket); // free it since we won't do anything with it
-      }
+  // process packet if it belongs to selected stream.
+  // for dvd's don't allow automatic opening of streams*/
+
+  if (CheckIsCurrent(m_CurrentAudio, pStream, pPacket))
+    ProcessAudioData(pStream, pPacket);
+  else if (CheckIsCurrent(m_CurrentVideo, pStream, pPacket))
+    ProcessVideoData(pStream, pPacket);
+  else if (CheckIsCurrent(m_CurrentSubtitle, pStream, pPacket))
+    ProcessSubData(pStream, pPacket);
+  else if (CheckIsCurrent(m_CurrentTeletext, pStream, pPacket))
+    ProcessTeletextData(pStream, pPacket);
+  else
+  {
+    pStream->SetDiscard(AVDISCARD_ALL);
+    CDVDDemuxUtils::FreeDemuxPacket(pPacket); // free it since we won't do anything with it
+  }
 }
 
 void CDVDPlayer::CheckStreamChanges(CCurrentStream& current, CDemuxStream* stream)

From 7c8937a10c0441e815ec4743dfc38b22c6f38d09 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Fri, 3 Apr 2015 14:03:44 +0200
Subject: [PATCH 80/89] dvdplayer/omxplayer: protect live streams (pvr) from
 stalling

---
 xbmc/cores/VideoRenderers/RenderManager.cpp |  9 +++++
 xbmc/cores/dvdplayer/DVDClock.cpp           | 53 +++++++++++++++--------------
 xbmc/cores/dvdplayer/DVDClock.h             | 10 ++++--
 xbmc/cores/dvdplayer/DVDPlayer.cpp          | 30 ++++++++++++++++
 xbmc/cores/dvdplayer/DVDPlayer.h            |  1 +
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp     |  5 +--
 xbmc/linux/OMXClock.cpp                     | 20 ++++++++++-
 xbmc/linux/OMXClock.h                       |  2 ++
 xbmc/video/VideoReferenceClock.cpp          |  8 +++++
 xbmc/video/VideoReferenceClock.h            |  1 +
 10 files changed, 106 insertions(+), 33 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index 25323ef..25d3809 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -175,6 +175,15 @@ void CXBMCRenderManager::WaitPresentTime(double presenttime)
     return;
   }
 
+  CDVDClock *dvdclock = CDVDClock::GetMasterClock();
+  if(dvdclock != NULL && dvdclock->GetSpeedAdjust() != 0.0)
+  {
+    CDVDClock::WaitAbsoluteClock(presenttime * DVD_TIME_BASE);
+    m_presenterr = 0;
+    m_presentcorr = 0;
+    return;
+  }
+
   double clock     = CDVDClock::WaitAbsoluteClock(presenttime * DVD_TIME_BASE) / DVD_TIME_BASE;
   double target    = 0.5;
   double error     = ( clock - presenttime ) / frametime - target;
diff --git a/xbmc/cores/dvdplayer/DVDClock.cpp b/xbmc/cores/dvdplayer/DVDClock.cpp
index a496ec0..2629530 100644
--- a/xbmc/cores/dvdplayer/DVDClock.cpp
+++ b/xbmc/cores/dvdplayer/DVDClock.cpp
@@ -29,7 +29,7 @@
 int64_t CDVDClock::m_systemOffset;
 int64_t CDVDClock::m_systemFrequency;
 CCriticalSection CDVDClock::m_systemsection;
-CDVDClock *CDVDClock::m_playerclock = NULL;;
+CDVDClock *CDVDClock::m_playerclock = NULL;
 
 CDVDClock::CDVDClock()
   :  m_master(MASTER_CLOCK_NONE)
@@ -42,6 +42,9 @@ CDVDClock::CDVDClock()
   m_bReset = true;
   m_iDisc = 0;
   m_maxspeedadjust = 0.0;
+  m_lastSystemTime = g_VideoReferenceClock.GetTime();
+  m_systemAdjust = 0;
+  m_speedAdjust = 0;
 
   m_startClock = 0;
 
@@ -103,7 +106,12 @@ CDVDClock* CDVDClock::GetMasterClock()
 double CDVDClock::GetClock(bool interpolated /*= true*/)
 {
   CSharedLock lock(m_critSection);
-  return SystemToPlaying(g_VideoReferenceClock.GetTime(interpolated));
+
+  int64_t current = g_VideoReferenceClock.GetTime(interpolated);
+  m_systemAdjust += m_speedAdjust * (current - m_lastSystemTime);
+  m_lastSystemTime = current;
+
+  return SystemToPlaying(current);
 }
 
 double CDVDClock::GetClock(double& absolute, bool interpolated /*= true*/)
@@ -115,8 +123,7 @@ double CDVDClock::GetClock(double& absolute, bool interpolated /*= true*/)
     absolute = SystemToAbsolute(current);
   }
 
-  CSharedLock lock(m_critSection);
-  return SystemToPlaying(current);
+  return GetClock(interpolated);
 }
 
 void CDVDClock::SetSpeed(int iSpeed)
@@ -145,6 +152,18 @@ void CDVDClock::SetSpeed(int iSpeed)
   m_systemUsed = newfreq;
 }
 
+void CDVDClock::SetSpeedAdjust(double adjust)
+{
+  CExclusiveLock lock(m_critSection);
+  m_speedAdjust = adjust;
+}
+
+double CDVDClock::GetSpeedAdjust()
+{
+  CExclusiveLock lock(m_critSection);
+  return m_speedAdjust;
+}
+
 bool CDVDClock::Update(double clock, double absolute, double limit, const char* log)
 {
   CExclusiveLock lock(m_critSection);
@@ -174,26 +193,8 @@ void CDVDClock::Discontinuity(double clock, double absolute)
     m_pauseClock = m_startClock;
   m_iDisc = clock;
   m_bReset = false;
-}
-
-void CDVDClock::Pause()
-{
-  CExclusiveLock lock(m_critSection);
-  if(!m_pauseClock)
-    m_pauseClock = g_VideoReferenceClock.GetTime();
-}
-
-void CDVDClock::Resume()
-{
-  CExclusiveLock lock(m_critSection);
-  if( m_pauseClock )
-  {
-    int64_t current;
-    current = g_VideoReferenceClock.GetTime();
-
-    m_startClock += current - m_pauseClock;
-    m_pauseClock = 0;
-  }
+  m_systemAdjust = 0;
+  m_speedAdjust = 0;
 }
 
 void CDVDClock::SetMaxSpeedAdjust(double speed)
@@ -265,6 +266,8 @@ double CDVDClock::SystemToPlaying(int64_t system)
     if(m_pauseClock)
       m_pauseClock = m_startClock;
     m_iDisc = 0;
+    m_systemAdjust = 0;
+    m_speedAdjust = 0;
     m_bReset = false;
   }
   
@@ -273,7 +276,7 @@ double CDVDClock::SystemToPlaying(int64_t system)
   else
     current = system;
 
-  return DVD_TIME_BASE * (double)(current - m_startClock) / m_systemUsed + m_iDisc;
+  return DVD_TIME_BASE * (double)(current - m_startClock + m_systemAdjust) / m_systemUsed + m_iDisc;
 }
 
 EMasterClock CDVDClock::GetMaster()
diff --git a/xbmc/cores/dvdplayer/DVDClock.h b/xbmc/cores/dvdplayer/DVDClock.h
index d6b2d0a..cf03af5 100644
--- a/xbmc/cores/dvdplayer/DVDClock.h
+++ b/xbmc/cores/dvdplayer/DVDClock.h
@@ -66,9 +66,9 @@ class CDVDClock
   }
 
   void Reset() { m_bReset = true; }
-  void Pause();
-  void Resume();
   void SetSpeed(int iSpeed);
+  void SetSpeedAdjust(double adjust);
+  double GetSpeedAdjust();
 
   double GetClockSpeed(); /**< get the current speed of the clock relative normal system time */
 
@@ -101,7 +101,11 @@ class CDVDClock
   static int64_t m_systemOffset;
   static CCriticalSection m_systemsection;
 
-  double           m_maxspeedadjust;
+  int64_t m_systemAdjust;
+  int64_t m_lastSystemTime;
+  double m_speedAdjust;
+
+  double m_maxspeedadjust;
   CCriticalSection m_speedsection;
   static CDVDClock *m_playerclock;
 };
diff --git a/xbmc/cores/dvdplayer/DVDPlayer.cpp b/xbmc/cores/dvdplayer/DVDPlayer.cpp
index 1f220c6..4db38e2 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayer.cpp
@@ -1841,6 +1841,7 @@ void CDVDPlayer::HandlePlaySpeed()
   if(m_caching != caching)
     SetCaching(caching);
 
+  // check buffering levels and adjust clock
   if (m_playSpeed == DVD_PLAYSPEED_NORMAL && m_caching == CACHESTATE_DONE)
   {
     // due to i.e. discontinuities of pts the stream may have drifted away
@@ -1851,6 +1852,31 @@ void CDVDPlayer::HandlePlaySpeed()
       CLog::Log(LOGDEBUG,"CDVDPlayer::HandlePlaySpeed - audio stream stalled, tiggering re-sync");
       TriggerResync();
     }
+
+    if (CachePVRStream())
+    {
+      if (m_CurrentAudio.id >= 0)
+      {
+        double adjust = -1.0; // a unique value
+        if (m_clock.GetSpeedAdjust() == 0.0 && m_dvdPlayerAudio->GetLevel() < 5)
+          adjust = -0.01;
+        else if (m_clock.GetSpeedAdjust() == 0.0 && m_dvdPlayerAudio->GetLevel() > 95)
+          adjust = 0.01;
+
+        if (m_clock.GetSpeedAdjust() < 0 && m_dvdPlayerAudio->GetLevel() > 20)
+          adjust = 0.0;
+        else if (m_clock.GetSpeedAdjust() > 0 && m_dvdPlayerAudio->GetLevel() < 80)
+          adjust = 0.0;
+
+        if (adjust != -1.0)
+        {
+          m_clock.SetSpeedAdjust(adjust);
+          if (m_omxplayer_mode)
+            m_OmxPlayerState.av_clock.OMXSetSpeedAdjust(adjust);
+          CLog::Log(LOGDEBUG, "CDVDPlayer::HandlePlaySpeed set clock adjust: %f", adjust);
+        }
+      }
+    }
   }
 
   if(GetPlaySpeed() != DVD_PLAYSPEED_NORMAL && GetPlaySpeed() != DVD_PLAYSPEED_PAUSE)
@@ -2762,6 +2788,10 @@ void CDVDPlayer::SetCaching(ECacheState state)
     m_pInputStream->ResetScanTimeout(0);
   }
   m_caching = state;
+
+  m_clock.SetSpeedAdjust(0);
+  if (m_omxplayer_mode)
+    m_OmxPlayerState.av_clock.OMXSetSpeedAdjust(0);
 }
 
 void CDVDPlayer::SetPlaySpeed(int speed)
diff --git a/xbmc/cores/dvdplayer/DVDPlayer.h b/xbmc/cores/dvdplayer/DVDPlayer.h
index 3b8cefb..3dbb809 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.h
+++ b/xbmc/cores/dvdplayer/DVDPlayer.h
@@ -68,6 +68,7 @@ class OMXClock
   bool OMXStateExecute(bool lock = true) { return false; }
   void OMXStateIdle(bool lock = true) {}
   bool HDMIClockSync(bool lock = true) { return false; }
+  void OMXSetSpeedAdjust(double adjust, bool lock = true) {}
 };
 #endif
 
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 5832c58..f5e6de9 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -201,10 +201,7 @@ bool CDVDPlayerVideo::OpenStream( CDVDStreamInfo &hint )
     return false;
   }
 
-  if(CSettings::Get().GetBool("videoplayer.usedisplayasclock") && !g_VideoReferenceClock.IsRunning())
-  {
-    g_VideoReferenceClock.Create();
-  }
+  g_VideoReferenceClock.Start();
 
   if(m_messageQueue.IsInited())
     m_messageQueue.Put(new CDVDMsgVideoCodecChange(hint, codec), 0);
diff --git a/xbmc/linux/OMXClock.cpp b/xbmc/linux/OMXClock.cpp
index 46df52e..4f094df 100644
--- a/xbmc/linux/OMXClock.cpp
+++ b/xbmc/linux/OMXClock.cpp
@@ -45,6 +45,7 @@ OMXClock::OMXClock()
   m_clock        = NULL;
   m_last_media_time = 0.0f;
   m_last_media_time_read = 0.0f;
+  m_speedAdjust = 0;
 
   pthread_mutex_init(&m_lock, NULL);
 }
@@ -477,7 +478,7 @@ bool OMXClock::OMXSetSpeed(int speed, bool lock /* = true */, bool pause_resume
   if(lock)
     Lock();
 
-  CLog::Log(LOGDEBUG, "OMXClock::OMXSetSpeed(%.2f) pause_resume:%d", (float)speed / (float)DVD_PLAYSPEED_NORMAL, pause_resume);
+  CLog::Log(LOGDEBUG, "OMXClock::OMXSetSpeed(%.3f) pause_resume:%d", (float)speed / (float)DVD_PLAYSPEED_NORMAL * (1.0 + m_speedAdjust), pause_resume);
 
   if (pause_resume)
   {
@@ -485,6 +486,8 @@ bool OMXClock::OMXSetSpeed(int speed, bool lock /* = true */, bool pause_resume
     OMX_INIT_STRUCTURE(scaleType);
 
     scaleType.xScale = (speed << 16) / DVD_PLAYSPEED_NORMAL;
+    scaleType.xScale += scaleType.xScale * m_speedAdjust;
+
     OMX_ERRORTYPE omx_err = m_omx_clock.SetConfig(OMX_IndexConfigTimeScale, &scaleType);
     if(omx_err != OMX_ErrorNone)
     {
@@ -504,6 +507,21 @@ bool OMXClock::OMXSetSpeed(int speed, bool lock /* = true */, bool pause_resume
   return true;
 }
 
+void OMXClock::OMXSetSpeedAdjust(double adjust, bool lock /* = true */)
+{
+  if(lock)
+    Lock();
+  // we only support resampling (and hence clock adjustment) in this mode
+  if (CSettings::Get().GetBool("videoplayer.usedisplayasclock"))
+  {
+    m_speedAdjust = adjust;
+    OMXSetSpeed(m_omx_speed, false, true);
+    m_last_media_time = 0.0f;
+  }
+  if(lock)
+    UnLock();
+}
+
 bool OMXClock::OMXFlush(bool lock)
 {
   if(m_omx_clock.GetComponent() == NULL)
diff --git a/xbmc/linux/OMXClock.h b/xbmc/linux/OMXClock.h
index 8f06134..df0d4cf 100644
--- a/xbmc/linux/OMXClock.h
+++ b/xbmc/linux/OMXClock.h
@@ -59,6 +59,7 @@ class OMXClock
   COMXCoreComponent m_omx_clock;
   double            m_last_media_time;
   double            m_last_media_time_read;
+  double            m_speedAdjust;
 public:
   OMXClock();
   ~OMXClock();
@@ -82,6 +83,7 @@ class OMXClock
   bool OMXPause(bool lock = true);
   bool OMXResume(bool lock = true);
   bool OMXSetSpeed(int speed, bool lock = true, bool pause_resume = false);
+  void OMXSetSpeedAdjust(double adjust, bool lock = true);
   int  OMXPlaySpeed() { return m_omx_speed; };
   bool OMXFlush(bool lock = true);
   COMXCoreComponent *GetOMXClock();
diff --git a/xbmc/video/VideoReferenceClock.cpp b/xbmc/video/VideoReferenceClock.cpp
index f97e0bf..a363c36 100644
--- a/xbmc/video/VideoReferenceClock.cpp
+++ b/xbmc/video/VideoReferenceClock.cpp
@@ -28,6 +28,7 @@
 #include "guilib/GraphicContext.h"
 #include "video/videosync/VideoSync.h"
 #include "windowing/WindowingFactory.h"
+#include "settings/Settings.h"
 
 #if defined(HAS_GLX)
 #include "video/videosync/VideoSyncGLX.h"
@@ -72,6 +73,13 @@ CVideoReferenceClock::~CVideoReferenceClock()
 {
 }
 
+void CVideoReferenceClock::Start()
+{
+  CSingleExit lock(g_graphicsContext);
+  if(CSettings::Get().GetBool("videoplayer.usedisplayasclock") && !IsRunning())
+    Create();
+}
+
 void CVideoReferenceClock::Stop()
 {
   CSingleExit lock(g_graphicsContext);
diff --git a/xbmc/video/VideoReferenceClock.h b/xbmc/video/VideoReferenceClock.h
index 937b53e..d0a9c3f 100644
--- a/xbmc/video/VideoReferenceClock.h
+++ b/xbmc/video/VideoReferenceClock.h
@@ -39,6 +39,7 @@ class CVideoReferenceClock : public CThread
     bool    GetClockInfo(int& MissedVblanks, double& ClockSpeed, double& RefreshRate);
     void    SetFineAdjust(double fineadjust);
     void    RefreshChanged();
+    void    Start();
     void    Stop();
 
   private:

From 1026004dc183fad879d872223a263c5f36aa1056 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 14 Apr 2015 17:51:27 +0100
Subject: [PATCH 81/89] Avoid double rate deinterlace when not fullscreen or
 with OSD

---
 xbmc/cores/VideoRenderers/MMALRenderer.cpp | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/VideoRenderers/MMALRenderer.cpp b/xbmc/cores/VideoRenderers/MMALRenderer.cpp
index c30de9c..998d3d5 100644
--- a/xbmc/cores/VideoRenderers/MMALRenderer.cpp
+++ b/xbmc/cores/VideoRenderers/MMALRenderer.cpp
@@ -32,6 +32,7 @@
 #include "windowing/WindowingFactory.h"
 #include "cores/dvdplayer/DVDCodecs/Video/MMALCodec.h"
 #include "xbmc/Application.h"
+#include "guilib/GUIWindowManager.h"
 
 #define CLASSNAME "CMMALRenderer"
 
@@ -551,7 +552,10 @@ bool CMMALRenderer::Supports(ESCALINGMETHOD method)
 
 EINTERLACEMETHOD CMMALRenderer::AutoInterlaceMethod()
 {
-  return VS_INTERLACEMETHOD_MMAL_ADVANCED;
+  if (!g_graphicsContext.IsFullScreenVideo() || g_windowManager.HasDialogOnScreen())
+    return VS_INTERLACEMETHOD_MMAL_ADVANCED_HALF;
+  else
+    return VS_INTERLACEMETHOD_MMAL_ADVANCED;
 }
 
 void CMMALRenderer::SetVideoRect(const CRect& InSrcRect, const CRect& InDestRect)

From 76b915c21c082ea4a827a3b5d1e7279ff7fba60b Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 16 Apr 2015 17:27:27 +0100
Subject: [PATCH 82/89] Enable zero copy

---
 xbmc/cores/VideoRenderers/MMALRenderer.cpp         |  6 ++++++
 xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp | 18 ++++++++++++++++--
 2 files changed, 22 insertions(+), 2 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/MMALRenderer.cpp b/xbmc/cores/VideoRenderers/MMALRenderer.cpp
index 998d3d5..3eb4060 100644
--- a/xbmc/cores/VideoRenderers/MMALRenderer.cpp
+++ b/xbmc/cores/VideoRenderers/MMALRenderer.cpp
@@ -133,6 +133,12 @@ bool CMMALRenderer::init_vout(ERenderFormat format)
       es_format->es->video.color_space = MMAL_COLOR_SPACE_SMPTE240M;
   }
 
+  if (m_format == RENDER_FMT_MMAL)
+  {
+    status = mmal_port_parameter_set_boolean(m_vout_input, MMAL_PARAMETER_ZERO_COPY,  MMAL_TRUE);
+    if (status != MMAL_SUCCESS)
+       CLog::Log(LOGERROR, "%s::%s Failed to enable zero copy mode on %s (status=%x %s)", CLASSNAME, __func__, m_vout_input->name, status, mmal_status_to_string(status));
+  }
   status = mmal_port_format_commit(m_vout_input);
   if (status != MMAL_SUCCESS)
   {
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
index 39d6e60..1ab5254 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
@@ -312,6 +312,11 @@ bool CMMALVideo::change_dec_output_format()
     CLog::Log(LOGERROR, "%s::%s Failed to query interlace type on %s (status=%x %s)", CLASSNAME, __func__, m_dec_output->name, status, mmal_status_to_string(status));
 
   mmal_format_copy(m_dec_output->format, m_es_format);
+
+  status = mmal_port_parameter_set_boolean(m_dec_output, MMAL_PARAMETER_ZERO_COPY,  MMAL_TRUE);
+  if (status != MMAL_SUCCESS)
+    CLog::Log(LOGERROR, "%s::%s Failed to enable zero copy mode on %s (status=%x %s)", CLASSNAME, __func__, m_dec_output->name, status, mmal_status_to_string(status));
+
   status = mmal_port_format_commit(m_dec_output);
   if (status != MMAL_SUCCESS)
   {
@@ -383,6 +388,11 @@ bool CMMALVideo::CreateDeinterlace(EINTERLACEMETHOD interlace_method)
   }
 
   mmal_format_copy(m_deint->output[0]->format, m_es_format);
+
+  status = mmal_port_parameter_set_boolean(m_deint->output[0], MMAL_PARAMETER_ZERO_COPY,  MMAL_TRUE);
+  if (status != MMAL_SUCCESS)
+    CLog::Log(LOGERROR, "%s::%s Failed to enable zero copy mode on %s (status=%x %s)", CLASSNAME, __func__, m_deint->output[0]->name, status, mmal_status_to_string(status));
+
   status = mmal_port_format_commit(m_deint->output[0]);
   if (status != MMAL_SUCCESS)
   {
@@ -661,6 +671,10 @@ bool CMMALVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, MMALVide
   m_dec_output->format->encoding = MMAL_ENCODING_OPAQUE;
   mmal_format_copy(m_es_format, m_dec_output->format);
 
+  status = mmal_port_parameter_set_boolean(m_dec_output, MMAL_PARAMETER_ZERO_COPY,  MMAL_TRUE);
+  if (status != MMAL_SUCCESS)
+    CLog::Log(LOGERROR, "%s::%s Failed to enable zero copy mode on %s (status=%x %s)", CLASSNAME, __func__, m_dec_output->name, status, mmal_status_to_string(status));
+
   status = mmal_port_format_commit(m_dec_output);
   if (status != MMAL_SUCCESS)
   {
@@ -685,14 +699,14 @@ bool CMMALVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, MMALVide
     return false;
   }
 
-  m_dec_input_pool = mmal_pool_create(m_dec_input->buffer_num, m_dec_input->buffer_size);
+  m_dec_input_pool = mmal_port_pool_create(m_dec_input, m_dec_input->buffer_num, m_dec_input->buffer_size);
   if (!m_dec_input_pool)
   {
     CLog::Log(LOGERROR, "%s::%s Failed to create pool for decoder input port (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
     return false;
   }
 
-  m_dec_output_pool = mmal_pool_create(m_dec_output->buffer_num, m_dec_output->buffer_size);
+  m_dec_output_pool = mmal_port_pool_create(m_dec_output, m_dec_output->buffer_num, m_dec_output->buffer_size);
   if(!m_dec_output_pool)
   {
     CLog::Log(LOGERROR, "%s::%s Failed to create pool for decode output port (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));

From 332c505cf424b7356a31aa5b2d44652377f4e490 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 16 Apr 2015 19:09:31 +0100
Subject: [PATCH 83/89] flags debug

---
 xbmc/cores/VideoRenderers/MMALRenderer.cpp         | 11 ++++++-----
 xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp |  2 ++
 2 files changed, 8 insertions(+), 5 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/MMALRenderer.cpp b/xbmc/cores/VideoRenderers/MMALRenderer.cpp
index 3eb4060..fa65c2b 100644
--- a/xbmc/cores/VideoRenderers/MMALRenderer.cpp
+++ b/xbmc/cores/VideoRenderers/MMALRenderer.cpp
@@ -49,12 +49,13 @@ void CMMALRenderer::vout_input_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *
 {
   #if defined(MMAL_DEBUG_VERBOSE)
   CMMALVideoBuffer *omvb = (CMMALVideoBuffer *)buffer->user_data;
-  CLog::Log(LOGDEBUG, "%s::%s port:%p buffer %p (%p), len %d cmd:%x", CLASSNAME, __func__, port, buffer, omvb, buffer->length, buffer->cmd);
+  CLog::Log(LOGDEBUG, "%s::%s port:%p buffer %p (%p), len %d cmd:%x f:%x", CLASSNAME, __func__, port, buffer, omvb, buffer->length, buffer->cmd, buffer->flags);
   #endif
 
+  assert(!(buffer->flags & MMAL_BUFFER_HEADER_FLAG_TRANSMISSION_FAILED));
+  buffer->flags &= ~MMAL_BUFFER_HEADER_FLAG_USER2;
   if (m_format == RENDER_FMT_MMAL)
   {
-    buffer->flags &= ~MMAL_BUFFER_HEADER_FLAG_USER2;
     mmal_queue_put(m_release_queue, buffer);
   }
   else if (m_format == RENDER_FMT_YUV420P)
@@ -377,7 +378,7 @@ void CMMALRenderer::RenderUpdate(bool clear, DWORD flags, DWORD alpha)
     if (omvb)
     {
 #if defined(MMAL_DEBUG_VERBOSE)
-      CLog::Log(LOGDEBUG, "%s::%s %p (%p)", CLASSNAME, __func__, omvb, omvb->mmal_buffer);
+      CLog::Log(LOGDEBUG, "%s::%s %p (%p) f:%x", CLASSNAME, __func__, omvb, omvb->mmal_buffer, omvb->mmal_buffer->flags);
 #endif
       // we only want to upload frames once
       if (omvb->mmal_buffer->flags & MMAL_BUFFER_HEADER_FLAG_USER1)
@@ -391,14 +392,14 @@ void CMMALRenderer::RenderUpdate(bool clear, DWORD flags, DWORD alpha)
   }
   else if (m_format == RENDER_FMT_YUV420P)
   {
-    CLog::Log(LOGDEBUG, "%s::%s - %p %d", CLASSNAME, __func__, buffer->mmal_buffer, source);
+    CLog::Log(LOGDEBUG, "%s::%s - %p %d f:%x", CLASSNAME, __func__, buffer->mmal_buffer, source, buffer->mmal_buffer->flags);
     if (buffer->mmal_buffer)
     {
       // we only want to upload frames once
       if (buffer->mmal_buffer->flags & MMAL_BUFFER_HEADER_FLAG_USER1)
         return;
       // sanity check it is not on display
-      buffer->mmal_buffer->flags |= MMAL_BUFFER_HEADER_FLAG_USER1;
+      buffer->mmal_buffer->flags |= MMAL_BUFFER_HEADER_FLAG_USER1 | MMAL_BUFFER_HEADER_FLAG_USER2;
       mmal_port_send_buffer(m_vout_input, buffer->mmal_buffer);
     }
     else
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
index 1ab5254..61cf8e2 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
@@ -83,6 +83,7 @@ long CMMALVideoBuffer::Release()
   {
     m_omv->ReleaseBuffer(this);
   }
+  else assert(count > 0);
   return count;
 }
 
@@ -247,6 +248,7 @@ void CMMALVideo::dec_output_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buf
 
   bool kept = false;
 
+  assert(!(buffer->flags & MMAL_BUFFER_HEADER_FLAG_TRANSMISSION_FAILED));
   if (buffer->cmd == 0)
   {
     if (buffer->length > 0)

From 1757168ee2f38cb7e56b27f9d8a4a8f180ed68b1 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 16 Apr 2015 18:18:14 +0100
Subject: [PATCH 84/89] Move the image pool from decoder to renderer

---
 xbmc/cores/VideoRenderers/BaseRenderer.h           |  5 ++
 xbmc/cores/VideoRenderers/MMALRenderer.cpp         | 77 ++++++++++++++++++----
 xbmc/cores/VideoRenderers/MMALRenderer.h           |  4 ++
 xbmc/cores/VideoRenderers/RenderManager.cpp        |  8 +++
 xbmc/cores/VideoRenderers/RenderManager.h          |  5 ++
 xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp | 30 ++-------
 xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h   |  2 -
 7 files changed, 91 insertions(+), 40 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/BaseRenderer.h b/xbmc/cores/VideoRenderers/BaseRenderer.h
index 389695a..264f0ad 100644
--- a/xbmc/cores/VideoRenderers/BaseRenderer.h
+++ b/xbmc/cores/VideoRenderers/BaseRenderer.h
@@ -112,6 +112,11 @@ class CBaseRenderer
 
   static void SettingOptionsRenderMethodsFiller(const CSetting *setting, std::vector< std::pair<std::string, int> > &list, int &current, void *data);
 
+  /**
+   * Magic api for communicating between codec and renderer
+   */
+  virtual void *PassCookie(void *cookie) { return NULL; }
+
 protected:
   void       ChooseBestResolution(float fps);
   bool       FindResolutionFromOverride(float fps, float& weight, bool fallback);
diff --git a/xbmc/cores/VideoRenderers/MMALRenderer.cpp b/xbmc/cores/VideoRenderers/MMALRenderer.cpp
index fa65c2b..5fbe2d2 100644
--- a/xbmc/cores/VideoRenderers/MMALRenderer.cpp
+++ b/xbmc/cores/VideoRenderers/MMALRenderer.cpp
@@ -40,6 +40,50 @@
 #define MMAL_DEBUG_VERBOSE
 #endif
 
+
+
+void CMMALRenderer::Prime()
+{
+  #if defined(MMAL_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s format:%d dec:%p pool:%p", CLASSNAME, __func__, m_format, m_mmal_video, m_vout_input_pool);
+  #endif
+
+  if (m_format != RENDER_FMT_MMAL || !m_vout_input_pool)
+    return;
+
+  MMAL_BUFFER_HEADER_T *buffer;
+  while (buffer = mmal_queue_get(m_vout_input_pool->queue), buffer)
+  {
+    CLog::Log(LOGDEBUG, "%s::%s buffer:%p mmal_video:%p", CLASSNAME, __func__, buffer, m_mmal_video);
+    if (m_mmal_video)
+    {
+      m_mmal_video->Recycle(buffer);
+    }
+    else
+    {
+      mmal_buffer_header_release(buffer);
+      break;
+    }
+  }
+}
+
+void *CMMALRenderer::PassCookie(void *cookie)
+{
+  m_mmal_video = (CMMALVideo *)cookie;
+  #if defined(MMAL_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s cookie:%p", CLASSNAME, __func__, cookie);
+  #endif
+
+  if (m_mmal_video)
+  {
+    bool formatChanged = m_format != RENDER_FMT_MMAL;
+    m_format = RENDER_FMT_MMAL;
+    m_bConfigured = init_vout(formatChanged);
+    Prime();
+  }
+  return NULL;
+}
+
 static void vout_control_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
 {
   mmal_buffer_header_release(buffer);
@@ -164,14 +208,11 @@ bool CMMALRenderer::init_vout(ERenderFormat format)
     return false;
   }
 
-  if (m_format == RENDER_FMT_YUV420P)
+  m_vout_input_pool = mmal_port_pool_create(m_vout_input , m_vout_input->buffer_num, m_vout_input->buffer_size);
+  if (!m_vout_input_pool)
   {
-    m_vout_input_pool = mmal_pool_create(m_vout_input->buffer_num, m_vout_input->buffer_size);
-    if (!m_vout_input_pool)
-    {
-      CLog::Log(LOGERROR, "%s::%s Failed to create pool for decoder input port (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
-      return false;
-    }
+    CLog::Log(LOGERROR, "%s::%s Failed to create pool for decoder input port (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
+    return false;
   }
   return true;
 }
@@ -179,10 +220,17 @@ bool CMMALRenderer::init_vout(ERenderFormat format)
 void CMMALRenderer::Process()
 {
   MMAL_BUFFER_HEADER_T *buffer;
-  while (buffer = mmal_queue_wait(m_release_queue), buffer && buffer != &m_quit_packet)
+  while (buffer = mmal_queue_timedwait(m_release_queue, 100), buffer != &m_quit_packet)
   {
-    CMMALVideoBuffer *omvb = (CMMALVideoBuffer *)buffer->user_data;
-    omvb->Release();
+    if (buffer)
+    {
+      CMMALVideoBuffer *omvb = (CMMALVideoBuffer *)buffer->user_data;
+      omvb->Release();
+    }
+    else
+    {
+      Prime();
+    }
   }
   m_sync.Set();
 }
@@ -382,7 +430,7 @@ void CMMALRenderer::RenderUpdate(bool clear, DWORD flags, DWORD alpha)
 #endif
       // we only want to upload frames once
       if (omvb->mmal_buffer->flags & MMAL_BUFFER_HEADER_FLAG_USER1)
-        return;
+        goto done;
       omvb->Acquire();
       omvb->mmal_buffer->flags |= MMAL_BUFFER_HEADER_FLAG_USER1 | MMAL_BUFFER_HEADER_FLAG_USER2;
       mmal_port_send_buffer(m_vout_input, omvb->mmal_buffer);
@@ -397,7 +445,7 @@ void CMMALRenderer::RenderUpdate(bool clear, DWORD flags, DWORD alpha)
     {
       // we only want to upload frames once
       if (buffer->mmal_buffer->flags & MMAL_BUFFER_HEADER_FLAG_USER1)
-        return;
+        goto done;
       // sanity check it is not on display
       buffer->mmal_buffer->flags |= MMAL_BUFFER_HEADER_FLAG_USER1 | MMAL_BUFFER_HEADER_FLAG_USER2;
       mmal_port_send_buffer(m_vout_input, buffer->mmal_buffer);
@@ -406,6 +454,8 @@ void CMMALRenderer::RenderUpdate(bool clear, DWORD flags, DWORD alpha)
       CLog::Log(LOGDEBUG, "%s::%s - No buffer to update", CLASSNAME, __func__);
   }
   else assert(0);
+done:
+  Prime();
 }
 
 void CMMALRenderer::FlipPage(int source)
@@ -467,6 +517,8 @@ void CMMALRenderer::UnInitMMAL()
     m_vout_input = NULL;
   }
 
+  ReleaseBuffers();
+
   if (m_vout_input_pool)
   {
     mmal_pool_destroy(m_vout_input_pool);
@@ -478,7 +530,6 @@ void CMMALRenderer::UnInitMMAL()
     mmal_component_release(m_vout);
     m_vout = NULL;
   }
-  ReleaseBuffers();
 
   m_RenderUpdateCallBackFn = NULL;
   m_RenderUpdateCallBackCtx = NULL;
diff --git a/xbmc/cores/VideoRenderers/MMALRenderer.h b/xbmc/cores/VideoRenderers/MMALRenderer.h
index 17b189e..f515d7a 100644
--- a/xbmc/cores/VideoRenderers/MMALRenderer.h
+++ b/xbmc/cores/VideoRenderers/MMALRenderer.h
@@ -40,6 +40,7 @@
 
 class CBaseTexture;
 class CMMALVideoBuffer;
+class CMMALVideo;
 
 struct DVDVideoPicture;
 
@@ -90,6 +91,7 @@ class CMMALRenderer : public CBaseRenderer, public CThread
   virtual bool         IsGuiLayer() { return false; }
 
   void vout_input_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer);
+  virtual void        *PassCookie(void *cookie);
 protected:
   int m_iYV12RenderBuffer;
   int m_NumYV12Buffers;
@@ -116,8 +118,10 @@ class CMMALRenderer : public CBaseRenderer, public CThread
   MMAL_QUEUE_T     *m_release_queue;
   CEvent            m_sync;
   MMAL_BUFFER_HEADER_T m_quit_packet;
+  CMMALVideo *m_mmal_video;
 
   bool init_vout(ERenderFormat format);
   void ReleaseBuffers();
   void UnInitMMAL();
+  void Prime();
 };
diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index 25d3809..89faa65 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -949,6 +949,14 @@ unsigned int CXBMCRenderManager::GetOptimalBufferSize()
   return m_pRenderer->GetMaxBufferSize();
 }
 
+void *CXBMCRenderManager::PassCookie(void *cookie)
+{
+  if (m_pRenderer)
+    return m_pRenderer->PassCookie(cookie);
+  assert(0);
+}
+
+
 // Supported pixel formats, can be called before configure
 std::vector<ERenderFormat> CXBMCRenderManager::SupportedFormats()
 {
diff --git a/xbmc/cores/VideoRenderers/RenderManager.h b/xbmc/cores/VideoRenderers/RenderManager.h
index f32f4a9..1d8fe88 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.h
+++ b/xbmc/cores/VideoRenderers/RenderManager.h
@@ -195,6 +195,11 @@ class CXBMCRenderManager
    */
   void DiscardBuffer();
 
+  /**
+   * Magic api for communicating between codec and renderer
+   */
+  void *PassCookie(void *cookie);
+
 protected:
 
   void PresentSingle(bool clear, DWORD flags, DWORD alpha);
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
index 61cf8e2..1fdc44c 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
@@ -111,7 +111,6 @@ CMMALVideo::CMMALVideo()
   m_dec_input = NULL;
   m_dec_output = NULL;
   m_dec_input_pool = NULL;
-  m_dec_output_pool = NULL;
 
   m_deint = NULL;
   m_deint_connection = NULL;
@@ -162,10 +161,6 @@ CMMALVideo::~CMMALVideo()
     mmal_pool_destroy(m_dec_input_pool);
   m_dec_input_pool = NULL;
 
-  if (m_dec_output_pool)
-    mmal_pool_destroy(m_dec_output_pool);
-  m_dec_output_pool = NULL;
-
   if (m_deint)
     mmal_component_destroy(m_deint);
   m_deint = NULL;
@@ -421,7 +416,7 @@ bool CMMALVideo::CreateDeinterlace(EINTERLACEMETHOD interlace_method)
 
   m_dec_output = m_deint->output[0];
   m_interlace_method = interlace_method;
-  Prime();
+
   return true;
 }
 
@@ -477,7 +472,7 @@ bool CMMALVideo::DestroyDeinterlace()
 
   m_dec_output = m_dec->output[0];
   m_interlace_method = VS_INTERLACEMETHOD_NONE;
-  Prime();
+
   return true;
 }
 
@@ -708,21 +703,14 @@ bool CMMALVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, MMALVide
     return false;
   }
 
-  m_dec_output_pool = mmal_port_pool_create(m_dec_output, m_dec_output->buffer_num, m_dec_output->buffer_size);
-  if(!m_dec_output_pool)
-  {
-    CLog::Log(LOGERROR, "%s::%s Failed to create pool for decode output port (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
-    return false;
-  }
-
   if (!SendCodecConfigData())
     return false;
 
-  Prime();
   m_startframe = false;
   m_preroll = !m_hints.stills;
   m_speed = DVD_PLAYSPEED_NORMAL;
 
+  g_renderManager.PassCookie(this);
   return true;
 }
 
@@ -730,6 +718,7 @@ void CMMALVideo::Dispose()
 {
   // we are happy to exit, but let last shared pointer being deleted trigger the destructor
   bool done = false;
+  g_renderManager.PassCookie(NULL);
   m_finished = true;
   Reset();
   pthread_mutex_lock(&m_output_mutex);
@@ -905,13 +894,6 @@ int CMMALVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
   return ret;
 }
 
-void CMMALVideo::Prime()
-{
-  MMAL_BUFFER_HEADER_T *buffer;
-  while (buffer = mmal_queue_get(m_dec_output_pool->queue), buffer)
-    Recycle(buffer);
-}
-
 void CMMALVideo::Reset(void)
 {
   if (g_advancedSettings.CanLogComponent(LOGVIDEO))
@@ -957,10 +939,8 @@ void CMMALVideo::Reset(void)
   pthread_mutex_unlock(&m_output_mutex);
 
   if (!m_finished)
-  {
     SendCodecConfigData();
-    Prime();
-  }
+
   m_startframe = false;
   m_decoderPts = DVD_NOPTS_VALUE;
   m_preroll = !m_hints.stills && (m_speed == DVD_PLAYSPEED_NORMAL || m_speed == DVD_PLAYSPEED_PAUSE);
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h
index fcc6a15..204f004 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h
@@ -103,7 +103,6 @@ class CMMALVideo
   void QueryCodec(void);
   bool CreateDeinterlace(EINTERLACEMETHOD interlace_method);
   bool DestroyDeinterlace();
-  void Prime();
 
   // Video format
   int               m_decoded_width;
@@ -141,7 +140,6 @@ class CMMALVideo
   MMAL_PORT_T *m_dec_input;
   MMAL_PORT_T *m_dec_output;
   MMAL_POOL_T *m_dec_input_pool;
-  MMAL_POOL_T *m_dec_output_pool;
 
   MMAL_ES_FORMAT_T *m_es_format;
   MMAL_COMPONENT_T *m_deint;

From 77dd3b8de1d73d01867d190bbcd4a82e67179c44 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 17 Apr 2015 16:07:40 +0100
Subject: [PATCH 85/89] Separate mmal and renderer configured flags

---
 xbmc/cores/VideoRenderers/MMALRenderer.cpp | 26 +++++++++++++++-----------
 xbmc/cores/VideoRenderers/MMALRenderer.h   |  1 +
 2 files changed, 16 insertions(+), 11 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/MMALRenderer.cpp b/xbmc/cores/VideoRenderers/MMALRenderer.cpp
index 5fbe2d2..fe3dce4 100644
--- a/xbmc/cores/VideoRenderers/MMALRenderer.cpp
+++ b/xbmc/cores/VideoRenderers/MMALRenderer.cpp
@@ -74,13 +74,12 @@ void *CMMALRenderer::PassCookie(void *cookie)
   CLog::Log(LOGDEBUG, "%s::%s cookie:%p", CLASSNAME, __func__, cookie);
   #endif
 
-  if (m_mmal_video)
-  {
-    bool formatChanged = m_format != RENDER_FMT_MMAL;
-    m_format = RENDER_FMT_MMAL;
-    m_bConfigured = init_vout(formatChanged);
+  if (m_mmal_video && !m_bMMALConfigured)
+    m_bMMALConfigured = init_vout(RENDER_FMT_MMAL);
+
+  if (m_mmal_video && m_bMMALConfigured)
     Prime();
-  }
+
   return NULL;
 }
 
@@ -122,10 +121,10 @@ bool CMMALRenderer::init_vout(ERenderFormat format)
 
   CLog::Log(LOGDEBUG, "%s::%s configured:%d format:%d->%d", CLASSNAME, __func__, m_bConfigured, m_format, format);
 
-  if (m_bConfigured && formatChanged)
+  if (m_bMMALConfigured && formatChanged)
     UnInitMMAL();
 
-  if (m_bConfigured)
+  if (m_bMMALConfigured)
     return true;
 
   m_format = RENDER_FMT_MMAL;
@@ -247,6 +246,8 @@ CMMALRenderer::CMMALRenderer()
   m_release_queue = mmal_queue_create();
   m_iFlags = 0;
   m_format = RENDER_FMT_NONE;
+  m_bConfigured = false;
+  m_bMMALConfigured = false;
   m_iYV12RenderBuffer = 0;
   Create();
 }
@@ -297,8 +298,9 @@ bool CMMALRenderer::Configure(unsigned int width, unsigned int height, unsigned
   SetViewMode(CMediaSettings::Get().GetCurrentVideoSettings().m_ViewMode);
   ManageDisplay();
 
-  m_bConfigured = init_vout(format);
-
+  m_bMMALConfigured = init_vout(format);
+  m_bConfigured = m_bMMALConfigured;
+  assert(m_bConfigured);
   return m_bConfigured;
 }
 
@@ -361,7 +363,8 @@ int CMMALRenderer::GetImage(YV12Image *image, int source, bool readonly)
 
 void CMMALRenderer::ReleaseBuffer(int idx)
 {
-  if (!m_bConfigured || m_format == RENDER_FMT_BYPASS)
+  CSingleLock lock(m_sharedSection);
+  if (!m_bMMALConfigured || m_format == RENDER_FMT_BYPASS)
     return;
 
 #if defined(MMAL_DEBUG_VERBOSE)
@@ -541,6 +544,7 @@ void CMMALRenderer::UnInitMMAL()
   m_StereoInvert = false;
 
   m_bConfigured = false;
+  m_bMMALConfigured = false;
 }
 
 void CMMALRenderer::UnInit()
diff --git a/xbmc/cores/VideoRenderers/MMALRenderer.h b/xbmc/cores/VideoRenderers/MMALRenderer.h
index f515d7a..a694182 100644
--- a/xbmc/cores/VideoRenderers/MMALRenderer.h
+++ b/xbmc/cores/VideoRenderers/MMALRenderer.h
@@ -100,6 +100,7 @@ class CMMALRenderer : public CBaseRenderer, public CThread
 
   YUVBUFFER            m_buffers[NUM_BUFFERS];
   bool                 m_bConfigured;
+  bool                 m_bMMALConfigured;
   unsigned int         m_extended_format;
   unsigned int         m_destWidth;
   unsigned int         m_destHeight;

From abe0fca00a2e5b063ff45037f543429f4c87305c Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 16 Apr 2015 21:43:27 +0100
Subject: [PATCH 86/89] Separate the buffers from the decoder so decoder can be
 destroyed first

---
 .../DVDCodecs/Video/DVDVideoCodecMMAL.cpp          |  4 +-
 .../dvdplayer/DVDCodecs/Video/DVDVideoCodecMMAL.h  |  2 +-
 xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp | 63 ++++++----------------
 xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h   |  6 +--
 4 files changed, 20 insertions(+), 55 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMMAL.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMMAL.cpp
index ee7d6f2..48e347c 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMMAL.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMMAL.cpp
@@ -44,11 +44,13 @@ CDVDVideoCodecMMAL::~CDVDVideoCodecMMAL()
 {
   CLog::Log(LOGDEBUG, "%s::%s %p\n", CLASSNAME, __func__, this);
   Dispose();
+  delete m_decoder;
+  m_decoder = NULL;
 }
 
 bool CDVDVideoCodecMMAL::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
 {
-  return m_decoder->Open(hints, options, m_decoder);
+  return m_decoder->Open(hints, options);
 }
 
 const char* CDVDVideoCodecMMAL::GetName(void)
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMMAL.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMMAL.h
index aa8e87f..6014363 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMMAL.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMMAL.h
@@ -46,7 +46,7 @@ class CDVDVideoCodecMMAL : public CDVDVideoCodec
   virtual void SetSpeed(int iSpeed);
 
 protected:
-  MMALVideoPtr m_decoder;
+  CMMALVideo *m_decoder;
 };
 
 #endif
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
index 1fdc44c..7a45c25 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
@@ -81,7 +81,8 @@ long CMMALVideoBuffer::Release()
     CLog::Log(LOGDEBUG, "%s::%s %p (%p) ref:%ld", CLASSNAME, __func__, this, mmal_buffer, count);
   if (count == 0)
   {
-    m_omv->ReleaseBuffer(this);
+    mmal_buffer_header_release(mmal_buffer);
+    delete this;
   }
   else assert(count > 0);
   return count;
@@ -117,7 +118,6 @@ CMMALVideo::CMMALVideo()
 
   m_codingType = 0;
 
-  m_output_busy = 0;
   m_demux_queue_length = 0;
   m_es_format = mmal_format_alloc();
   m_preroll = true;
@@ -261,7 +261,6 @@ void CMMALVideo::dec_output_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buf
         omvb->height = m_decoded_height;
         omvb->m_aspect_ratio = m_aspect_ratio;
         pthread_mutex_lock(&m_output_mutex);
-        m_output_busy++;
         m_output_ready.push(omvb);
         pthread_mutex_unlock(&m_output_mutex);
         kept = true;
@@ -505,7 +504,7 @@ bool CMMALVideo::SendCodecConfigData()
   return true;
 }
 
-bool CMMALVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, MMALVideoPtr myself)
+bool CMMALVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
 {
   if (g_advancedSettings.CanLogComponent(LOGVIDEO))
     CLog::Log(LOGDEBUG, "%s::%s usemmal:%d software:%d %dx%d", CLASSNAME, __func__, CSettings::Get().GetBool("videoplayer.usemmal"), hints.software, hints.width, hints.height);
@@ -518,7 +517,6 @@ bool CMMALVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, MMALVide
   MMAL_STATUS_T status;
   MMAL_PARAMETER_BOOLEAN_T error_concealment;
 
-  m_myself = myself;
   m_decoded_width  = hints.width;
   m_decoded_height = hints.height;
 
@@ -716,21 +714,9 @@ bool CMMALVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, MMALVide
 
 void CMMALVideo::Dispose()
 {
-  // we are happy to exit, but let last shared pointer being deleted trigger the destructor
-  bool done = false;
   g_renderManager.PassCookie(NULL);
   m_finished = true;
   Reset();
-  pthread_mutex_lock(&m_output_mutex);
-  if (!m_output_busy)
-    done = true;
-  pthread_mutex_unlock(&m_output_mutex);
-  if (g_advancedSettings.CanLogComponent(LOGVIDEO))
-    CLog::Log(LOGDEBUG, "%s::%s ready_queue(%d) busy_queue(%d) done:%d", CLASSNAME, __func__, m_output_ready.size(), m_output_busy, done);
-  if (done)
-  {
-    m_myself.reset();
-  }
 }
 
 void CMMALVideo::SetDropState(bool bDrop)
@@ -742,8 +728,8 @@ void CMMALVideo::SetDropState(bool bDrop)
 int CMMALVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
 {
   //if (g_advancedSettings.CanLogComponent(LOGVIDEO))
-  //  CLog::Log(LOGDEBUG, "%s::%s - %-8p %-6d dts:%.3f pts:%.3f ready_queue(%d) busy_queue(%d)",
-  //    CLASSNAME, __func__, pData, iSize, dts == DVD_NOPTS_VALUE ? 0.0 : dts*1e-6, pts == DVD_NOPTS_VALUE ? 0.0 : pts*1e-6, m_output_ready.size(), m_output_busy);
+  //  CLog::Log(LOGDEBUG, "%s::%s - %-8p %-6d dts:%.3f pts:%.3f ready_queue(%d)",
+  //    CLASSNAME, __func__, pData, iSize, dts == DVD_NOPTS_VALUE ? 0.0 : dts*1e-6, pts == DVD_NOPTS_VALUE ? 0.0 : pts*1e-6, m_output_ready.size());
 
   unsigned int demuxer_bytes = 0;
   uint8_t *demuxer_content = NULL;
@@ -819,8 +805,8 @@ int CMMALVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
          buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_END;
 
        if (g_advancedSettings.CanLogComponent(LOGVIDEO))
-         CLog::Log(LOGDEBUG, "%s::%s - %-8p %-6d/%-6d dts:%.3f pts:%.3f flags:%x ready_queue(%d) busy_queue(%d) demux_queue(%d) space(%d)",
-            CLASSNAME, __func__, buffer, buffer->length, demuxer_bytes, dts == DVD_NOPTS_VALUE ? 0.0 : dts*1e-6, pts == DVD_NOPTS_VALUE ? 0.0 : pts*1e-6, buffer->flags, m_output_ready.size(), m_output_busy, m_demux_queue_length, mmal_queue_length(m_dec_input_pool->queue) * m_dec_input->buffer_size);
+         CLog::Log(LOGDEBUG, "%s::%s - %-8p %-6d/%-6d dts:%.3f pts:%.3f flags:%x ready_queue(%d) demux_queue(%d) space(%d)",
+            CLASSNAME, __func__, buffer, buffer->length, demuxer_bytes, dts == DVD_NOPTS_VALUE ? 0.0 : dts*1e-6, pts == DVD_NOPTS_VALUE ? 0.0 : pts*1e-6, buffer->flags, m_output_ready.size(), m_demux_queue_length, mmal_queue_length(m_dec_input_pool->queue) * m_dec_input->buffer_size);
        assert((int)buffer->length > 0);
        status = mmal_port_send_buffer(m_dec_input, buffer);
        if (status != MMAL_SUCCESS)
@@ -887,8 +873,8 @@ int CMMALVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
   if (!ret)
   {
     if (g_advancedSettings.CanLogComponent(LOGVIDEO))
-      CLog::Log(LOGDEBUG, "%s::%s - Nothing to do: ready_queue(%d) busy_queue(%d) demux_queue(%d) space(%d) preroll(%d)",
-        CLASSNAME, __func__, m_output_ready.size(), m_output_busy, m_demux_queue_length, mmal_queue_length(m_dec_input_pool->queue) * m_dec_input->buffer_size, m_preroll);
+      CLog::Log(LOGDEBUG, "%s::%s - Nothing to do: ready_queue(%d) demux_queue(%d) space(%d) preroll(%d)",
+        CLASSNAME, __func__, m_output_ready.size(), m_demux_queue_length, mmal_queue_length(m_dec_input_pool->queue) * m_dec_input->buffer_size, m_preroll);
     Sleep(10); // otherwise we busy spin
   }
   return ret;
@@ -927,7 +913,10 @@ void CMMALVideo::Reset(void)
     }
     pthread_mutex_unlock(&m_output_mutex);
     if (buffer)
-      ReleaseBuffer(buffer);
+    {
+      buffer->Acquire();
+      buffer->Release();
+    }
     else
       break;
   }
@@ -970,8 +959,8 @@ void CMMALVideo::Recycle(MMAL_BUFFER_HEADER_T *buffer)
   mmal_buffer_header_reset(buffer);
   buffer->cmd = 0;
   if (g_advancedSettings.CanLogComponent(LOGVIDEO))
-    CLog::Log(LOGDEBUG, "%s::%s Send buffer %p from pool to decoder output port %p ready_queue(%d) busy_queue(%d)", CLASSNAME, __func__, buffer, m_dec_output,
-      m_output_ready.size(), m_output_busy);
+    CLog::Log(LOGDEBUG, "%s::%s Send buffer %p from pool to decoder output port %p ready_queue(%d)", CLASSNAME, __func__, buffer, m_dec_output,
+      m_output_ready.size());
   status = mmal_port_send_buffer(m_dec_output, buffer);
   if (status != MMAL_SUCCESS)
   {
@@ -980,28 +969,6 @@ void CMMALVideo::Recycle(MMAL_BUFFER_HEADER_T *buffer)
   }
 }
 
-void CMMALVideo::ReleaseBuffer(CMMALVideoBuffer *buffer)
-{
-  // remove from busy list
-  pthread_mutex_lock(&m_output_mutex);
-  assert(m_output_busy > 0);
-  m_output_busy--;
-  pthread_mutex_unlock(&m_output_mutex);
-  // sanity check it is not on display
-  assert(!(buffer->mmal_buffer->flags & MMAL_BUFFER_HEADER_FLAG_USER2));
-  Recycle(buffer->mmal_buffer);
-  bool done = false;
-  pthread_mutex_lock(&m_output_mutex);
-  if (m_finished && !m_output_busy)
-    done = true;
-  pthread_mutex_unlock(&m_output_mutex);
-  if (done)
-    m_myself.reset();
-  if (g_advancedSettings.CanLogComponent(LOGVIDEO))
-    CLog::Log(LOGDEBUG, "%s::%s %p (%p) ready_queue(%d) busy_queue(%d) done:%d", CLASSNAME, __func__, buffer, buffer->mmal_buffer, m_output_ready.size(), m_output_busy, done);
-  delete buffer;
-}
-
 bool CMMALVideo::GetPicture(DVDVideoPicture* pDvdVideoPicture)
 {
   if (!m_output_ready.empty())
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h
index 204f004..ab6e958 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h
@@ -42,7 +42,6 @@
 #include "cores/VideoRenderers/BaseRenderer.h"
 
 class CMMALVideo;
-typedef std::shared_ptr<CMMALVideo> MMALVideoPtr;
 
 // a mmal video frame
 class CMMALVideoBuffer
@@ -77,7 +76,7 @@ class CMMALVideo
   virtual ~CMMALVideo();
 
   // Required overrides
-  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options, MMALVideoPtr myself);
+  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
   virtual void Dispose(void);
   virtual int  Decode(uint8_t *pData, int iSize, double dts, double pts);
   virtual void Reset(void);
@@ -91,7 +90,6 @@ class CMMALVideo
   virtual void SetSpeed(int iSpeed);
 
   // MMAL decoder callback routines.
-  void ReleaseBuffer(CMMALVideoBuffer *buffer);
   void Recycle(MMAL_BUFFER_HEADER_T *buffer);
 
   // MMAL decoder callback routines.
@@ -111,14 +109,12 @@ class CMMALVideo
   bool              m_finished;
   float             m_aspect_ratio;
   const char        *m_pFormatName;
-  MMALVideoPtr      m_myself;
 
   std::queue<mmal_demux_packet> m_demux_queue;
   unsigned           m_demux_queue_length;
 
   // mmal output buffers (video frames)
   pthread_mutex_t   m_output_mutex;
-  int m_output_busy;
   std::queue<CMMALVideoBuffer*> m_output_ready;
 
   // initialize mmal and get decoder component

From d93944688cae601453f2439169cf9a5834196177 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Thu, 16 Apr 2015 21:50:10 +0100
Subject: [PATCH 87/89] Remove DVDVideoCodecMMAL wrapper

---
 xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp |   4 +-
 .../DVDCodecs/Video/DVDVideoCodecMMAL.cpp          | 111 ---------------------
 .../dvdplayer/DVDCodecs/Video/DVDVideoCodecMMAL.h  |  52 ----------
 xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h   |   4 +-
 xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in   |   1 -
 5 files changed, 4 insertions(+), 168 deletions(-)
 delete mode 100644 xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMMAL.cpp
 delete mode 100644 xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMMAL.h

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
index 9d8de2a..995a14e 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
@@ -39,7 +39,7 @@
 #if defined(HAS_IMXVPU)
 #include "Video/DVDVideoCodecIMX.h"
 #endif
-#include "Video/DVDVideoCodecMMAL.h"
+#include "Video/MMALCodec.h"
 #include "Video/DVDVideoCodecStageFright.h"
 #if defined(HAS_LIBAMCODEC)
 #include "utils/AMLUtils.h"
@@ -306,7 +306,7 @@ CDVDVideoCodec* CDVDFactoryCodec::CreateVideoCodec(CDVDStreamInfo &hint, unsigne
           hint.codec == AV_CODEC_ID_VP6 || hint.codec == AV_CODEC_ID_VP6F || hint.codec == AV_CODEC_ID_VP6A || hint.codec == AV_CODEC_ID_VP8 ||
           hint.codec == AV_CODEC_ID_THEORA || hint.codec == AV_CODEC_ID_MJPEG || hint.codec == AV_CODEC_ID_MJPEGB || hint.codec == AV_CODEC_ID_VC1 || hint.codec == AV_CODEC_ID_WMV3)
       {
-        if ( (pCodec = OpenCodec(new CDVDVideoCodecMMAL(), hint, options)) ) return pCodec;
+        if ( (pCodec = OpenCodec(new CMMALVideo(), hint, options)) ) return pCodec;
       }
     }
 #endif
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMMAL.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMMAL.cpp
deleted file mode 100644
index 48e347c..0000000
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMMAL.cpp
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- *      Copyright (C) 2010-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#if (defined HAVE_CONFIG_H) && (!defined TARGET_WINDOWS)
-  #include "config.h"
-#elif defined(TARGET_WINDOWS)
-#include "system.h"
-#endif
-
-#if defined(HAS_MMAL)
-#include "DVDClock.h"
-#include "DVDStreamInfo.h"
-#include "DVDVideoCodecMMAL.h"
-#include "settings/Settings.h"
-#include "utils/log.h"
-
-#define CLASSNAME "CDVDVideoCodecMMAL"
-////////////////////////////////////////////////////////////////////////////////////////////
-////////////////////////////////////////////////////////////////////////////////////////////
-CDVDVideoCodecMMAL::CDVDVideoCodecMMAL()
- : m_decoder( new CMMALVideo )
-{
-  CLog::Log(LOGDEBUG, "%s::%s %p\n", CLASSNAME, __func__, this);
-}
-
-CDVDVideoCodecMMAL::~CDVDVideoCodecMMAL()
-{
-  CLog::Log(LOGDEBUG, "%s::%s %p\n", CLASSNAME, __func__, this);
-  Dispose();
-  delete m_decoder;
-  m_decoder = NULL;
-}
-
-bool CDVDVideoCodecMMAL::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
-{
-  return m_decoder->Open(hints, options);
-}
-
-const char* CDVDVideoCodecMMAL::GetName(void)
-{
-  return m_decoder ? m_decoder->GetName() : "mmal-xxx";
-}
-
-void CDVDVideoCodecMMAL::Dispose()
-{
-  m_decoder->Dispose();
-}
-
-void CDVDVideoCodecMMAL::SetDropState(bool bDrop)
-{
-  m_decoder->SetDropState(bDrop);
-}
-
-int CDVDVideoCodecMMAL::Decode(uint8_t* pData, int iSize, double dts, double pts)
-{
-  return m_decoder->Decode(pData, iSize, dts, pts);
-}
-
-unsigned CDVDVideoCodecMMAL::GetAllowedReferences()
-{
-  return m_decoder->GetAllowedReferences();
-}
-
-void CDVDVideoCodecMMAL::Reset(void)
-{
-  m_decoder->Reset();
-}
-
-bool CDVDVideoCodecMMAL::GetPicture(DVDVideoPicture* pDvdVideoPicture)
-{
-  return m_decoder->GetPicture(pDvdVideoPicture);
-}
-
-bool CDVDVideoCodecMMAL::ClearPicture(DVDVideoPicture* pDvdVideoPicture)
-{
-  return m_decoder->ClearPicture(pDvdVideoPicture);
-}
-
-bool CDVDVideoCodecMMAL::GetCodecStats(double &pts, int &droppedPics)
-{
-  return m_decoder->GetCodecStats(pts, droppedPics);
-}
-
-void CDVDVideoCodecMMAL::SetCodecControl(int flags)
-{
-  m_decoder->SetCodecControl(flags);
-}
-
-void CDVDVideoCodecMMAL::SetSpeed(int iSpeed)
-{
-  m_decoder->SetSpeed(iSpeed);
-}
-
-#endif
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMMAL.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMMAL.h
deleted file mode 100644
index 6014363..0000000
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecMMAL.h
+++ /dev/null
@@ -1,52 +0,0 @@
-#pragma once
-/*
- *      Copyright (C) 2010-2013 Team XBMC
- *      http://xbmc.org
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#if defined(HAS_MMAL)
-
-#include "DVDVideoCodec.h"
-#include "MMALCodec.h"
-
-class CMMALVideo;
-class CDVDVideoCodecMMAL : public CDVDVideoCodec
-{
-public:
-  CDVDVideoCodecMMAL();
-  virtual ~CDVDVideoCodecMMAL();
-
-  // Required overrides
-  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
-  virtual void Dispose(void);
-  virtual int  Decode(uint8_t *pData, int iSize, double dts, double pts);
-  virtual void Reset(void);
-  virtual bool GetPicture(DVDVideoPicture *pDvdVideoPicture);
-  virtual bool ClearPicture(DVDVideoPicture* pDvdVideoPicture);
-  virtual unsigned GetAllowedReferences();
-  virtual void SetDropState(bool bDrop);
-  virtual const char* GetName(void);
-  virtual bool GetCodecStats(double &pts, int &droppedPics);
-  virtual void SetCodecControl(int flags);
-  virtual void SetSpeed(int iSpeed);
-
-protected:
-  CMMALVideo *m_decoder;
-};
-
-#endif
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h
index ab6e958..3e444f7 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h
@@ -62,7 +62,7 @@ class CMMALVideoBuffer
 private:
 };
 
-class CMMALVideo
+class CMMALVideo : public CDVDVideoCodec
 {
   typedef struct mmal_demux_packet {
     uint8_t *buff;
@@ -84,7 +84,7 @@ class CMMALVideo
   virtual bool ClearPicture(DVDVideoPicture* pDvdVideoPicture);
   virtual unsigned GetAllowedReferences() { return 3; }
   virtual void SetDropState(bool bDrop);
-  virtual const char* GetName(void) { return (const char*)m_pFormatName; }
+  virtual const char* GetName(void) { return m_pFormatName ? m_pFormatName:"mmal-xxx"; }
   virtual bool GetCodecStats(double &pts, int &droppedPics);
   virtual void SetCodecControl(int flags);
   virtual void SetSpeed(int iSpeed);
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in b/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
index 6f5d3e8..56ec6a3 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
@@ -39,7 +39,6 @@ endif
 
 ifeq (@USE_MMAL@,1)
 SRCS += MMALCodec.cpp
-SRCS += DVDVideoCodecMMAL.cpp
 endif
 
 LIB=Video.a

From 6b1c7ca35ed7a890db47cf528a4a5ebbd468b852 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 17 Apr 2015 15:46:55 +0100
Subject: [PATCH 88/89] Add shared lock around MMAL operations

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp | 17 +++++++++++++++++
 xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h   |  1 +
 2 files changed, 18 insertions(+)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
index 7a45c25..2a6eb78 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
@@ -127,6 +127,7 @@ CMMALVideo::CMMALVideo()
 
 CMMALVideo::~CMMALVideo()
 {
+  CSingleLock lock(m_sharedSection);
   if (g_advancedSettings.CanLogComponent(LOGVIDEO))
     CLog::Log(LOGDEBUG, "%s::%s %p", CLASSNAME, __func__, this);
   assert(m_finished);
@@ -174,6 +175,7 @@ CMMALVideo::~CMMALVideo()
 
 void CMMALVideo::PortSettingsChanged(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
 {
+  CSingleLock lock(m_sharedSection);
   MMAL_EVENT_FORMAT_CHANGED_T *fmt = mmal_event_format_changed_get(buffer);
   mmal_format_copy(m_es_format, fmt->format);
 
@@ -288,6 +290,7 @@ static void dec_output_port_cb_static(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *b
 
 bool CMMALVideo::change_dec_output_format()
 {
+  CSingleLock lock(m_sharedSection);
   MMAL_STATUS_T status;
   if (g_advancedSettings.CanLogComponent(LOGVIDEO))
     CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
@@ -324,6 +327,7 @@ bool CMMALVideo::change_dec_output_format()
 
 bool CMMALVideo::CreateDeinterlace(EINTERLACEMETHOD interlace_method)
 {
+  CSingleLock lock(m_sharedSection);
   MMAL_STATUS_T status;
 
   if (g_advancedSettings.CanLogComponent(LOGVIDEO))
@@ -421,6 +425,7 @@ bool CMMALVideo::CreateDeinterlace(EINTERLACEMETHOD interlace_method)
 
 bool CMMALVideo::DestroyDeinterlace()
 {
+  CSingleLock lock(m_sharedSection);
   MMAL_STATUS_T status;
 
   if (g_advancedSettings.CanLogComponent(LOGVIDEO))
@@ -477,6 +482,7 @@ bool CMMALVideo::DestroyDeinterlace()
 
 bool CMMALVideo::SendCodecConfigData()
 {
+  CSingleLock lock(m_sharedSection);
   MMAL_STATUS_T status;
   if (!m_dec_input_pool)
     return true;
@@ -506,6 +512,7 @@ bool CMMALVideo::SendCodecConfigData()
 
 bool CMMALVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
 {
+  CSingleLock lock(m_sharedSection);
   if (g_advancedSettings.CanLogComponent(LOGVIDEO))
     CLog::Log(LOGDEBUG, "%s::%s usemmal:%d software:%d %dx%d", CLASSNAME, __func__, CSettings::Get().GetBool("videoplayer.usemmal"), hints.software, hints.width, hints.height);
 
@@ -708,6 +715,7 @@ bool CMMALVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
   m_preroll = !m_hints.stills;
   m_speed = DVD_PLAYSPEED_NORMAL;
 
+  lock.Leave();
   g_renderManager.PassCookie(this);
   return true;
 }
@@ -715,6 +723,7 @@ bool CMMALVideo::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
 void CMMALVideo::Dispose()
 {
   g_renderManager.PassCookie(NULL);
+  CSingleLock lock(m_sharedSection);
   m_finished = true;
   Reset();
 }
@@ -727,6 +736,7 @@ void CMMALVideo::SetDropState(bool bDrop)
 
 int CMMALVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
 {
+  CSingleLock lock(m_sharedSection);
   //if (g_advancedSettings.CanLogComponent(LOGVIDEO))
   //  CLog::Log(LOGDEBUG, "%s::%s - %-8p %-6d dts:%.3f pts:%.3f ready_queue(%d)",
   //    CLASSNAME, __func__, pData, iSize, dts == DVD_NOPTS_VALUE ? 0.0 : dts*1e-6, pts == DVD_NOPTS_VALUE ? 0.0 : pts*1e-6, m_output_ready.size());
@@ -875,6 +885,7 @@ int CMMALVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
     if (g_advancedSettings.CanLogComponent(LOGVIDEO))
       CLog::Log(LOGDEBUG, "%s::%s - Nothing to do: ready_queue(%d) demux_queue(%d) space(%d) preroll(%d)",
         CLASSNAME, __func__, m_output_ready.size(), m_demux_queue_length, mmal_queue_length(m_dec_input_pool->queue) * m_dec_input->buffer_size, m_preroll);
+    lock.Leave();
     Sleep(10); // otherwise we busy spin
   }
   return ret;
@@ -882,6 +893,7 @@ int CMMALVideo::Decode(uint8_t* pData, int iSize, double dts, double pts)
 
 void CMMALVideo::Reset(void)
 {
+  CSingleLock lock(m_sharedSection);
   if (g_advancedSettings.CanLogComponent(LOGVIDEO))
     CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
 
@@ -946,6 +958,7 @@ void CMMALVideo::SetSpeed(int iSpeed)
 
 void CMMALVideo::Recycle(MMAL_BUFFER_HEADER_T *buffer)
 {
+  CSingleLock lock(m_sharedSection);
   if (g_advancedSettings.CanLogComponent(LOGVIDEO))
     CLog::Log(LOGDEBUG, "%s::%s %p", CLASSNAME, __func__, buffer);
 
@@ -971,6 +984,7 @@ void CMMALVideo::Recycle(MMAL_BUFFER_HEADER_T *buffer)
 
 bool CMMALVideo::GetPicture(DVDVideoPicture* pDvdVideoPicture)
 {
+  CSingleLock lock(m_sharedSection);
   if (!m_output_ready.empty())
   {
     CMMALVideoBuffer *buffer;
@@ -1030,6 +1044,7 @@ bool CMMALVideo::GetPicture(DVDVideoPicture* pDvdVideoPicture)
 
 bool CMMALVideo::ClearPicture(DVDVideoPicture* pDvdVideoPicture)
 {
+  CSingleLock lock(m_sharedSection);
   if (pDvdVideoPicture->format == RENDER_FMT_MMAL)
   {
     if (g_advancedSettings.CanLogComponent(LOGVIDEO))
@@ -1042,12 +1057,14 @@ bool CMMALVideo::ClearPicture(DVDVideoPicture* pDvdVideoPicture)
 
 bool CMMALVideo::GetCodecStats(double &pts, int &droppedPics)
 {
+  CSingleLock lock(m_sharedSection);
   droppedPics= -1;
   return false;
 }
 
 void CMMALVideo::SetCodecControl(int flags)
 {
+  CSingleLock lock(m_sharedSection);
   m_codecControlFlags = flags;
   if (g_advancedSettings.CanLogComponent(LOGVIDEO))
     CLog::Log(LOGDEBUG, "%s::%s flags:%x", CLASSNAME, __func__, flags);
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h
index 3e444f7..e686b4b 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h
@@ -132,6 +132,7 @@ class CMMALVideo : public CDVDVideoCodec
   bool              m_preroll;
   int               m_codecControlFlags;
 
+  CCriticalSection m_sharedSection;
   MMAL_COMPONENT_T *m_dec;
   MMAL_PORT_T *m_dec_input;
   MMAL_PORT_T *m_dec_output;

From ec9d208ad8e921eb4479279154fe4b477d1f9c71 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 17 Apr 2015 15:59:12 +0100
Subject: [PATCH 89/89] Add shared lock around MMAL operations

---
 xbmc/cores/VideoRenderers/MMALRenderer.cpp | 13 +++++++++++++
 xbmc/cores/VideoRenderers/MMALRenderer.h   |  1 +
 2 files changed, 14 insertions(+)

diff --git a/xbmc/cores/VideoRenderers/MMALRenderer.cpp b/xbmc/cores/VideoRenderers/MMALRenderer.cpp
index fe3dce4..7ebc2c9 100644
--- a/xbmc/cores/VideoRenderers/MMALRenderer.cpp
+++ b/xbmc/cores/VideoRenderers/MMALRenderer.cpp
@@ -44,6 +44,7 @@
 
 void CMMALRenderer::Prime()
 {
+  CSingleLock lock(m_sharedSection);
   #if defined(MMAL_DEBUG_VERBOSE)
   CLog::Log(LOGDEBUG, "%s::%s format:%d dec:%p pool:%p", CLASSNAME, __func__, m_format, m_mmal_video, m_vout_input_pool);
   #endif
@@ -69,6 +70,7 @@ void CMMALRenderer::Prime()
 
 void *CMMALRenderer::PassCookie(void *cookie)
 {
+  CSingleLock lock(m_sharedSection);
   m_mmal_video = (CMMALVideo *)cookie;
   #if defined(MMAL_DEBUG_VERBOSE)
   CLog::Log(LOGDEBUG, "%s::%s cookie:%p", CLASSNAME, __func__, cookie);
@@ -90,6 +92,7 @@ static void vout_control_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer
 
 void CMMALRenderer::vout_input_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
 {
+  CSingleLock lock(m_sharedSection);
   #if defined(MMAL_DEBUG_VERBOSE)
   CMMALVideoBuffer *omvb = (CMMALVideoBuffer *)buffer->user_data;
   CLog::Log(LOGDEBUG, "%s::%s port:%p buffer %p (%p), len %d cmd:%x f:%x", CLASSNAME, __func__, port, buffer, omvb, buffer->length, buffer->cmd, buffer->flags);
@@ -116,6 +119,7 @@ static void vout_input_port_cb_static(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *b
 
 bool CMMALRenderer::init_vout(ERenderFormat format)
 {
+  CSingleLock lock(m_sharedSection);
   bool formatChanged = m_format != format;
   MMAL_STATUS_T status;
 
@@ -254,6 +258,7 @@ CMMALRenderer::CMMALRenderer()
 
 CMMALRenderer::~CMMALRenderer()
 {
+  CSingleLock lock(m_sharedSection);
   CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
   // shutdown thread
   mmal_queue_put(m_release_queue, &m_quit_packet);
@@ -276,6 +281,7 @@ void CMMALRenderer::AddProcessor(CMMALVideoBuffer *buffer, int index)
 
 bool CMMALRenderer::Configure(unsigned int width, unsigned int height, unsigned int d_width, unsigned int d_height, float fps, unsigned flags, ERenderFormat format, unsigned extended_format, unsigned int orientation)
 {
+  CSingleLock lock(m_sharedSection);
   ReleaseBuffers();
 
   m_sourceWidth  = width;
@@ -306,6 +312,7 @@ bool CMMALRenderer::Configure(unsigned int width, unsigned int height, unsigned
 
 int CMMALRenderer::GetImage(YV12Image *image, int source, bool readonly)
 {
+  CSingleLock lock(m_sharedSection);
 #if defined(MMAL_DEBUG_VERBOSE)
   CLog::Log(LOGDEBUG, "%s::%s - %p %d %d", CLASSNAME, __func__, image, source, readonly);
 #endif
@@ -403,6 +410,7 @@ void CMMALRenderer::Update()
 
 void CMMALRenderer::RenderUpdate(bool clear, DWORD flags, DWORD alpha)
 {
+  CSingleLock lock(m_sharedSection);
   int source = m_iYV12RenderBuffer;
 #if defined(MMAL_DEBUG_VERBOSE)
   CLog::Log(LOGDEBUG, "%s::%s - %d %x %d %d", CLASSNAME, __func__, clear, flags, alpha, source);
@@ -463,6 +471,7 @@ void CMMALRenderer::RenderUpdate(bool clear, DWORD flags, DWORD alpha)
 
 void CMMALRenderer::FlipPage(int source)
 {
+  CSingleLock lock(m_sharedSection);
   if (!m_bConfigured || m_format == RENDER_FMT_BYPASS)
     return;
 
@@ -475,6 +484,7 @@ void CMMALRenderer::FlipPage(int source)
 
 unsigned int CMMALRenderer::PreInit()
 {
+  CSingleLock lock(m_sharedSection);
   m_bConfigured = false;
   UnInit();
 
@@ -500,12 +510,14 @@ unsigned int CMMALRenderer::PreInit()
 
 void CMMALRenderer::ReleaseBuffers()
 {
+  CSingleLock lock(m_sharedSection);
   for (int i=0; i<NUM_BUFFERS; i++)
     ReleaseBuffer(i);
 }
 
 void CMMALRenderer::UnInitMMAL()
 {
+  CSingleLock lock(m_sharedSection);
   CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
   if (m_vout)
   {
@@ -622,6 +634,7 @@ EINTERLACEMETHOD CMMALRenderer::AutoInterlaceMethod()
 
 void CMMALRenderer::SetVideoRect(const CRect& InSrcRect, const CRect& InDestRect)
 {
+  CSingleLock lock(m_sharedSection);
   assert(g_graphicsContext.GetStereoView() != RENDER_STEREO_VIEW_RIGHT);
 
   if (!m_vout_input)
diff --git a/xbmc/cores/VideoRenderers/MMALRenderer.h b/xbmc/cores/VideoRenderers/MMALRenderer.h
index a694182..6474c1b 100644
--- a/xbmc/cores/VideoRenderers/MMALRenderer.h
+++ b/xbmc/cores/VideoRenderers/MMALRenderer.h
@@ -112,6 +112,7 @@ class CMMALRenderer : public CBaseRenderer, public CThread
   RENDER_STEREO_MODE        m_display_stereo_mode;
   bool                      m_StereoInvert;
 
+  CCriticalSection m_sharedSection;
   MMAL_COMPONENT_T *m_vout;
   MMAL_PORT_T *m_vout_input;
   MMAL_POOL_T *m_vout_input_pool;
